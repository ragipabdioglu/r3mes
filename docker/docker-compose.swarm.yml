version: '3.8'

# Docker Swarm Production Stack with External Secrets
# Usage: 
#   1. Initialize swarm: docker swarm init
#   2. Create secrets: bash scripts/create_swarm_secrets.sh
#   3. Deploy: docker stack deploy -c docker-compose.swarm.yml r3mes
#
# This configuration uses Docker Swarm's native secrets management
# which provides better security than file-based secrets

services:
  # PostgreSQL Database
  postgres:
    image: postgres:16-alpine
    secrets:
      - postgres_password
      - postgres_user
    environment:
      POSTGRES_USER_FILE: /run/secrets/postgres_user
      POSTGRES_PASSWORD_FILE: /run/secrets/postgres_password
      POSTGRES_DB: ${POSTGRES_DB:-r3mes}
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - r3mes-internal
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '1'
          memory: 1G
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
        window: 120s
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$(cat /run/secrets/postgres_user)"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  # Redis Cache
  redis:
    image: redis:7-alpine
    secrets:
      - redis_password
    command: >
      sh -c "
        REDIS_PASS=$$(cat /run/secrets/redis_password);
        exec redis-server
        --appendonly yes
        --requirepass $$REDIS_PASS
        --maxmemory 1gb
        --maxmemory-policy allkeys-lru
        --tcp-backlog 511
        --timeout 0
        --tcp-keepalive 300
      "
    volumes:
      - redis_data:/data
    networks:
      - r3mes-internal
    deploy:
      mode: replicated
      replicas: 1
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
    healthcheck:
      test: ["CMD", "sh", "-c", "redis-cli -a $$(cat /run/secrets/redis_password) ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  # IPFS Node
  ipfs:
    image: ipfs/kubo:latest
    environment:
      - IPFS_PROFILE=server
    volumes:
      - ipfs_data:/data/ipfs
    networks:
      - r3mes-internal
    deploy:
      mode: replicated
      replicas: 1
      resources:
        limits:
          cpus: '1'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 1G
      restart_policy:
        condition: on-failure
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:5001/api/v0/version"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Blockchain Node
  remesd:
    image: r3mes/remesd:${REMESD_VERSION:-latest}
    secrets:
      - validator_key
      - node_key
    environment:
      - CHAIN_ID=${CHAIN_ID:-remes-mainnet-1}
      - R3MES_NETWORK=${R3MES_NETWORK:-mainnet}
    volumes:
      - blockchain_data:/app/.remesd
    ports:
      - target: 26656
        published: 26656
        protocol: tcp
        mode: host
      - target: 26657
        published: 26657
        protocol: tcp
        mode: host
    networks:
      - r3mes-internal
      - r3mes-public
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: '4'
          memory: 8G
        reservations:
          cpus: '2'
          memory: 4G
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 3
        window: 300s
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:26657/status"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 120s

  # Backend API
  backend:
    image: r3mes/backend:${BACKEND_VERSION:-latest}
    secrets:
      - postgres_password
      - postgres_user
      - redis_password
      - jwt_secret
      - api_secret_key
    environment:
      R3MES_ENV: production
      DATABASE_TYPE: postgresql
      POSTGRES_USER_FILE: /run/secrets/postgres_user
      POSTGRES_PASSWORD_FILE: /run/secrets/postgres_password
      POSTGRES_HOST: postgres
      POSTGRES_PORT: 5432
      POSTGRES_DB: ${POSTGRES_DB:-r3mes}
      REDIS_PASSWORD_FILE: /run/secrets/redis_password
      REDIS_HOST: redis
      REDIS_PORT: 6379
      JWT_SECRET_FILE: /run/secrets/jwt_secret
      API_SECRET_KEY_FILE: /run/secrets/api_secret_key
      BLOCKCHAIN_RPC_URL: http://remesd:26657
      BLOCKCHAIN_GRPC_URL: remesd:9090
      R3MES_IPFS_URL: http://ipfs:5001
      CORS_ALLOWED_ORIGINS: ${CORS_ALLOWED_ORIGINS}
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    networks:
      - r3mes-internal
    deploy:
      mode: replicated
      replicas: ${BACKEND_REPLICAS:-2}
      update_config:
        parallelism: 1
        delay: 10s
        failure_action: rollback
        order: start-first
      rollback_config:
        parallelism: 1
        delay: 10s
      resources:
        limits:
          cpus: '2'
          memory: 4G
        reservations:
          cpus: '1'
          memory: 2G
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Frontend
  frontend:
    image: r3mes/frontend:${FRONTEND_VERSION:-latest}
    environment:
      NODE_ENV: production
      NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL}
      NEXT_PUBLIC_CHAIN_ID: ${CHAIN_ID:-remes-mainnet-1}
    networks:
      - r3mes-internal
    deploy:
      mode: replicated
      replicas: ${FRONTEND_REPLICAS:-2}
      update_config:
        parallelism: 1
        delay: 10s
        failure_action: rollback
        order: start-first
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
      restart_policy:
        condition: on-failure
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Nginx Load Balancer
  nginx:
    image: r3mes/nginx:${NGINX_VERSION:-latest}
    ports:
      - target: 80
        published: 80
        protocol: tcp
        mode: ingress
      - target: 443
        published: 443
        protocol: tcp
        mode: ingress
    secrets:
      - ssl_certificate
      - ssl_private_key
    environment:
      DOMAIN: ${DOMAIN:-r3mes.network}
    volumes:
      - nginx_certs:/etc/letsencrypt
    networks:
      - r3mes-internal
      - r3mes-public
    deploy:
      mode: global
      update_config:
        parallelism: 1
        delay: 10s
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
      restart_policy:
        condition: on-failure
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Prometheus
  prometheus:
    image: prom/prometheus:latest
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=30d'
      - '--web.enable-lifecycle'
    volumes:
      - prometheus_data:/prometheus
    configs:
      - source: prometheus_config
        target: /etc/prometheus/prometheus.yml
      - source: prometheus_alerts
        target: /etc/prometheus/alerts/r3mes_alerts.yml
    networks:
      - r3mes-internal
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: '1'
          memory: 2G
      restart_policy:
        condition: on-failure

  # Grafana
  grafana:
    image: grafana/grafana:latest
    secrets:
      - grafana_admin_password
    environment:
      - GF_SECURITY_ADMIN_USER=${GRAFANA_ADMIN_USER:-admin}
      - GF_SECURITY_ADMIN_PASSWORD__FILE=/run/secrets/grafana_admin_password
      - GF_USERS_ALLOW_SIGN_UP=false
      - GF_SERVER_ROOT_URL=${GRAFANA_ROOT_URL}
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - r3mes-internal
    deploy:
      mode: replicated
      replicas: 1
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
      restart_policy:
        condition: on-failure

# Secrets - External (created via docker secret create)
secrets:
  postgres_password:
    external: true
  postgres_user:
    external: true
  redis_password:
    external: true
  grafana_admin_password:
    external: true
  jwt_secret:
    external: true
  api_secret_key:
    external: true
  validator_key:
    external: true
  node_key:
    external: true
  ssl_certificate:
    external: true
  ssl_private_key:
    external: true

# Configs - External (created via docker config create)
configs:
  prometheus_config:
    external: true
  prometheus_alerts:
    external: true

# Volumes
volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  ipfs_data:
    driver: local
  blockchain_data:
    driver: local
  prometheus_data:
    driver: local
  grafana_data:
    driver: local
  nginx_certs:
    driver: local

# Networks
networks:
  r3mes-internal:
    driver: overlay
    attachable: true
    internal: true
  r3mes-public:
    driver: overlay
    attachable: true
