syntax = "proto3";
package remes.remes.v1;

import "amino/amino.proto";
import "gogoproto/gogo.proto";
import "google/protobuf/timestamp.proto";
import "remes/remes/v1/stored_gradient.proto";

option go_package = "remes/x/remes/types";

// GlobalModelState represents the current global model state
message GlobalModelState {
  option (amino.name) = "remes/x/remes/GlobalModelState";
  option (gogoproto.equal) = true;

  // model_ipfs_hash is the IPFS hash of the current global model
  string model_ipfs_hash = 1;

  // model_version is the version of the current model (e.g., "v1.0.0")
  string model_version = 2;

  // last_updated_height is the block height when the model was last updated
  int64 last_updated_height = 3;

  // last_updated_time is the timestamp when the model was last updated
  google.protobuf.Timestamp last_updated_time = 4 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
  
  // training_round_id is the training round ID of the current global model
  uint64 training_round_id = 5;
  
  // last_aggregation_id is the aggregation ID that was used to create this global model
  uint64 last_aggregation_id = 6;
}

// AggregationRecord represents an aggregation record stored on-chain
message AggregationRecord {
  option (amino.name) = "remes/x/remes/AggregationRecord";
  option (gogoproto.equal) = true;

  // aggregation_id is the unique identifier for this aggregation
  uint64 aggregation_id = 1;

  // proposer is the address of the proposer who performed aggregation
  string proposer = 2;

  // aggregated_gradient_ipfs_hash is the IPFS hash of the aggregated gradient result
  string aggregated_gradient_ipfs_hash = 3;

  // merkle_root is the Merkle root hash of all included gradients
  string merkle_root = 4;

  // participant_gradient_ids are the IDs of all gradients included in aggregation
  repeated uint64 participant_gradient_ids = 5;

  // training_round_id is the identifier for the training round
  uint64 training_round_id = 6;

  // model_version is the version of the model used
  string model_version = 7;

  // submitted_at_height is the block height when this aggregation was submitted
  int64 submitted_at_height = 8;

  // status is the current status (pending, finalized, challenged)
  string status = 9;

  // challenge_deadline_height is the block height when challenge period ends (submitted_at_height + challenge_period_blocks)
  int64 challenge_deadline_height = 10;
}

// AggregationCommitment represents a commitment to an aggregation result (commit-reveal scheme)
message AggregationCommitment {
  option (amino.name) = "remes/x/remes/AggregationCommitment";
  option (gogoproto.equal) = true;

  // commitment_id is the unique identifier for this commitment
  uint64 commitment_id = 1;

  // proposer is the address of the proposer who made the commitment
  string proposer = 2;

  // commitment_hash is the hash of (aggregated_hash + merkle_root + participant_ids + salt)
  string commitment_hash = 3;

  // training_round_id is the identifier for the training round
  uint64 training_round_id = 4;

  // participant_gradient_ids are the IDs of all gradients included in aggregation
  repeated uint64 participant_gradient_ids = 5;

  // committed_at_height is the block height when this commitment was made
  int64 committed_at_height = 6;

  // reveal_deadline_height is the block height when reveal period starts
  int64 reveal_deadline_height = 7;

  // status is the current status (committed, revealed, expired)
  string status = 8;

  // revealed_aggregation_id is the aggregation ID created after reveal (if revealed)
  uint64 revealed_aggregation_id = 9;
}

// MiningContribution represents a miner's contribution to the network
message MiningContribution {
  option (amino.name) = "remes/x/remes/MiningContribution";
  option (gogoproto.equal) = true;

  // miner_address is the address of the miner
  string miner_address = 1;

  // total_submissions is the total number of gradient submissions
  uint64 total_submissions = 2;

  // successful_submissions is the number of successful submissions
  uint64 successful_submissions = 3;

  // trust_score is the reputation score (0.0 to 1.0)
  string trust_score = 4;

  // reputation_tier is the tier (excellent, trusted, developing, new)
  string reputation_tier = 5;

  // slashing_events is the number of slashing events
  uint64 slashing_events = 6;

  // last_submission_height is the block height of the last submission
  int64 last_submission_height = 7;

  // traps_caught is the number of trap jobs successfully completed
  uint64 traps_caught = 8;

  // traps_failed is the number of trap jobs that failed verification
  uint64 traps_failed = 9;

  // fraud_score is the fraud risk score (0.0 to 1.0, higher = more fraudulent)
  string fraud_score = 10;
}

// ChallengeRecord represents a challenge to an aggregation
message ChallengeRecord {
  option (amino.name) = "remes/x/remes/ChallengeRecord";
  option (gogoproto.equal) = true;

  // challenge_id is the unique identifier for this challenge
  uint64 challenge_id = 1;

  // challenger is the address of the node challenging the aggregation
  string challenger = 2;

  // aggregation_id is the ID of the aggregation being challenged
  uint64 aggregation_id = 3;

  // reason is the reason for the challenge
  string reason = 4;

  // evidence_ipfs_hash is the IPFS hash of evidence supporting the challenge
  string evidence_ipfs_hash = 5;

  // status is the current status (pending, resolved, rejected)
  string status = 6;

  // created_at_height is the block height when this challenge was created
  int64 created_at_height = 7;

  // cpu_verification_panel is the list of validator addresses selected for CPU verification
  repeated string cpu_verification_panel = 8;

  // cpu_verification_results stores verification results from panel validators
  repeated CPUVerificationResult cpu_verification_results = 9;

  // resolution_height is the block height when challenge was resolved
  int64 resolution_height = 10;

  // fraud_detected indicates if fraud was detected
  bool fraud_detected = 11;

  // layer indicates the verification layer (1=GPU-to-GPU, 2=High-Stakes Challenge, 3=CPU Iron Sandbox)
  uint32 layer = 12;

  // bond_amount is the bond amount required for Layer 2 challenge (10x base reward)
  string bond_amount = 13; // sdk.Coin format

  // random_verifier is the randomly selected GPU verifier for Layer 2
  string random_verifier = 14;

  // random_verifier_result is the result from random verifier ("valid", "invalid", "pending")
  string random_verifier_result = 15;

  // miner_weights_ipfs is the IPFS hash of miner's model weights (for Loss-Based Spot Checking)
  string miner_weights_ipfs = 16;

  // data_batch_seed is the VRF seed for deterministic batch selection (for Loss-Based Spot Checking)
  uint64 data_batch_seed = 17;

  // verifier_loss is the loss calculated by the random verifier (BitNet integer format)
  string verifier_loss = 18;

  // loss_match indicates if miner's claimed loss matches verifier's calculated loss (within tolerance)
  bool loss_match = 19;

  // loss_tolerance is the tolerance used for loss comparison (BitNet integer format, default: Â±1)
  string loss_tolerance = 20;
}

// CPUVerificationResult represents a CPU verification result from a validator
message CPUVerificationResult {
  option (amino.name) = "remes/x/remes/CPUVerificationResult";
  option (gogoproto.equal) = true;

  // validator_address is the address of the validator
  string validator_address = 1;

  // is_valid indicates if the gradient is valid
  bool is_valid = 2;

  // computed_hash is the hash computed by the validator
  string computed_hash = 3;

  // expected_hash is the expected hash from the aggregation
  string expected_hash = 4;

  // verification_time is when the verification was performed
  google.protobuf.Timestamp verification_time = 5 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];
}

// ParticipantSyncState represents a participant's synchronization state
message ParticipantSyncState {
  option (amino.name) = "remes/x/remes/ParticipantSyncState";
  option (gogoproto.equal) = true;

  // participant_address is the address of the participant (miner or node)
  string participant_address = 1;

  // current_model_version is the model version the participant is currently using
  string current_model_version = 2;

  // last_sync_height is the block height when the participant last synced
  int64 last_sync_height = 3;

  // last_sync_time is the timestamp when the participant last synced
  google.protobuf.Timestamp last_sync_time = 4 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];

  // is_synced indicates if the participant is synced with the latest model version
  bool is_synced = 5;

  // sync_lag_blocks is the number of blocks behind the participant is
  int64 sync_lag_blocks = 6;

  // participant_type is the type of participant (miner, validator, serving_node)
  string participant_type = 7;

  // is_partitioned indicates if the participant is currently partitioned
  bool is_partitioned = 8;

  // partition_detected_at is the block height when partition was detected
  int64 partition_detected_at = 9;

  // partition_detected_time is the timestamp when partition was detected
  google.protobuf.Timestamp partition_detected_time = 10 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];

  // partition_recovered_at is the block height when partition was recovered
  int64 partition_recovered_at = 11;

  // partition_recovered_time is the timestamp when partition was recovered
  google.protobuf.Timestamp partition_recovered_time = 12 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];
}

// PartitionRecoveryInfo contains information for partition recovery
message PartitionRecoveryInfo {
  option (amino.name) = "remes/x/remes/PartitionRecoveryInfo";
  option (gogoproto.equal) = true;

  // participant_address is the address of the participant
  string participant_address = 1;

  // was_partitioned indicates if the participant was partitioned
  bool was_partitioned = 2;

  // partition_duration is the duration of the partition in blocks
  int64 partition_duration = 3;

  // recovery_type is the type of recovery (incremental, full_catchup)
  string recovery_type = 4;

  // requires_full_sync indicates if full sync is required
  bool requires_full_sync = 5;

  // sync_lag_blocks is the number of blocks behind
  int64 sync_lag_blocks = 6;

  // global_state is the current global model state (if incremental recovery)
  GlobalModelState global_state = 7 [(gogoproto.nullable) = false];

  // catch_up_gradients are the gradients needed for catch-up (if incremental recovery)
  repeated StoredGradient catch_up_gradients = 8 [(gogoproto.nullable) = false];
}

// ProofOfReplication represents a cryptographic proof that a miner stores actual data
message ProofOfReplication {
  option (amino.name) = "remes/x/remes/ProofOfReplication";
  option (gogoproto.equal) = true;

  // data_hash is the hash of the original gradient data
  string data_hash = 1;

  // replica_hash is the hash of the stored replica (miner-specific encoding)
  string replica_hash = 2;

  // merkle_proof is the Merkle proof of inclusion (serialized)
  bytes merkle_proof = 3;

  // storage_proof is the proof that data is stored (serialized)
  bytes storage_proof = 4;

  // replication_id is the unique replication identifier
  string replication_id = 5;

  // miner_address is the address of the miner storing the replica
  string miner_address = 6;

  // timestamp is when replication occurred (Unix timestamp)
  int64 timestamp = 7;
}

// PartitionStatus represents the partition status of a participant
message PartitionStatus {
  option (amino.name) = "remes/x/remes/PartitionStatus";
  option (gogoproto.equal) = true;

  // is_partitioned indicates if the participant is currently partitioned
  bool is_partitioned = 1;

  // sync_lag_blocks is the number of blocks behind
  int64 sync_lag_blocks = 2;

  // time_since_last_sync is the time since last sync
  string time_since_last_sync = 3;

  // last_sync_height is the block height of last sync
  int64 last_sync_height = 4;

  // last_sync_time is the timestamp of last sync
  google.protobuf.Timestamp last_sync_time = 5 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];

  // partition_detected_at is the block height when partition was detected
  int64 partition_detected_at = 6;

  // partition_recovered_at is the block height when partition was recovered
  int64 partition_recovered_at = 7;

  // partition_duration is the duration of the partition in blocks
  int64 partition_duration = 8;
}

// ConvergenceMetrics tracks model convergence metrics
message ConvergenceMetrics {
  option (amino.name) = "remes/x/remes/ConvergenceMetrics";
  option (gogoproto.equal) = true;

  // training_round_id is the training round identifier
  uint64 training_round_id = 1;

  // average_loss is the average loss value (BitNet integer format)
  string average_loss = 2;

  // loss_history is the last N loss values for trend analysis (BitNet integer format)
  repeated string loss_history = 3;

  // convergence_rate is the rate of loss reduction (decimal string)
  string convergence_rate = 4;

  // is_converged indicates if the model has converged
  bool is_converged = 5;

  // convergence_threshold is the loss change threshold for convergence (decimal string)
  string convergence_threshold = 6;

  // last_updated_height is the block height when metrics were last updated
  int64 last_updated_height = 7;
}

// PinInfo represents information about a pinned IPFS content
message PinInfo {
  option (amino.name) = "remes/x/remes/PinInfo";
  option (gogoproto.equal) = true;

  // pinner is the address of the node that pinned the content
  string pinner = 1;

  // cid is the IPFS content identifier
  string cid = 2;

  // size_bytes is the size of the pinned content in bytes
  uint64 size_bytes = 3;

  // pinned_at is the Unix timestamp when the content was pinned
  int64 pinned_at = 4;

  // unpinned_at is the Unix timestamp when the content was unpinned (0 if still pinned)
  int64 unpinned_at = 5;
}

// AggregationIDList stores a list of aggregation IDs for the deadline index
message AggregationIDList {
  option (amino.name) = "remes/x/remes/AggregationIDList";
  option (gogoproto.equal) = true;
  
  repeated uint64 aggregation_ids = 1;
}

