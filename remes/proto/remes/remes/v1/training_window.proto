syntax = "proto3";
package remes.remes.v1;

import "amino/amino.proto";
import "gogoproto/gogo.proto";
import "google/protobuf/timestamp.proto";
import "remes/remes/v1/subnet.proto";

option go_package = "remes/x/remes/types";

// TrainingWindow represents a training window for async rollup
message TrainingWindow {
  option (amino.name) = "remes/x/remes/TrainingWindow";
  option (gogoproto.equal) = true;

  // window_id is the unique identifier for this window
  uint64 window_id = 1;

  // start_height is the block height when the window started
  int64 start_height = 2;

  // end_height is the block height when the window ends (StartHeight + 100 blocks)
  int64 end_height = 3;

  // status is the current status ("collecting", "aggregating", "finalized")
  string status = 4;

  // gradient_hashes is the list of IPFS hashes submitted during this window
  repeated string gradient_hashes = 5;

  // aggregator_node is the proposer address assigned to aggregate gradients
  string aggregator_node = 6;

  // aggregation_hash is the IPFS hash of the final aggregated result
  string aggregation_hash = 7;

  // model_update_hash is the IPFS hash of updated model weights
  string model_update_hash = 8;

  // global_seed is the deterministic seed derived from block hash
  bytes global_seed = 9;

  // created_at is when this window was created
  google.protobuf.Timestamp created_at = 10 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];

  // finalized_at is when this window was finalized (if applicable)
  google.protobuf.Timestamp finalized_at = 11 [(gogoproto.nullable) = true, (gogoproto.stdtime) = true];
}

// AsyncGradientSubmission represents an asynchronous gradient submission
message AsyncGradientSubmission {
  option (amino.name) = "remes/x/remes/AsyncGradientSubmission";
  option (gogoproto.equal) = true;

  // submission_id is the unique identifier for this submission
  uint64 submission_id = 1;

  // window_id is the training window this submission belongs to
  uint64 window_id = 2;

  // miner_address is the address of the miner who submitted the gradient
  string miner_address = 3;

  // gradient_hash is the IPFS hash of the gradient (Python miner uploaded directly to IPFS)
  string gradient_hash = 4;

  // subnet_id is the subnet ID this gradient belongs to
  uint64 subnet_id = 5;

  // layer_range is the layer range that was trained
  LayerRange layer_range = 6 [(gogoproto.nullable) = false];

  // timestamp is when this submission was created
  google.protobuf.Timestamp timestamp = 7 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];

  // credit_record indicates this is a credit record (on-chain credit, not immediate update)
  bool credit_record = 8;
}

// LazyAggregation represents lazy aggregation at window boundary
message LazyAggregation {
  option (amino.name) = "remes/x/remes/LazyAggregation";
  option (gogoproto.equal) = true;

  // aggregation_id is the unique identifier for this lazy aggregation
  uint64 aggregation_id = 1;

  // window_id is the training window this aggregation belongs to
  uint64 window_id = 2;

  // aggregator_node is the proposer address that performed aggregation
  string aggregator_node = 3;

  // collected_gradients is the list of all gradient hashes collected in the window
  repeated string collected_gradients = 4;

  // aggregation_method is the method used ("weighted_average", "median", "trimmed_mean")
  string aggregation_method = 5;

  // result_hash is the IPFS hash of the aggregated result
  string result_hash = 6;

  // merkle_root is the Merkle root for verification
  bytes merkle_root = 7;

  // submission_height is the block height when aggregation was submitted
  int64 submission_height = 8;

  // created_at is when this aggregation was created
  google.protobuf.Timestamp created_at = 9 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
}

