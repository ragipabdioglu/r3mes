// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: remes/remes/v1/dataset.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DatasetProposal represents a governance proposal for dataset approval
type DatasetProposal struct {
	// proposal_id is the unique identifier for the proposal
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// proposer is the address of the proposer
	Proposer string `protobuf:"bytes,2,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// dataset_ipfs_hash is the IPFS hash of the dataset
	DatasetIpfsHash string `protobuf:"bytes,3,opt,name=dataset_ipfs_hash,json=datasetIpfsHash,proto3" json:"dataset_ipfs_hash,omitempty"`
	// dataset_metadata contains metadata about the dataset
	Metadata DatasetMetadata `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata"`
	// deposit is the deposit amount required for proposal
	Deposit string `protobuf:"bytes,5,opt,name=deposit,proto3" json:"deposit,omitempty"`
	// voting_period_end is when the voting period ends
	VotingPeriodEnd time.Time `protobuf:"bytes,6,opt,name=voting_period_end,json=votingPeriodEnd,proto3,stdtime" json:"voting_period_end"`
	// status is the proposal status
	Status string `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	// submit_time is when the proposal was submitted
	SubmitTime time.Time `protobuf:"bytes,8,opt,name=submit_time,json=submitTime,proto3,stdtime" json:"submit_time"`
	// total_votes is the total voting power cast
	TotalVotes string `protobuf:"bytes,9,opt,name=total_votes,json=totalVotes,proto3" json:"total_votes,omitempty"`
	// yes_votes is the voting power for "yes"
	YesVotes string `protobuf:"bytes,10,opt,name=yes_votes,json=yesVotes,proto3" json:"yes_votes,omitempty"`
	// no_votes is the voting power for "no"
	NoVotes string `protobuf:"bytes,11,opt,name=no_votes,json=noVotes,proto3" json:"no_votes,omitempty"`
	// abstain_votes is the voting power for "abstain"
	AbstainVotes string `protobuf:"bytes,12,opt,name=abstain_votes,json=abstainVotes,proto3" json:"abstain_votes,omitempty"`
}

func (m *DatasetProposal) Reset()         { *m = DatasetProposal{} }
func (m *DatasetProposal) String() string { return proto.CompactTextString(m) }
func (*DatasetProposal) ProtoMessage()    {}
func (*DatasetProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0a6ac87bf3a5fe4, []int{0}
}
func (m *DatasetProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatasetProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatasetProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatasetProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatasetProposal.Merge(m, src)
}
func (m *DatasetProposal) XXX_Size() int {
	return m.Size()
}
func (m *DatasetProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_DatasetProposal.DiscardUnknown(m)
}

var xxx_messageInfo_DatasetProposal proto.InternalMessageInfo

func (m *DatasetProposal) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *DatasetProposal) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *DatasetProposal) GetDatasetIpfsHash() string {
	if m != nil {
		return m.DatasetIpfsHash
	}
	return ""
}

func (m *DatasetProposal) GetMetadata() DatasetMetadata {
	if m != nil {
		return m.Metadata
	}
	return DatasetMetadata{}
}

func (m *DatasetProposal) GetDeposit() string {
	if m != nil {
		return m.Deposit
	}
	return ""
}

func (m *DatasetProposal) GetVotingPeriodEnd() time.Time {
	if m != nil {
		return m.VotingPeriodEnd
	}
	return time.Time{}
}

func (m *DatasetProposal) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *DatasetProposal) GetSubmitTime() time.Time {
	if m != nil {
		return m.SubmitTime
	}
	return time.Time{}
}

func (m *DatasetProposal) GetTotalVotes() string {
	if m != nil {
		return m.TotalVotes
	}
	return ""
}

func (m *DatasetProposal) GetYesVotes() string {
	if m != nil {
		return m.YesVotes
	}
	return ""
}

func (m *DatasetProposal) GetNoVotes() string {
	if m != nil {
		return m.NoVotes
	}
	return ""
}

func (m *DatasetProposal) GetAbstainVotes() string {
	if m != nil {
		return m.AbstainVotes
	}
	return ""
}

// DatasetMetadata contains metadata about a dataset
type DatasetMetadata struct {
	// name is the name of the dataset
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// description is the description of the dataset
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// data_schema is the schema of the dataset
	DataSchema string `protobuf:"bytes,3,opt,name=data_schema,json=dataSchema,proto3" json:"data_schema,omitempty"`
	// size_bytes is the size of the dataset in bytes
	SizeBytes uint64 `protobuf:"varint,4,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// num_samples is the number of samples in the dataset
	NumSamples uint64 `protobuf:"varint,5,opt,name=num_samples,json=numSamples,proto3" json:"num_samples,omitempty"`
	// license is the license of the dataset
	License string `protobuf:"bytes,6,opt,name=license,proto3" json:"license,omitempty"`
	// source is the source of the dataset
	Source string `protobuf:"bytes,7,opt,name=source,proto3" json:"source,omitempty"`
	// checksum is the cryptographic checksum of the dataset
	Checksum string `protobuf:"bytes,8,opt,name=checksum,proto3" json:"checksum,omitempty"`
	// signature is the cryptographic signature of the proposer
	Signature []byte `protobuf:"bytes,9,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *DatasetMetadata) Reset()         { *m = DatasetMetadata{} }
func (m *DatasetMetadata) String() string { return proto.CompactTextString(m) }
func (*DatasetMetadata) ProtoMessage()    {}
func (*DatasetMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0a6ac87bf3a5fe4, []int{1}
}
func (m *DatasetMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatasetMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatasetMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatasetMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatasetMetadata.Merge(m, src)
}
func (m *DatasetMetadata) XXX_Size() int {
	return m.Size()
}
func (m *DatasetMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_DatasetMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_DatasetMetadata proto.InternalMessageInfo

func (m *DatasetMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DatasetMetadata) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DatasetMetadata) GetDataSchema() string {
	if m != nil {
		return m.DataSchema
	}
	return ""
}

func (m *DatasetMetadata) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *DatasetMetadata) GetNumSamples() uint64 {
	if m != nil {
		return m.NumSamples
	}
	return 0
}

func (m *DatasetMetadata) GetLicense() string {
	if m != nil {
		return m.License
	}
	return ""
}

func (m *DatasetMetadata) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *DatasetMetadata) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

func (m *DatasetMetadata) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// ApprovedDataset represents an approved dataset in the registry
type ApprovedDataset struct {
	// dataset_id is the unique identifier for the approved dataset
	DatasetId uint64 `protobuf:"varint,1,opt,name=dataset_id,json=datasetId,proto3" json:"dataset_id,omitempty"`
	// dataset_ipfs_hash is the IPFS hash of the dataset
	DatasetIpfsHash string `protobuf:"bytes,2,opt,name=dataset_ipfs_hash,json=datasetIpfsHash,proto3" json:"dataset_ipfs_hash,omitempty"`
	// metadata is the dataset metadata
	Metadata DatasetMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata"`
	// approval_height is the block height when approved
	ApprovalHeight int64 `protobuf:"varint,4,opt,name=approval_height,json=approvalHeight,proto3" json:"approval_height,omitempty"`
	// approval_tx_hash is the transaction hash of the approval
	ApprovalTxHash string `protobuf:"bytes,5,opt,name=approval_tx_hash,json=approvalTxHash,proto3" json:"approval_tx_hash,omitempty"`
	// proposer is the address of the original proposer
	Proposer string `protobuf:"bytes,6,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// status is the dataset status
	Status string `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	// is_official_training_data indicates if this dataset is marked as "Official Training Data"
	IsOfficialTrainingData bool `protobuf:"varint,10,opt,name=is_official_training_data,json=isOfficialTrainingData,proto3" json:"is_official_training_data,omitempty"`
	// removal_height is the block height when removed (if removed)
	RemovalHeight int64 `protobuf:"varint,8,opt,name=removal_height,json=removalHeight,proto3" json:"removal_height,omitempty"`
	// removal_tx_hash is the transaction hash of the removal (if removed)
	RemovalTxHash string `protobuf:"bytes,9,opt,name=removal_tx_hash,json=removalTxHash,proto3" json:"removal_tx_hash,omitempty"`
	// audit_trail contains cryptographic audit trail linking to approval transactions
	AuditTrail []*AuditTrailEntry `protobuf:"bytes,11,rep,name=audit_trail,json=auditTrail,proto3" json:"audit_trail,omitempty"`
}

func (m *ApprovedDataset) Reset()         { *m = ApprovedDataset{} }
func (m *ApprovedDataset) String() string { return proto.CompactTextString(m) }
func (*ApprovedDataset) ProtoMessage()    {}
func (*ApprovedDataset) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0a6ac87bf3a5fe4, []int{2}
}
func (m *ApprovedDataset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovedDataset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovedDataset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovedDataset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovedDataset.Merge(m, src)
}
func (m *ApprovedDataset) XXX_Size() int {
	return m.Size()
}
func (m *ApprovedDataset) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovedDataset.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovedDataset proto.InternalMessageInfo

func (m *ApprovedDataset) GetDatasetId() uint64 {
	if m != nil {
		return m.DatasetId
	}
	return 0
}

func (m *ApprovedDataset) GetDatasetIpfsHash() string {
	if m != nil {
		return m.DatasetIpfsHash
	}
	return ""
}

func (m *ApprovedDataset) GetMetadata() DatasetMetadata {
	if m != nil {
		return m.Metadata
	}
	return DatasetMetadata{}
}

func (m *ApprovedDataset) GetApprovalHeight() int64 {
	if m != nil {
		return m.ApprovalHeight
	}
	return 0
}

func (m *ApprovedDataset) GetApprovalTxHash() string {
	if m != nil {
		return m.ApprovalTxHash
	}
	return ""
}

func (m *ApprovedDataset) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *ApprovedDataset) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ApprovedDataset) GetIsOfficialTrainingData() bool {
	if m != nil {
		return m.IsOfficialTrainingData
	}
	return false
}

func (m *ApprovedDataset) GetRemovalHeight() int64 {
	if m != nil {
		return m.RemovalHeight
	}
	return 0
}

func (m *ApprovedDataset) GetRemovalTxHash() string {
	if m != nil {
		return m.RemovalTxHash
	}
	return ""
}

func (m *ApprovedDataset) GetAuditTrail() []*AuditTrailEntry {
	if m != nil {
		return m.AuditTrail
	}
	return nil
}

// AuditTrailEntry represents an entry in the cryptographic audit trail
type AuditTrailEntry struct {
	// entry_type is the type of entry ("approval", "removal", "update", "challenge")
	EntryType string `protobuf:"bytes,1,opt,name=entry_type,json=entryType,proto3" json:"entry_type,omitempty"`
	// block_height is the block height when this entry was created
	BlockHeight int64 `protobuf:"varint,2,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// tx_hash is the transaction hash
	TxHash string `protobuf:"bytes,3,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// actor is the address of the actor (proposer, voter, challenger, etc.)
	Actor string `protobuf:"bytes,4,opt,name=actor,proto3" json:"actor,omitempty"`
	// description is a human-readable description
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// timestamp is when this entry was created
	Timestamp time.Time `protobuf:"bytes,6,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
}

func (m *AuditTrailEntry) Reset()         { *m = AuditTrailEntry{} }
func (m *AuditTrailEntry) String() string { return proto.CompactTextString(m) }
func (*AuditTrailEntry) ProtoMessage()    {}
func (*AuditTrailEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0a6ac87bf3a5fe4, []int{3}
}
func (m *AuditTrailEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuditTrailEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuditTrailEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuditTrailEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuditTrailEntry.Merge(m, src)
}
func (m *AuditTrailEntry) XXX_Size() int {
	return m.Size()
}
func (m *AuditTrailEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AuditTrailEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AuditTrailEntry proto.InternalMessageInfo

func (m *AuditTrailEntry) GetEntryType() string {
	if m != nil {
		return m.EntryType
	}
	return ""
}

func (m *AuditTrailEntry) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *AuditTrailEntry) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *AuditTrailEntry) GetActor() string {
	if m != nil {
		return m.Actor
	}
	return ""
}

func (m *AuditTrailEntry) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AuditTrailEntry) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func init() {
	proto.RegisterType((*DatasetProposal)(nil), "remes.remes.v1.DatasetProposal")
	proto.RegisterType((*DatasetMetadata)(nil), "remes.remes.v1.DatasetMetadata")
	proto.RegisterType((*ApprovedDataset)(nil), "remes.remes.v1.ApprovedDataset")
	proto.RegisterType((*AuditTrailEntry)(nil), "remes.remes.v1.AuditTrailEntry")
}

func init() { proto.RegisterFile("remes/remes/v1/dataset.proto", fileDescriptor_e0a6ac87bf3a5fe4) }

var fileDescriptor_e0a6ac87bf3a5fe4 = []byte{
	// 818 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0x8f, 0x93, 0x34, 0x8d, 0x9f, 0xb3, 0x1b, 0x3a, 0xac, 0x16, 0x6f, 0x58, 0x92, 0x10, 0x04,
	0x44, 0x48, 0x24, 0x5a, 0x38, 0x71, 0xa3, 0x11, 0x95, 0x76, 0x0f, 0x88, 0xca, 0x1b, 0x71, 0xe0,
	0x62, 0x4d, 0xec, 0x49, 0x32, 0xaa, 0xed, 0xb1, 0x3c, 0xe3, 0xa8, 0xe1, 0x03, 0x70, 0xee, 0x81,
	0x0f, 0xd5, 0x63, 0x8f, 0x9c, 0x00, 0xb5, 0x17, 0xce, 0x7c, 0x02, 0x34, 0x6f, 0xc6, 0x6e, 0x29,
	0x45, 0xa8, 0x5c, 0xac, 0x79, 0xbf, 0xf7, 0x26, 0xef, 0xf7, 0xfe, 0xfc, 0x26, 0xf0, 0xb2, 0x60,
	0x29, 0x93, 0x73, 0xf3, 0xdd, 0xbd, 0x9a, 0xc7, 0x54, 0x51, 0xc9, 0xd4, 0x2c, 0x2f, 0x84, 0x12,
	0xe4, 0x29, 0xe2, 0x33, 0xf3, 0xdd, 0xbd, 0x1a, 0x1c, 0xd1, 0x94, 0x67, 0x62, 0x8e, 0x5f, 0x13,
	0x32, 0x78, 0xb6, 0x11, 0x1b, 0x81, 0xc7, 0xb9, 0x3e, 0x59, 0x74, 0xb4, 0x11, 0x62, 0x93, 0xb0,
	0x39, 0x5a, 0xab, 0x72, 0x3d, 0x57, 0x3c, 0x65, 0x52, 0xd1, 0x34, 0x37, 0x01, 0x93, 0x9f, 0xda,
	0xd0, 0xff, 0xc6, 0xe4, 0x3a, 0x2d, 0x44, 0x2e, 0x24, 0x4d, 0xc8, 0x08, 0xbc, 0xdc, 0x9e, 0x43,
	0x1e, 0xfb, 0xce, 0xd8, 0x99, 0xb6, 0x03, 0xa8, 0xa0, 0x37, 0x31, 0x19, 0x40, 0xd7, 0x58, 0xac,
	0xf0, 0x9b, 0x63, 0x67, 0xea, 0x06, 0xb5, 0x4d, 0x3e, 0x83, 0x23, 0xcb, 0x3d, 0xe4, 0xf9, 0x5a,
	0x86, 0x5b, 0x2a, 0xb7, 0x7e, 0x0b, 0x83, 0xfa, 0xd6, 0xf1, 0x26, 0x5f, 0xcb, 0xd7, 0x54, 0x6e,
	0xc9, 0x31, 0x74, 0x53, 0xa6, 0xa8, 0x86, 0xfd, 0xf6, 0xd8, 0x99, 0x7a, 0x5f, 0x8c, 0x66, 0x7f,
	0xaf, 0x74, 0x66, 0xb9, 0x7d, 0x6b, 0xc3, 0x16, 0xed, 0xcb, 0x5f, 0x47, 0x8d, 0xa0, 0xbe, 0x46,
	0x7c, 0x38, 0x8c, 0x59, 0x2e, 0x24, 0x57, 0xfe, 0x01, 0x26, 0xa9, 0x4c, 0x72, 0x0a, 0x47, 0x3b,
	0xa1, 0x78, 0xb6, 0x09, 0x73, 0x56, 0x70, 0x11, 0x87, 0x2c, 0x8b, 0xfd, 0x0e, 0x66, 0x19, 0xcc,
	0x4c, 0x5b, 0x66, 0x55, 0x5b, 0x66, 0xcb, 0xaa, 0x2d, 0x8b, 0xae, 0x4e, 0x70, 0xf1, 0xdb, 0xc8,
	0x09, 0xfa, 0xe6, 0xfa, 0x29, 0xde, 0x3e, 0xc9, 0x62, 0xf2, 0x1c, 0x3a, 0x52, 0x51, 0x55, 0x4a,
	0xff, 0x10, 0x53, 0x59, 0x8b, 0x9c, 0x80, 0x27, 0xcb, 0x55, 0xca, 0x55, 0xa8, 0xbb, 0xeb, 0x77,
	0x1f, 0x91, 0x03, 0xcc, 0x45, 0xed, 0xd2, 0x6d, 0x57, 0x42, 0xd1, 0x24, 0xdc, 0x09, 0xc5, 0xa4,
	0xef, 0x62, 0x0e, 0x40, 0xe8, 0x7b, 0x8d, 0x90, 0xf7, 0xc1, 0xdd, 0x33, 0x69, 0xdd, 0x60, 0xfa,
	0xbe, 0x67, 0xd2, 0x38, 0x5f, 0x40, 0x37, 0x13, 0xd6, 0xe7, 0x99, 0x4e, 0x64, 0xc2, 0xb8, 0x3e,
	0x82, 0x27, 0x74, 0x25, 0x15, 0xe5, 0x99, 0xf5, 0xf7, 0xd0, 0xdf, 0xb3, 0x20, 0x06, 0x4d, 0x7e,
	0x6e, 0xd6, 0x8b, 0x50, 0x35, 0x9b, 0x10, 0x68, 0x67, 0x34, 0x65, 0xb8, 0x01, 0x6e, 0x80, 0x67,
	0x32, 0x06, 0x2f, 0x66, 0x32, 0x2a, 0x78, 0xae, 0xb8, 0xc8, 0xec, 0xf8, 0xef, 0x42, 0xba, 0x0e,
	0x7d, 0x3b, 0x94, 0xd1, 0x96, 0xa5, 0xd4, 0xce, 0x1e, 0x34, 0xf4, 0x16, 0x11, 0xf2, 0x01, 0x80,
	0xe4, 0x3f, 0xb2, 0x70, 0xb5, 0xd7, 0x64, 0xda, 0xb8, 0x5e, 0xae, 0x46, 0x16, 0x1a, 0xd0, 0xf7,
	0xb3, 0x32, 0x0d, 0x25, 0x4d, 0xf3, 0x84, 0x49, 0x1c, 0x6b, 0x3b, 0x80, 0xac, 0x4c, 0xdf, 0x1a,
	0x44, 0xcf, 0x3c, 0xe1, 0x11, 0xcb, 0x24, 0xc3, 0x79, 0xba, 0x41, 0x65, 0xe2, 0x84, 0x44, 0x59,
	0x44, 0xac, 0x9e, 0x10, 0x5a, 0x7a, 0x61, 0xa3, 0x2d, 0x8b, 0xce, 0x64, 0x99, 0xe2, 0x78, 0xdc,
	0xa0, 0xb6, 0xc9, 0x4b, 0x70, 0x25, 0xdf, 0x64, 0x54, 0x95, 0x05, 0xc3, 0xa6, 0xf7, 0x82, 0x5b,
	0x60, 0xf2, 0x67, 0x0b, 0xfa, 0xc7, 0x79, 0x5e, 0x88, 0x1d, 0x8b, 0x6d, 0x7b, 0x34, 0xff, 0x7a,
	0xc5, 0x2b, 0x79, 0xb8, 0xd5, 0x6e, 0xc7, 0x0f, 0x2b, 0xa0, 0xf9, 0xdf, 0x0a, 0x68, 0xfd, 0x3f,
	0x05, 0x7c, 0x0a, 0x7d, 0x8a, 0x04, 0x69, 0x12, 0x6e, 0x19, 0xdf, 0x6c, 0x15, 0xb6, 0xb4, 0x15,
	0x3c, 0xad, 0xe0, 0xd7, 0x88, 0x92, 0x29, 0xbc, 0x53, 0x07, 0xaa, 0x73, 0x43, 0xcb, 0x68, 0xa6,
	0x8e, 0x5c, 0x9e, 0x23, 0xab, 0xbb, 0xfa, 0xee, 0xdc, 0xd3, 0xf7, 0xbf, 0x89, 0xe0, 0x2b, 0x78,
	0xc1, 0x65, 0x28, 0xd6, 0x6b, 0x1e, 0x71, 0x9d, 0xa0, 0xa0, 0x3c, 0xd3, 0xe2, 0xc3, 0xd2, 0xf4,
	0xb2, 0x76, 0x83, 0xe7, 0x5c, 0x7e, 0x67, 0xfd, 0x4b, 0xeb, 0xd6, 0xc5, 0x91, 0x8f, 0x41, 0xbf,
	0x6f, 0x77, 0x0b, 0xe8, 0x62, 0x01, 0x4f, 0x2c, 0x6a, 0xf9, 0x7f, 0x02, 0xfd, 0x2a, 0xac, 0xa2,
	0x6f, 0x34, 0x52, 0xc5, 0x59, 0xf6, 0x5f, 0x83, 0x47, 0xcb, 0x58, 0xab, 0xb1, 0xa0, 0x3c, 0xf1,
	0xbd, 0x71, 0xeb, 0xa1, 0xb6, 0x1e, 0xeb, 0x10, 0x4d, 0x23, 0x39, 0xc9, 0x54, 0xb1, 0x0f, 0x80,
	0xd6, 0xc0, 0xe4, 0x0f, 0x07, 0xfa, 0xf7, 0xfc, 0x7a, 0xe8, 0x4c, 0x1f, 0x42, 0xb5, 0xcf, 0x2b,
	0x45, 0xb8, 0x88, 0x2c, 0xf7, 0x39, 0x23, 0x1f, 0x42, 0x6f, 0x95, 0x88, 0xe8, 0xac, 0xaa, 0xa0,
	0x89, 0x15, 0x78, 0x88, 0x59, 0xfe, 0xef, 0xc1, 0x61, 0xc5, 0xdb, 0x68, 0xa2, 0xa3, 0x0c, 0xe1,
	0x67, 0x70, 0x40, 0x23, 0x25, 0x0a, 0x9c, 0x9b, 0x1b, 0x18, 0xe3, 0xbe, 0xd0, 0x0e, 0xfe, 0x29,
	0xb4, 0x05, 0xb8, 0xf5, 0x73, 0xfe, 0xa8, 0x97, 0xed, 0xf6, 0xda, 0xe2, 0xf3, 0xcb, 0xeb, 0xa1,
	0x73, 0x75, 0x3d, 0x74, 0x7e, 0xbf, 0x1e, 0x3a, 0x17, 0x37, 0xc3, 0xc6, 0xd5, 0xcd, 0xb0, 0xf1,
	0xcb, 0xcd, 0xb0, 0xf1, 0xc3, 0xbb, 0xe6, 0xbf, 0xe8, 0xdc, 0xfe, 0x27, 0xe9, 0xb2, 0xe5, 0xaa,
	0x83, 0xbf, 0xfb, 0xe5, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x5f, 0x37, 0xe1, 0x5a, 0xaf, 0x06,
	0x00, 0x00,
}

func (m *DatasetProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatasetProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatasetProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AbstainVotes) > 0 {
		i -= len(m.AbstainVotes)
		copy(dAtA[i:], m.AbstainVotes)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.AbstainVotes)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.NoVotes) > 0 {
		i -= len(m.NoVotes)
		copy(dAtA[i:], m.NoVotes)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.NoVotes)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.YesVotes) > 0 {
		i -= len(m.YesVotes)
		copy(dAtA[i:], m.YesVotes)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.YesVotes)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.TotalVotes) > 0 {
		i -= len(m.TotalVotes)
		copy(dAtA[i:], m.TotalVotes)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.TotalVotes)))
		i--
		dAtA[i] = 0x4a
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.SubmitTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.SubmitTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintDataset(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x42
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x3a
	}
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.VotingPeriodEnd, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.VotingPeriodEnd):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintDataset(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x32
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDataset(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.DatasetIpfsHash) > 0 {
		i -= len(m.DatasetIpfsHash)
		copy(dAtA[i:], m.DatasetIpfsHash)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.DatasetIpfsHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalId != 0 {
		i = encodeVarintDataset(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatasetMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatasetMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatasetMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Checksum) > 0 {
		i -= len(m.Checksum)
		copy(dAtA[i:], m.Checksum)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Checksum)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.License) > 0 {
		i -= len(m.License)
		copy(dAtA[i:], m.License)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.License)))
		i--
		dAtA[i] = 0x32
	}
	if m.NumSamples != 0 {
		i = encodeVarintDataset(dAtA, i, uint64(m.NumSamples))
		i--
		dAtA[i] = 0x28
	}
	if m.SizeBytes != 0 {
		i = encodeVarintDataset(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DataSchema) > 0 {
		i -= len(m.DataSchema)
		copy(dAtA[i:], m.DataSchema)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.DataSchema)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApprovedDataset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovedDataset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovedDataset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuditTrail) > 0 {
		for iNdEx := len(m.AuditTrail) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AuditTrail[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDataset(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.IsOfficialTrainingData {
		i--
		if m.IsOfficialTrainingData {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.RemovalTxHash) > 0 {
		i -= len(m.RemovalTxHash)
		copy(dAtA[i:], m.RemovalTxHash)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.RemovalTxHash)))
		i--
		dAtA[i] = 0x4a
	}
	if m.RemovalHeight != 0 {
		i = encodeVarintDataset(dAtA, i, uint64(m.RemovalHeight))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ApprovalTxHash) > 0 {
		i -= len(m.ApprovalTxHash)
		copy(dAtA[i:], m.ApprovalTxHash)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.ApprovalTxHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ApprovalHeight != 0 {
		i = encodeVarintDataset(dAtA, i, uint64(m.ApprovalHeight))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDataset(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.DatasetIpfsHash) > 0 {
		i -= len(m.DatasetIpfsHash)
		copy(dAtA[i:], m.DatasetIpfsHash)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.DatasetIpfsHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetId != 0 {
		i = encodeVarintDataset(dAtA, i, uint64(m.DatasetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuditTrailEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditTrailEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditTrailEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintDataset(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x32
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Actor) > 0 {
		i -= len(m.Actor)
		copy(dAtA[i:], m.Actor)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Actor)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockHeight != 0 {
		i = encodeVarintDataset(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.EntryType) > 0 {
		i -= len(m.EntryType)
		copy(dAtA[i:], m.EntryType)
		i = encodeVarintDataset(dAtA, i, uint64(len(m.EntryType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDataset(dAtA []byte, offset int, v uint64) int {
	offset -= sovDataset(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DatasetProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovDataset(uint64(m.ProposalId))
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = len(m.DatasetIpfsHash)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovDataset(uint64(l))
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.VotingPeriodEnd)
	n += 1 + l + sovDataset(uint64(l))
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.SubmitTime)
	n += 1 + l + sovDataset(uint64(l))
	l = len(m.TotalVotes)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = len(m.YesVotes)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = len(m.NoVotes)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = len(m.AbstainVotes)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	return n
}

func (m *DatasetMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = len(m.DataSchema)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovDataset(uint64(m.SizeBytes))
	}
	if m.NumSamples != 0 {
		n += 1 + sovDataset(uint64(m.NumSamples))
	}
	l = len(m.License)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = len(m.Checksum)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	return n
}

func (m *ApprovedDataset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetId != 0 {
		n += 1 + sovDataset(uint64(m.DatasetId))
	}
	l = len(m.DatasetIpfsHash)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovDataset(uint64(l))
	if m.ApprovalHeight != 0 {
		n += 1 + sovDataset(uint64(m.ApprovalHeight))
	}
	l = len(m.ApprovalTxHash)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	if m.RemovalHeight != 0 {
		n += 1 + sovDataset(uint64(m.RemovalHeight))
	}
	l = len(m.RemovalTxHash)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	if m.IsOfficialTrainingData {
		n += 2
	}
	if len(m.AuditTrail) > 0 {
		for _, e := range m.AuditTrail {
			l = e.Size()
			n += 1 + l + sovDataset(uint64(l))
		}
	}
	return n
}

func (m *AuditTrailEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EntryType)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovDataset(uint64(m.BlockHeight))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = len(m.Actor)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovDataset(uint64(l))
	return n
}

func sovDataset(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDataset(x uint64) (n int) {
	return sovDataset(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DatasetProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatasetProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatasetProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPeriodEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.VotingPeriodEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.SubmitTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVotes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalVotes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YesVotes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YesVotes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoVotes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoVotes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbstainVotes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbstainVotes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatasetMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatasetMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatasetMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSchema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataSchema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSamples", wireType)
			}
			m.NumSamples = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSamples |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field License", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.License = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovedDataset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovedDataset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovedDataset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetId", wireType)
			}
			m.DatasetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatasetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalHeight", wireType)
			}
			m.ApprovalHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApprovalHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovalHeight", wireType)
			}
			m.RemovalHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemovalHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovalTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemovalTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOfficialTrainingData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOfficialTrainingData = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditTrail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuditTrail = append(m.AuditTrail, &AuditTrailEntry{})
			if err := m.AuditTrail[len(m.AuditTrail)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditTrailEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditTrailEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditTrailEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDataset(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDataset
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDataset
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDataset
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDataset
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDataset        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDataset          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDataset = fmt.Errorf("proto: unexpected end of group")
)
