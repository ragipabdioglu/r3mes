// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: remes/remes/v1/model.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ModelType identifies the neural network architecture
type ModelType int32

const (
	ModelType_MODEL_TYPE_UNSPECIFIED ModelType = 0
	ModelType_MODEL_TYPE_BITNET      ModelType = 1
	ModelType_MODEL_TYPE_MAMBA       ModelType = 2
	ModelType_MODEL_TYPE_RWKV        ModelType = 3
	ModelType_MODEL_TYPE_CUSTOM      ModelType = 99
)

var ModelType_name = map[int32]string{
	0:  "MODEL_TYPE_UNSPECIFIED",
	1:  "MODEL_TYPE_BITNET",
	2:  "MODEL_TYPE_MAMBA",
	3:  "MODEL_TYPE_RWKV",
	99: "MODEL_TYPE_CUSTOM",
}

var ModelType_value = map[string]int32{
	"MODEL_TYPE_UNSPECIFIED": 0,
	"MODEL_TYPE_BITNET":      1,
	"MODEL_TYPE_MAMBA":       2,
	"MODEL_TYPE_RWKV":        3,
	"MODEL_TYPE_CUSTOM":      99,
}

func (x ModelType) String() string {
	return proto.EnumName(ModelType_name, int32(x))
}

func (ModelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a718e44e98504b7, []int{0}
}

// EncryptionType specifies encryption method for enterprise privacy
type EncryptionType int32

const (
	EncryptionType_ENCRYPTION_TYPE_UNSPECIFIED    EncryptionType = 0
	EncryptionType_ENCRYPTION_TYPE_PLAINTEXT      EncryptionType = 1
	EncryptionType_ENCRYPTION_TYPE_TEE_SGX        EncryptionType = 2
	EncryptionType_ENCRYPTION_TYPE_HOMOMORPHIC    EncryptionType = 3
	EncryptionType_ENCRYPTION_TYPE_ZERO_KNOWLEDGE EncryptionType = 4
)

var EncryptionType_name = map[int32]string{
	0: "ENCRYPTION_TYPE_UNSPECIFIED",
	1: "ENCRYPTION_TYPE_PLAINTEXT",
	2: "ENCRYPTION_TYPE_TEE_SGX",
	3: "ENCRYPTION_TYPE_HOMOMORPHIC",
	4: "ENCRYPTION_TYPE_ZERO_KNOWLEDGE",
}

var EncryptionType_value = map[string]int32{
	"ENCRYPTION_TYPE_UNSPECIFIED":    0,
	"ENCRYPTION_TYPE_PLAINTEXT":      1,
	"ENCRYPTION_TYPE_TEE_SGX":        2,
	"ENCRYPTION_TYPE_HOMOMORPHIC":    3,
	"ENCRYPTION_TYPE_ZERO_KNOWLEDGE": 4,
}

func (x EncryptionType) String() string {
	return proto.EnumName(EncryptionType_name, int32(x))
}

func (EncryptionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a718e44e98504b7, []int{1}
}

// ModelConfig represents a generic model configuration
// This replaces BitNet-specific hard-coding
type ModelConfig struct {
	// model_type identifies the model architecture
	ModelType ModelType `protobuf:"varint,1,opt,name=model_type,json=modelType,proto3,enum=remes.remes.v1.ModelType" json:"model_type,omitempty"`
	// model_version is the version string (e.g., "b1.58", "v2.0")
	ModelVersion string `protobuf:"bytes,2,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
	// architecture_config is a JSON blob containing architecture-specific parameters
	// For BitNet: {"hidden_size": 768, "num_layers": 12, "lora_rank": 8, ...}
	// For Mamba: {"d_model": 512, "d_state": 16, "d_conv": 4, ...}
	// For RWKV: {"n_embd": 4096, "n_layer": 32, "n_head": 32, ...}
	ArchitectureConfig string `protobuf:"bytes,3,opt,name=architecture_config,json=architectureConfig,proto3" json:"architecture_config,omitempty"`
	// container_hash is the Docker/OCI image hash for deterministic execution
	// Format: "sha256:abc123..." (Docker image digest)
	// This enables support for future architectures without protocol changes
	ContainerHash string `protobuf:"bytes,4,opt,name=container_hash,json=containerHash,proto3" json:"container_hash,omitempty"`
	// container_registry is the container registry URL (e.g., "docker.io", "ghcr.io")
	ContainerRegistry string `protobuf:"bytes,5,opt,name=container_registry,json=containerRegistry,proto3" json:"container_registry,omitempty"`
	// execution_environment_id references an approved execution environment
	ExecutionEnvironmentId uint64 `protobuf:"varint,6,opt,name=execution_environment_id,json=executionEnvironmentId,proto3" json:"execution_environment_id,omitempty"`
	// encryption_type specifies encryption method
	EncryptionType EncryptionType `protobuf:"varint,7,opt,name=encryption_type,json=encryptionType,proto3,enum=remes.remes.v1.EncryptionType" json:"encryption_type,omitempty"`
	// encrypted_weights_ipfs_hash is the IPFS hash of encrypted model weights
	// Only used if encryption_type != ENCRYPTION_TYPE_PLAINTEXT
	EncryptedWeightsIpfsHash string `protobuf:"bytes,8,opt,name=encrypted_weights_ipfs_hash,json=encryptedWeightsIpfsHash,proto3" json:"encrypted_weights_ipfs_hash,omitempty"`
	// decryption_key_holder is the address authorized to decrypt (if applicable)
	// For TEE-SGX: This is the enclave address
	DecryptionKeyHolder string `protobuf:"bytes,9,opt,name=decryption_key_holder,json=decryptionKeyHolder,proto3" json:"decryption_key_holder,omitempty"`
}

func (m *ModelConfig) Reset()         { *m = ModelConfig{} }
func (m *ModelConfig) String() string { return proto.CompactTextString(m) }
func (*ModelConfig) ProtoMessage()    {}
func (*ModelConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a718e44e98504b7, []int{0}
}
func (m *ModelConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelConfig.Merge(m, src)
}
func (m *ModelConfig) XXX_Size() int {
	return m.Size()
}
func (m *ModelConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ModelConfig proto.InternalMessageInfo

func (m *ModelConfig) GetModelType() ModelType {
	if m != nil {
		return m.ModelType
	}
	return ModelType_MODEL_TYPE_UNSPECIFIED
}

func (m *ModelConfig) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

func (m *ModelConfig) GetArchitectureConfig() string {
	if m != nil {
		return m.ArchitectureConfig
	}
	return ""
}

func (m *ModelConfig) GetContainerHash() string {
	if m != nil {
		return m.ContainerHash
	}
	return ""
}

func (m *ModelConfig) GetContainerRegistry() string {
	if m != nil {
		return m.ContainerRegistry
	}
	return ""
}

func (m *ModelConfig) GetExecutionEnvironmentId() uint64 {
	if m != nil {
		return m.ExecutionEnvironmentId
	}
	return 0
}

func (m *ModelConfig) GetEncryptionType() EncryptionType {
	if m != nil {
		return m.EncryptionType
	}
	return EncryptionType_ENCRYPTION_TYPE_UNSPECIFIED
}

func (m *ModelConfig) GetEncryptedWeightsIpfsHash() string {
	if m != nil {
		return m.EncryptedWeightsIpfsHash
	}
	return ""
}

func (m *ModelConfig) GetDecryptionKeyHolder() string {
	if m != nil {
		return m.DecryptionKeyHolder
	}
	return ""
}

// ModelRegistry stores approved model configurations
type ModelRegistry struct {
	// model_id is the unique identifier for this model
	ModelId uint64 `protobuf:"varint,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	// config is the model configuration
	Config ModelConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config"`
	// approved_at_height is when this model was approved
	ApprovedAtHeight int64 `protobuf:"varint,3,opt,name=approved_at_height,json=approvedAtHeight,proto3" json:"approved_at_height,omitempty"`
	// approved_by is the governance proposal ID that approved this model
	ApprovedBy uint64 `protobuf:"varint,4,opt,name=approved_by,json=approvedBy,proto3" json:"approved_by,omitempty"`
	// is_active indicates if this model is currently active for training
	IsActive bool `protobuf:"varint,5,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	// created_at is the timestamp when this model was registered
	CreatedAt time.Time `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
}

func (m *ModelRegistry) Reset()         { *m = ModelRegistry{} }
func (m *ModelRegistry) String() string { return proto.CompactTextString(m) }
func (*ModelRegistry) ProtoMessage()    {}
func (*ModelRegistry) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a718e44e98504b7, []int{1}
}
func (m *ModelRegistry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelRegistry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelRegistry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelRegistry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelRegistry.Merge(m, src)
}
func (m *ModelRegistry) XXX_Size() int {
	return m.Size()
}
func (m *ModelRegistry) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelRegistry.DiscardUnknown(m)
}

var xxx_messageInfo_ModelRegistry proto.InternalMessageInfo

func (m *ModelRegistry) GetModelId() uint64 {
	if m != nil {
		return m.ModelId
	}
	return 0
}

func (m *ModelRegistry) GetConfig() ModelConfig {
	if m != nil {
		return m.Config
	}
	return ModelConfig{}
}

func (m *ModelRegistry) GetApprovedAtHeight() int64 {
	if m != nil {
		return m.ApprovedAtHeight
	}
	return 0
}

func (m *ModelRegistry) GetApprovedBy() uint64 {
	if m != nil {
		return m.ApprovedBy
	}
	return 0
}

func (m *ModelRegistry) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *ModelRegistry) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func init() {
	proto.RegisterEnum("remes.remes.v1.ModelType", ModelType_name, ModelType_value)
	proto.RegisterEnum("remes.remes.v1.EncryptionType", EncryptionType_name, EncryptionType_value)
	proto.RegisterType((*ModelConfig)(nil), "remes.remes.v1.ModelConfig")
	proto.RegisterType((*ModelRegistry)(nil), "remes.remes.v1.ModelRegistry")
}

func init() { proto.RegisterFile("remes/remes/v1/model.proto", fileDescriptor_5a718e44e98504b7) }

var fileDescriptor_5a718e44e98504b7 = []byte{
	// 760 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x53, 0xcd, 0x6e, 0xda, 0x40,
	0x10, 0xc6, 0x40, 0x13, 0x58, 0x1a, 0xe2, 0x2c, 0x49, 0x6a, 0x40, 0x35, 0x11, 0x6d, 0xa5, 0x28,
	0x6a, 0x40, 0xa1, 0x97, 0x34, 0x52, 0x0f, 0x40, 0xdc, 0x60, 0x25, 0x60, 0xe4, 0x38, 0xbf, 0x17,
	0xcb, 0xb1, 0x17, 0x58, 0x35, 0xd8, 0x96, 0xbd, 0xa1, 0xf1, 0xad, 0xe7, 0x4a, 0x95, 0xf2, 0x08,
	0x7d, 0x84, 0xaa, 0xe7, 0x3e, 0x40, 0x8e, 0x39, 0xf6, 0xd4, 0x56, 0xc9, 0xa1, 0x7d, 0x8c, 0x8a,
	0xb5, 0x71, 0x00, 0x71, 0x59, 0xed, 0x7c, 0xdf, 0x37, 0x3b, 0xb3, 0xf3, 0x03, 0x72, 0x0e, 0xea,
	0x23, 0xb7, 0xec, 0x9f, 0x83, 0xad, 0x72, 0xdf, 0x32, 0xd0, 0x65, 0xc9, 0x76, 0x2c, 0x62, 0xc1,
	0x34, 0x45, 0x4b, 0xfe, 0x39, 0xd8, 0xca, 0x2d, 0x69, 0x7d, 0x6c, 0x5a, 0x65, 0x7a, 0xfa, 0x92,
	0xdc, 0x72, 0xd7, 0xea, 0x5a, 0xf4, 0x5a, 0x1e, 0xde, 0x02, 0xb4, 0xd0, 0xb5, 0xac, 0xee, 0x25,
	0x2a, 0x53, 0xeb, 0xe2, 0xaa, 0x53, 0x26, 0xb8, 0x8f, 0x5c, 0xa2, 0xf5, 0x6d, 0x5f, 0x50, 0xfc,
	0x12, 0x07, 0xa9, 0xe6, 0x30, 0x52, 0xdd, 0x32, 0x3b, 0xb8, 0x0b, 0xb7, 0x01, 0xa0, 0x81, 0x55,
	0xe2, 0xd9, 0x88, 0x63, 0xd6, 0x98, 0xf5, 0x74, 0x25, 0x5b, 0x9a, 0x0c, 0x5f, 0xa2, 0x0e, 0x8a,
	0x67, 0x23, 0x39, 0xd9, 0x1f, 0x5d, 0xe1, 0x0b, 0xb0, 0xe0, 0x7b, 0x0e, 0x90, 0xe3, 0x62, 0xcb,
	0xe4, 0xa2, 0x6b, 0xcc, 0x7a, 0x52, 0x7e, 0x4a, 0xc1, 0x63, 0x1f, 0x83, 0x65, 0x90, 0xd1, 0x1c,
	0xbd, 0x87, 0x09, 0xd2, 0xc9, 0x95, 0x83, 0x54, 0x9d, 0x46, 0xe5, 0x62, 0x54, 0x0a, 0xc7, 0xa9,
	0x20, 0x9f, 0x57, 0x20, 0xad, 0x5b, 0x26, 0xd1, 0xb0, 0x89, 0x1c, 0xb5, 0xa7, 0xb9, 0x3d, 0x2e,
	0x4e, 0xb5, 0x0b, 0x21, 0xda, 0xd0, 0xdc, 0x1e, 0xdc, 0x04, 0xf0, 0x51, 0xe6, 0xa0, 0x2e, 0x76,
	0x89, 0xe3, 0x71, 0x4f, 0xa8, 0x74, 0x29, 0x64, 0xe4, 0x80, 0x80, 0xdb, 0x80, 0x43, 0xd7, 0x48,
	0xbf, 0x22, 0xd8, 0x32, 0x55, 0x64, 0x0e, 0xb0, 0x63, 0x99, 0x7d, 0x64, 0x12, 0x15, 0x1b, 0xdc,
	0xdc, 0x1a, 0xb3, 0x1e, 0x97, 0x57, 0x43, 0x5e, 0x78, 0xa4, 0x45, 0x03, 0xee, 0x81, 0x45, 0x64,
	0xea, 0x8e, 0x67, 0x53, 0x57, 0x5a, 0xa4, 0x79, 0x5a, 0x24, 0x7e, 0xba, 0x48, 0x42, 0x28, 0xa3,
	0x95, 0x4a, 0xa3, 0x09, 0x1b, 0xbe, 0x03, 0xf9, 0x00, 0x41, 0x86, 0xfa, 0x11, 0xe1, 0x6e, 0x8f,
	0xb8, 0x2a, 0xb6, 0x3b, 0xae, 0xff, 0xcb, 0x04, 0x4d, 0x9d, 0x0b, 0x25, 0x27, 0xbe, 0x42, 0xb4,
	0x3b, 0x2e, 0xfd, 0x70, 0x05, 0xac, 0x18, 0x28, 0xcc, 0xe3, 0x03, 0xf2, 0xd4, 0x9e, 0x75, 0x69,
	0x20, 0x87, 0x4b, 0x52, 0xc7, 0xcc, 0x23, 0xb9, 0x8f, 0xbc, 0x06, 0xa5, 0x76, 0x8a, 0xff, 0xbe,
	0x16, 0x98, 0xcf, 0x7f, 0xbf, 0x6d, 0x64, 0xfd, 0x21, 0xbb, 0x0e, 0x86, 0x6d, 0xac, 0xff, 0xc5,
	0x1f, 0x51, 0xb0, 0x40, 0xed, 0xb0, 0x56, 0x59, 0x90, 0xf0, 0xfb, 0x8a, 0x0d, 0x3a, 0x0f, 0x71,
	0x79, 0x9e, 0xda, 0xa2, 0x01, 0xdf, 0x82, 0xb9, 0xa0, 0x81, 0xc3, 0x5e, 0xa7, 0x2a, 0xf9, 0x99,
	0x83, 0xe2, 0xbf, 0x5c, 0x8b, 0xdf, 0xfe, 0x2a, 0x44, 0xe4, 0xc0, 0x01, 0xbe, 0x06, 0x50, 0xb3,
	0x6d, 0xc7, 0x1a, 0x20, 0x43, 0xd5, 0x88, 0xda, 0xa3, 0xdf, 0xa3, 0x73, 0x10, 0x93, 0xd9, 0x11,
	0x53, 0x25, 0x0d, 0x8a, 0xc3, 0x02, 0x48, 0x85, 0xea, 0x0b, 0x8f, 0x8e, 0x40, 0x5c, 0x06, 0x23,
	0xa8, 0xe6, 0xc1, 0x3c, 0x48, 0x62, 0x57, 0xd5, 0x74, 0x82, 0x07, 0x88, 0xb6, 0x3d, 0x21, 0x27,
	0xb0, 0x5b, 0xa5, 0x36, 0xac, 0x03, 0xa0, 0x3b, 0x48, 0x23, 0x34, 0x14, 0xed, 0x6f, 0xaa, 0x92,
	0x2b, 0xf9, 0x9b, 0x51, 0x1a, 0x6d, 0x46, 0x49, 0x19, 0x6d, 0x46, 0x2d, 0x31, 0xcc, 0xf4, 0xe6,
	0x77, 0x81, 0x91, 0x93, 0x81, 0x5f, 0x95, 0xec, 0xbc, 0x1c, 0x15, 0x2f, 0x3f, 0xa3, 0x78, 0xa3,
	0x62, 0x6d, 0x7c, 0x62, 0x40, 0x32, 0xdc, 0x0e, 0x98, 0x03, 0xab, 0x4d, 0x69, 0x57, 0x38, 0x50,
	0x95, 0xb3, 0xb6, 0xa0, 0x1e, 0xb5, 0x0e, 0xdb, 0x42, 0x5d, 0x7c, 0x2f, 0x0a, 0xbb, 0x6c, 0x04,
	0xae, 0x80, 0xa5, 0x31, 0xae, 0x26, 0x2a, 0x2d, 0x41, 0x61, 0x19, 0xb8, 0x0c, 0xd8, 0x31, 0xb8,
	0x59, 0x6d, 0xd6, 0xaa, 0x6c, 0x14, 0x66, 0xc0, 0xe2, 0x18, 0x2a, 0x9f, 0xec, 0x1f, 0xb3, 0xb1,
	0xa9, 0x17, 0xea, 0x47, 0x87, 0x8a, 0xd4, 0x64, 0xf5, 0x8d, 0xef, 0x0c, 0x48, 0x4f, 0xce, 0x1e,
	0x2c, 0x80, 0xbc, 0xd0, 0xaa, 0xcb, 0x67, 0x6d, 0x45, 0x94, 0x5a, 0xb3, 0x92, 0x79, 0x0e, 0xb2,
	0xd3, 0x82, 0xf6, 0x41, 0x55, 0x6c, 0x29, 0xc2, 0xe9, 0x30, 0xa9, 0x3c, 0x78, 0x36, 0x4d, 0x2b,
	0x82, 0xa0, 0x1e, 0xee, 0x9d, 0xb2, 0xd1, 0x59, 0x8f, 0x37, 0xa4, 0xa6, 0xd4, 0x94, 0xe4, 0x76,
	0x43, 0xac, 0xb3, 0x31, 0x58, 0x04, 0xfc, 0xb4, 0xe0, 0x5c, 0x90, 0x25, 0x75, 0xbf, 0x25, 0x9d,
	0x1c, 0x08, 0xbb, 0x7b, 0x02, 0x1b, 0xaf, 0x6d, 0xde, 0xde, 0xf3, 0xcc, 0xdd, 0x3d, 0xcf, 0xfc,
	0xb9, 0xe7, 0x99, 0x9b, 0x07, 0x3e, 0x72, 0xf7, 0xc0, 0x47, 0x7e, 0x3e, 0xf0, 0x91, 0xf3, 0xcc,
	0x64, 0xb9, 0x87, 0x1b, 0xe7, 0x5e, 0xcc, 0xd1, 0xae, 0xbd, 0xf9, 0x1f, 0x00, 0x00, 0xff, 0xff,
	0x69, 0x12, 0xcd, 0x6d, 0x34, 0x05, 0x00, 0x00,
}

func (this *ModelConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelConfig)
	if !ok {
		that2, ok := that.(ModelConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ModelType != that1.ModelType {
		return false
	}
	if this.ModelVersion != that1.ModelVersion {
		return false
	}
	if this.ArchitectureConfig != that1.ArchitectureConfig {
		return false
	}
	if this.ContainerHash != that1.ContainerHash {
		return false
	}
	if this.ContainerRegistry != that1.ContainerRegistry {
		return false
	}
	if this.ExecutionEnvironmentId != that1.ExecutionEnvironmentId {
		return false
	}
	if this.EncryptionType != that1.EncryptionType {
		return false
	}
	if this.EncryptedWeightsIpfsHash != that1.EncryptedWeightsIpfsHash {
		return false
	}
	if this.DecryptionKeyHolder != that1.DecryptionKeyHolder {
		return false
	}
	return true
}
func (this *ModelRegistry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelRegistry)
	if !ok {
		that2, ok := that.(ModelRegistry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ModelId != that1.ModelId {
		return false
	}
	if !this.Config.Equal(&that1.Config) {
		return false
	}
	if this.ApprovedAtHeight != that1.ApprovedAtHeight {
		return false
	}
	if this.ApprovedBy != that1.ApprovedBy {
		return false
	}
	if this.IsActive != that1.IsActive {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	return true
}
func (m *ModelConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DecryptionKeyHolder) > 0 {
		i -= len(m.DecryptionKeyHolder)
		copy(dAtA[i:], m.DecryptionKeyHolder)
		i = encodeVarintModel(dAtA, i, uint64(len(m.DecryptionKeyHolder)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.EncryptedWeightsIpfsHash) > 0 {
		i -= len(m.EncryptedWeightsIpfsHash)
		copy(dAtA[i:], m.EncryptedWeightsIpfsHash)
		i = encodeVarintModel(dAtA, i, uint64(len(m.EncryptedWeightsIpfsHash)))
		i--
		dAtA[i] = 0x42
	}
	if m.EncryptionType != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.EncryptionType))
		i--
		dAtA[i] = 0x38
	}
	if m.ExecutionEnvironmentId != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ExecutionEnvironmentId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ContainerRegistry) > 0 {
		i -= len(m.ContainerRegistry)
		copy(dAtA[i:], m.ContainerRegistry)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ContainerRegistry)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ContainerHash) > 0 {
		i -= len(m.ContainerHash)
		copy(dAtA[i:], m.ContainerHash)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ContainerHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ArchitectureConfig) > 0 {
		i -= len(m.ArchitectureConfig)
		copy(dAtA[i:], m.ArchitectureConfig)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ArchitectureConfig)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x12
	}
	if m.ModelType != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ModelType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModelRegistry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelRegistry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelRegistry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintModel(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x32
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ApprovedBy != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ApprovedBy))
		i--
		dAtA[i] = 0x20
	}
	if m.ApprovedAtHeight != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ApprovedAtHeight))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintModel(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ModelId != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ModelId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintModel(dAtA []byte, offset int, v uint64) int {
	offset -= sovModel(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ModelConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ModelType != 0 {
		n += 1 + sovModel(uint64(m.ModelType))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ArchitectureConfig)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ContainerHash)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ContainerRegistry)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.ExecutionEnvironmentId != 0 {
		n += 1 + sovModel(uint64(m.ExecutionEnvironmentId))
	}
	if m.EncryptionType != 0 {
		n += 1 + sovModel(uint64(m.EncryptionType))
	}
	l = len(m.EncryptedWeightsIpfsHash)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.DecryptionKeyHolder)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *ModelRegistry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ModelId != 0 {
		n += 1 + sovModel(uint64(m.ModelId))
	}
	l = m.Config.Size()
	n += 1 + l + sovModel(uint64(l))
	if m.ApprovedAtHeight != 0 {
		n += 1 + sovModel(uint64(m.ApprovedAtHeight))
	}
	if m.ApprovedBy != 0 {
		n += 1 + sovModel(uint64(m.ApprovedBy))
	}
	if m.IsActive {
		n += 2
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovModel(uint64(l))
	return n
}

func sovModel(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModel(x uint64) (n int) {
	return sovModel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ModelConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelType", wireType)
			}
			m.ModelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelType |= ModelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchitectureConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArchitectureConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRegistry", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerRegistry = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionEnvironmentId", wireType)
			}
			m.ExecutionEnvironmentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutionEnvironmentId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionType", wireType)
			}
			m.EncryptionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncryptionType |= EncryptionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedWeightsIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedWeightsIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecryptionKeyHolder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecryptionKeyHolder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelRegistry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelRegistry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelRegistry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelId", wireType)
			}
			m.ModelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovedAtHeight", wireType)
			}
			m.ApprovedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApprovedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovedBy", wireType)
			}
			m.ApprovedBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApprovedBy |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModel
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModel
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModel
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModel        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModel          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModel = fmt.Errorf("proto: unexpected end of group")
)
