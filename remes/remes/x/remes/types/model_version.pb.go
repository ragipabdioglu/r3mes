// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: remes/remes/v1/model_version.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ModelVersion represents a specific version of a model
type ModelVersion struct {
	// version_number is the numeric version (e.g., 1, 2, 3)
	VersionNumber uint64 `protobuf:"varint,1,opt,name=version_number,json=versionNumber,proto3" json:"version_number,omitempty"`
	// model_id references the ModelRegistry entry
	ModelId uint64 `protobuf:"varint,2,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	// model_hash is the IPFS hash of the model weights
	ModelHash string `protobuf:"bytes,3,opt,name=model_hash,json=modelHash,proto3" json:"model_hash,omitempty"`
	// ipfs_path is the versioned IPFS path (e.g., "v1/", "v2/")
	IpfsPath string `protobuf:"bytes,4,opt,name=ipfs_path,json=ipfsPath,proto3" json:"ipfs_path,omitempty"`
	// architecture is the model architecture string
	Architecture string `protobuf:"bytes,5,opt,name=architecture,proto3" json:"architecture,omitempty"`
	// compatibility_info is JSON-encoded compatibility information
	// e.g., {"compatible_with": [1, 2], "breaking_changes": false}
	CompatibilityInfo string `protobuf:"bytes,6,opt,name=compatibility_info,json=compatibilityInfo,proto3" json:"compatibility_info,omitempty"`
	// status is the current status: "active", "migration", "deprecated", "rollback"
	Status string `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	// activation_height is when this version was activated
	ActivationHeight int64 `protobuf:"varint,8,opt,name=activation_height,json=activationHeight,proto3" json:"activation_height,omitempty"`
	// migration_window_start is when migration window started
	MigrationWindowStart int64 `protobuf:"varint,9,opt,name=migration_window_start,json=migrationWindowStart,proto3" json:"migration_window_start,omitempty"`
	// migration_window_end is when migration window ends
	MigrationWindowEnd int64 `protobuf:"varint,10,opt,name=migration_window_end,json=migrationWindowEnd,proto3" json:"migration_window_end,omitempty"`
	// governance_proposal_id is the proposal that approved this version
	GovernanceProposalId uint64 `protobuf:"varint,11,opt,name=governance_proposal_id,json=governanceProposalId,proto3" json:"governance_proposal_id,omitempty"`
	// created_at is when this version was created
	CreatedAt time.Time `protobuf:"bytes,12,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
}

func (m *ModelVersion) Reset()         { *m = ModelVersion{} }
func (m *ModelVersion) String() string { return proto.CompactTextString(m) }
func (*ModelVersion) ProtoMessage()    {}
func (*ModelVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7d98482dd46a863, []int{0}
}
func (m *ModelVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelVersion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelVersion.Merge(m, src)
}
func (m *ModelVersion) XXX_Size() int {
	return m.Size()
}
func (m *ModelVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelVersion.DiscardUnknown(m)
}

var xxx_messageInfo_ModelVersion proto.InternalMessageInfo

func (m *ModelVersion) GetVersionNumber() uint64 {
	if m != nil {
		return m.VersionNumber
	}
	return 0
}

func (m *ModelVersion) GetModelId() uint64 {
	if m != nil {
		return m.ModelId
	}
	return 0
}

func (m *ModelVersion) GetModelHash() string {
	if m != nil {
		return m.ModelHash
	}
	return ""
}

func (m *ModelVersion) GetIpfsPath() string {
	if m != nil {
		return m.IpfsPath
	}
	return ""
}

func (m *ModelVersion) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

func (m *ModelVersion) GetCompatibilityInfo() string {
	if m != nil {
		return m.CompatibilityInfo
	}
	return ""
}

func (m *ModelVersion) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ModelVersion) GetActivationHeight() int64 {
	if m != nil {
		return m.ActivationHeight
	}
	return 0
}

func (m *ModelVersion) GetMigrationWindowStart() int64 {
	if m != nil {
		return m.MigrationWindowStart
	}
	return 0
}

func (m *ModelVersion) GetMigrationWindowEnd() int64 {
	if m != nil {
		return m.MigrationWindowEnd
	}
	return 0
}

func (m *ModelVersion) GetGovernanceProposalId() uint64 {
	if m != nil {
		return m.GovernanceProposalId
	}
	return 0
}

func (m *ModelVersion) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

// ModelUpgradeProposal represents a governance proposal for model upgrade
type ModelUpgradeProposal struct {
	// proposal_id is the unique proposal identifier
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// proposer is the address that created this proposal
	Proposer string `protobuf:"bytes,2,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// new_model_version is the proposed version number
	NewModelVersion uint64 `protobuf:"varint,3,opt,name=new_model_version,json=newModelVersion,proto3" json:"new_model_version,omitempty"`
	// new_model_hash is the IPFS hash of the new model
	NewModelHash string `protobuf:"bytes,4,opt,name=new_model_hash,json=newModelHash,proto3" json:"new_model_hash,omitempty"`
	// new_model_id is the ModelRegistry ID for the new model
	NewModelId uint64 `protobuf:"varint,5,opt,name=new_model_id,json=newModelId,proto3" json:"new_model_id,omitempty"`
	// ipfs_path is the versioned IPFS path (e.g., "v2/")
	IpfsPath string `protobuf:"bytes,6,opt,name=ipfs_path,json=ipfsPath,proto3" json:"ipfs_path,omitempty"`
	// architecture is the model architecture string
	Architecture string `protobuf:"bytes,7,opt,name=architecture,proto3" json:"architecture,omitempty"`
	// compatibility_info is JSON-encoded compatibility information
	CompatibilityInfo string `protobuf:"bytes,8,opt,name=compatibility_info,json=compatibilityInfo,proto3" json:"compatibility_info,omitempty"`
	// migration_window is the transition period in blocks (e.g., 1000)
	MigrationWindow int64 `protobuf:"varint,9,opt,name=migration_window,json=migrationWindow,proto3" json:"migration_window,omitempty"`
	// status is the proposal status: "voting", "approved", "rejected", "executed"
	Status string `protobuf:"bytes,10,opt,name=status,proto3" json:"status,omitempty"`
	// voting_period contains voting period information
	VotingPeriod VotingPeriod `protobuf:"bytes,11,opt,name=voting_period,json=votingPeriod,proto3" json:"voting_period"`
	// deposit is the proposal deposit amount
	Deposit string `protobuf:"bytes,12,opt,name=deposit,proto3" json:"deposit,omitempty"`
	// created_at is when this proposal was created
	CreatedAt time.Time `protobuf:"bytes,13,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
}

func (m *ModelUpgradeProposal) Reset()         { *m = ModelUpgradeProposal{} }
func (m *ModelUpgradeProposal) String() string { return proto.CompactTextString(m) }
func (*ModelUpgradeProposal) ProtoMessage()    {}
func (*ModelUpgradeProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7d98482dd46a863, []int{1}
}
func (m *ModelUpgradeProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelUpgradeProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelUpgradeProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelUpgradeProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelUpgradeProposal.Merge(m, src)
}
func (m *ModelUpgradeProposal) XXX_Size() int {
	return m.Size()
}
func (m *ModelUpgradeProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelUpgradeProposal.DiscardUnknown(m)
}

var xxx_messageInfo_ModelUpgradeProposal proto.InternalMessageInfo

func (m *ModelUpgradeProposal) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *ModelUpgradeProposal) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *ModelUpgradeProposal) GetNewModelVersion() uint64 {
	if m != nil {
		return m.NewModelVersion
	}
	return 0
}

func (m *ModelUpgradeProposal) GetNewModelHash() string {
	if m != nil {
		return m.NewModelHash
	}
	return ""
}

func (m *ModelUpgradeProposal) GetNewModelId() uint64 {
	if m != nil {
		return m.NewModelId
	}
	return 0
}

func (m *ModelUpgradeProposal) GetIpfsPath() string {
	if m != nil {
		return m.IpfsPath
	}
	return ""
}

func (m *ModelUpgradeProposal) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

func (m *ModelUpgradeProposal) GetCompatibilityInfo() string {
	if m != nil {
		return m.CompatibilityInfo
	}
	return ""
}

func (m *ModelUpgradeProposal) GetMigrationWindow() int64 {
	if m != nil {
		return m.MigrationWindow
	}
	return 0
}

func (m *ModelUpgradeProposal) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ModelUpgradeProposal) GetVotingPeriod() VotingPeriod {
	if m != nil {
		return m.VotingPeriod
	}
	return VotingPeriod{}
}

func (m *ModelUpgradeProposal) GetDeposit() string {
	if m != nil {
		return m.Deposit
	}
	return ""
}

func (m *ModelUpgradeProposal) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

// VotingPeriod represents the voting period for a proposal
type VotingPeriod struct {
	// start_height is when voting started
	StartHeight int64 `protobuf:"varint,1,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// end_height is when voting ends
	EndHeight int64 `protobuf:"varint,2,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
}

func (m *VotingPeriod) Reset()         { *m = VotingPeriod{} }
func (m *VotingPeriod) String() string { return proto.CompactTextString(m) }
func (*VotingPeriod) ProtoMessage()    {}
func (*VotingPeriod) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7d98482dd46a863, []int{2}
}
func (m *VotingPeriod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VotingPeriod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VotingPeriod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VotingPeriod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VotingPeriod.Merge(m, src)
}
func (m *VotingPeriod) XXX_Size() int {
	return m.Size()
}
func (m *VotingPeriod) XXX_DiscardUnknown() {
	xxx_messageInfo_VotingPeriod.DiscardUnknown(m)
}

var xxx_messageInfo_VotingPeriod proto.InternalMessageInfo

func (m *VotingPeriod) GetStartHeight() int64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *VotingPeriod) GetEndHeight() int64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

// ActiveModelVersions tracks which model versions are currently active
type ActiveModelVersions struct {
	// version_numbers is the list of active version numbers
	VersionNumbers []uint64 `protobuf:"varint,1,rep,packed,name=version_numbers,json=versionNumbers,proto3" json:"version_numbers,omitempty"`
	// migration_window_active indicates if a migration window is currently active
	MigrationWindowActive bool `protobuf:"varint,2,opt,name=migration_window_active,json=migrationWindowActive,proto3" json:"migration_window_active,omitempty"`
	// primary_version is the primary active version (for non-migration periods)
	PrimaryVersion uint64 `protobuf:"varint,3,opt,name=primary_version,json=primaryVersion,proto3" json:"primary_version,omitempty"`
}

func (m *ActiveModelVersions) Reset()         { *m = ActiveModelVersions{} }
func (m *ActiveModelVersions) String() string { return proto.CompactTextString(m) }
func (*ActiveModelVersions) ProtoMessage()    {}
func (*ActiveModelVersions) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7d98482dd46a863, []int{3}
}
func (m *ActiveModelVersions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveModelVersions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActiveModelVersions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActiveModelVersions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveModelVersions.Merge(m, src)
}
func (m *ActiveModelVersions) XXX_Size() int {
	return m.Size()
}
func (m *ActiveModelVersions) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveModelVersions.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveModelVersions proto.InternalMessageInfo

func (m *ActiveModelVersions) GetVersionNumbers() []uint64 {
	if m != nil {
		return m.VersionNumbers
	}
	return nil
}

func (m *ActiveModelVersions) GetMigrationWindowActive() bool {
	if m != nil {
		return m.MigrationWindowActive
	}
	return false
}

func (m *ActiveModelVersions) GetPrimaryVersion() uint64 {
	if m != nil {
		return m.PrimaryVersion
	}
	return 0
}

func init() {
	proto.RegisterType((*ModelVersion)(nil), "remes.remes.v1.ModelVersion")
	proto.RegisterType((*ModelUpgradeProposal)(nil), "remes.remes.v1.ModelUpgradeProposal")
	proto.RegisterType((*VotingPeriod)(nil), "remes.remes.v1.VotingPeriod")
	proto.RegisterType((*ActiveModelVersions)(nil), "remes.remes.v1.ActiveModelVersions")
}

func init() {
	proto.RegisterFile("remes/remes/v1/model_version.proto", fileDescriptor_d7d98482dd46a863)
}

var fileDescriptor_d7d98482dd46a863 = []byte{
	// 776 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0x41, 0x6f, 0xe3, 0x44,
	0x14, 0xc7, 0xe3, 0xad, 0x49, 0xe2, 0x17, 0x37, 0xdd, 0xcc, 0x86, 0xc5, 0x04, 0x36, 0xc9, 0x06,
	0x10, 0xa1, 0xab, 0x4d, 0xd8, 0x05, 0x71, 0xd8, 0x5b, 0x8b, 0x10, 0xcd, 0x01, 0x54, 0x19, 0x28,
	0x12, 0x17, 0x6b, 0x12, 0x4f, 0xec, 0x91, 0x6a, 0x8f, 0x35, 0x9e, 0x24, 0xf4, 0x2b, 0x70, 0xea,
	0x47, 0xe0, 0x03, 0x70, 0xe0, 0x63, 0x54, 0xe2, 0x40, 0x8f, 0x9c, 0x00, 0xb5, 0x07, 0xf8, 0x18,
	0xc8, 0x6f, 0xec, 0x26, 0x4e, 0x5b, 0x81, 0xb8, 0x58, 0x7e, 0xef, 0xff, 0x7f, 0x7a, 0xcf, 0x7e,
	0xbf, 0x19, 0x18, 0x48, 0x16, 0xb1, 0x74, 0xac, 0x9f, 0xcb, 0x17, 0xe3, 0x48, 0xf8, 0xec, 0xd4,
	0x5b, 0x32, 0x99, 0x72, 0x11, 0x8f, 0x12, 0x29, 0x94, 0x20, 0x4d, 0x54, 0x47, 0xfa, 0xb9, 0x7c,
	0xd1, 0x69, 0xd1, 0x88, 0xc7, 0x62, 0x8c, 0x4f, 0x6d, 0xe9, 0xb4, 0x03, 0x11, 0x08, 0x7c, 0x1d,
	0x67, 0x6f, 0x79, 0xb6, 0x17, 0x08, 0x11, 0x9c, 0xb2, 0x31, 0x46, 0xd3, 0xc5, 0x7c, 0xac, 0x78,
	0xc4, 0x52, 0x45, 0xa3, 0x44, 0x1b, 0x06, 0x3f, 0x99, 0x60, 0x7f, 0x91, 0x75, 0x3c, 0xd1, 0x0d,
	0xc9, 0x7b, 0xd0, 0xcc, 0x7b, 0x7b, 0xf1, 0x22, 0x9a, 0x32, 0xe9, 0x18, 0x7d, 0x63, 0x68, 0xba,
	0xbb, 0x79, 0xf6, 0x4b, 0x4c, 0x92, 0x37, 0xa1, 0xae, 0x07, 0xe5, 0xbe, 0xf3, 0x00, 0x0d, 0x35,
	0x8c, 0x27, 0x3e, 0x79, 0x02, 0xa0, 0xa5, 0x90, 0xa6, 0xa1, 0xb3, 0xd3, 0x37, 0x86, 0x96, 0x6b,
	0x61, 0xe6, 0x88, 0xa6, 0x21, 0x79, 0x0b, 0x2c, 0x9e, 0xcc, 0x53, 0x2f, 0xa1, 0x2a, 0x74, 0x4c,
	0x54, 0xeb, 0x59, 0xe2, 0x98, 0xaa, 0x90, 0x0c, 0xc0, 0xa6, 0x72, 0x16, 0x72, 0xc5, 0x66, 0x6a,
	0x21, 0x99, 0xf3, 0x1a, 0xea, 0xa5, 0x1c, 0x79, 0x0e, 0x64, 0x26, 0xa2, 0x84, 0x2a, 0x3e, 0xe5,
	0xa7, 0x5c, 0x9d, 0x79, 0x3c, 0x9e, 0x0b, 0xa7, 0x8a, 0xce, 0x56, 0x49, 0x99, 0xc4, 0x73, 0x41,
	0x1e, 0x43, 0x35, 0x55, 0x54, 0x2d, 0x52, 0xa7, 0x86, 0x96, 0x3c, 0x22, 0xcf, 0xa0, 0x45, 0x67,
	0x8a, 0x2f, 0xa9, 0xca, 0xbe, 0x35, 0x64, 0x3c, 0x08, 0x95, 0x53, 0xef, 0x1b, 0xc3, 0x1d, 0xf7,
	0xe1, 0x5a, 0x38, 0xc2, 0x3c, 0xf9, 0x18, 0x1e, 0x47, 0x3c, 0x90, 0xda, 0xbb, 0xe2, 0xb1, 0x2f,
	0x56, 0x5e, 0xaa, 0xa8, 0x54, 0x8e, 0x85, 0x15, 0xed, 0x1b, 0xf5, 0x5b, 0x14, 0xbf, 0xca, 0x34,
	0xf2, 0x21, 0xb4, 0x6f, 0x55, 0xb1, 0xd8, 0x77, 0x00, 0x6b, 0xc8, 0x56, 0xcd, 0x67, 0xb1, 0x9f,
	0xf5, 0x09, 0xc4, 0x92, 0xc9, 0x98, 0xc6, 0x33, 0xe6, 0x25, 0x52, 0x24, 0x22, 0xa5, 0xf8, 0x93,
	0x1b, 0xf8, 0x93, 0xdb, 0x6b, 0xf5, 0x38, 0x17, 0x27, 0x3e, 0xf9, 0x14, 0x60, 0x26, 0x19, 0x55,
	0xcc, 0xf7, 0xa8, 0x72, 0xec, 0xbe, 0x31, 0x6c, 0xbc, 0xec, 0x8c, 0xf4, 0xea, 0x47, 0xc5, 0xea,
	0x47, 0x5f, 0x17, 0xab, 0x3f, 0xac, 0x5f, 0xfc, 0xde, 0xab, 0x9c, 0xff, 0xd1, 0x33, 0x5c, 0x2b,
	0xaf, 0x3b, 0x50, 0xaf, 0xde, 0xf9, 0xfb, 0xc7, 0x9e, 0xf1, 0xc3, 0x5f, 0x3f, 0xef, 0x77, 0x34,
	0x8a, 0xdf, 0xe7, 0x48, 0x6e, 0xd2, 0x31, 0xf8, 0xd5, 0x84, 0x36, 0x26, 0xbe, 0x49, 0x02, 0x49,
	0xfd, 0x9b, 0x21, 0x48, 0x0f, 0x1a, 0x9b, 0xd3, 0x6a, 0x66, 0x20, 0x59, 0xcf, 0xd8, 0x81, 0xba,
	0x8e, 0x98, 0x44, 0x60, 0x2c, 0xf7, 0x26, 0x26, 0xfb, 0xd0, 0x8a, 0xd9, 0xca, 0x2b, 0x91, 0x8f,
	0xe0, 0x98, 0xee, 0x5e, 0xcc, 0x56, 0x25, 0x3e, 0xdf, 0x85, 0xe6, 0xda, 0x8b, 0x84, 0x69, 0x86,
	0xec, 0xc2, 0x88, 0x90, 0xf5, 0xc1, 0x5e, 0xbb, 0xb8, 0x8f, 0x1c, 0x99, 0x2e, 0x14, 0x9e, 0x89,
	0x5f, 0xc6, 0xb0, 0xfa, 0x2f, 0x18, 0xd6, 0xfe, 0x33, 0x86, 0xf5, 0xfb, 0x30, 0xfc, 0x00, 0x1e,
	0x6e, 0xb3, 0x90, 0xb3, 0xb3, 0xb7, 0xc5, 0xc1, 0x06, 0xb1, 0x50, 0x22, 0xf6, 0x73, 0xd8, 0x5d,
	0x0a, 0xc5, 0xe3, 0xc0, 0x4b, 0x98, 0xe4, 0x42, 0x33, 0xd1, 0x78, 0xf9, 0xf6, 0xa8, 0x7c, 0x3b,
	0x8c, 0x4e, 0xd0, 0x74, 0x8c, 0x9e, 0x43, 0x33, 0xdb, 0xb5, 0x6b, 0x2f, 0x37, 0x72, 0xc4, 0x81,
	0x9a, 0xcf, 0x12, 0x91, 0x72, 0x0d, 0x8b, 0xe5, 0x16, 0xe1, 0x16, 0x49, 0xbb, 0xff, 0x8f, 0xa4,
	0x67, 0x05, 0x49, 0x83, 0x3b, 0x48, 0xda, 0x02, 0x67, 0xb0, 0x00, 0x7b, 0x73, 0x5e, 0xf2, 0x14,
	0x6c, 0x3c, 0x58, 0xc5, 0x89, 0x34, 0xf0, 0x1f, 0x35, 0x30, 0x97, 0x1f, 0xc6, 0x27, 0x00, 0x2c,
	0xf6, 0x0b, 0xc3, 0x03, 0x34, 0x58, 0x2c, 0xf6, 0xb5, 0x7c, 0x2f, 0xc8, 0x9b, 0x6d, 0x06, 0xbf,
	0x18, 0xf0, 0xe8, 0x20, 0x3b, 0xe5, 0x6c, 0x93, 0xae, 0x94, 0xbc, 0x0f, 0x7b, 0xe5, 0xeb, 0x2f,
	0x75, 0x8c, 0xfe, 0xce, 0xd0, 0x74, 0x9b, 0xa5, 0xfb, 0x2f, 0x25, 0x9f, 0xc0, 0x1b, 0xb7, 0xce,
	0x36, 0x5e, 0x1b, 0x0c, 0x27, 0xaa, 0xbb, 0xaf, 0x6f, 0xad, 0x55, 0x77, 0xcb, 0x1a, 0x24, 0x92,
	0x47, 0x54, 0x9e, 0x6d, 0x91, 0xde, 0xcc, 0xd3, 0xf9, 0x28, 0xaf, 0xf6, 0x8b, 0xcf, 0x78, 0x5a,
	0xfe, 0x8c, 0x3b, 0xa6, 0x3e, 0x7c, 0x7e, 0x71, 0xd5, 0x35, 0x2e, 0xaf, 0xba, 0xc6, 0x9f, 0x57,
	0x5d, 0xe3, 0xfc, 0xba, 0x5b, 0xb9, 0xbc, 0xee, 0x56, 0x7e, 0xbb, 0xee, 0x56, 0xbe, 0x7b, 0x54,
	0x2e, 0x56, 0x67, 0x09, 0x4b, 0xa7, 0x55, 0xdc, 0xe4, 0x47, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff,
	0xfe, 0xb6, 0xc8, 0xb9, 0x7b, 0x06, 0x00, 0x00,
}

func (this *ModelVersion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelVersion)
	if !ok {
		that2, ok := that.(ModelVersion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VersionNumber != that1.VersionNumber {
		return false
	}
	if this.ModelId != that1.ModelId {
		return false
	}
	if this.ModelHash != that1.ModelHash {
		return false
	}
	if this.IpfsPath != that1.IpfsPath {
		return false
	}
	if this.Architecture != that1.Architecture {
		return false
	}
	if this.CompatibilityInfo != that1.CompatibilityInfo {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.ActivationHeight != that1.ActivationHeight {
		return false
	}
	if this.MigrationWindowStart != that1.MigrationWindowStart {
		return false
	}
	if this.MigrationWindowEnd != that1.MigrationWindowEnd {
		return false
	}
	if this.GovernanceProposalId != that1.GovernanceProposalId {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	return true
}
func (this *ModelUpgradeProposal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelUpgradeProposal)
	if !ok {
		that2, ok := that.(ModelUpgradeProposal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProposalId != that1.ProposalId {
		return false
	}
	if this.Proposer != that1.Proposer {
		return false
	}
	if this.NewModelVersion != that1.NewModelVersion {
		return false
	}
	if this.NewModelHash != that1.NewModelHash {
		return false
	}
	if this.NewModelId != that1.NewModelId {
		return false
	}
	if this.IpfsPath != that1.IpfsPath {
		return false
	}
	if this.Architecture != that1.Architecture {
		return false
	}
	if this.CompatibilityInfo != that1.CompatibilityInfo {
		return false
	}
	if this.MigrationWindow != that1.MigrationWindow {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.VotingPeriod.Equal(&that1.VotingPeriod) {
		return false
	}
	if this.Deposit != that1.Deposit {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	return true
}
func (this *VotingPeriod) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VotingPeriod)
	if !ok {
		that2, ok := that.(VotingPeriod)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartHeight != that1.StartHeight {
		return false
	}
	if this.EndHeight != that1.EndHeight {
		return false
	}
	return true
}
func (this *ActiveModelVersions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActiveModelVersions)
	if !ok {
		that2, ok := that.(ActiveModelVersions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VersionNumbers) != len(that1.VersionNumbers) {
		return false
	}
	for i := range this.VersionNumbers {
		if this.VersionNumbers[i] != that1.VersionNumbers[i] {
			return false
		}
	}
	if this.MigrationWindowActive != that1.MigrationWindowActive {
		return false
	}
	if this.PrimaryVersion != that1.PrimaryVersion {
		return false
	}
	return true
}
func (m *ModelVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintModelVersion(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x62
	if m.GovernanceProposalId != 0 {
		i = encodeVarintModelVersion(dAtA, i, uint64(m.GovernanceProposalId))
		i--
		dAtA[i] = 0x58
	}
	if m.MigrationWindowEnd != 0 {
		i = encodeVarintModelVersion(dAtA, i, uint64(m.MigrationWindowEnd))
		i--
		dAtA[i] = 0x50
	}
	if m.MigrationWindowStart != 0 {
		i = encodeVarintModelVersion(dAtA, i, uint64(m.MigrationWindowStart))
		i--
		dAtA[i] = 0x48
	}
	if m.ActivationHeight != 0 {
		i = encodeVarintModelVersion(dAtA, i, uint64(m.ActivationHeight))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintModelVersion(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CompatibilityInfo) > 0 {
		i -= len(m.CompatibilityInfo)
		copy(dAtA[i:], m.CompatibilityInfo)
		i = encodeVarintModelVersion(dAtA, i, uint64(len(m.CompatibilityInfo)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Architecture) > 0 {
		i -= len(m.Architecture)
		copy(dAtA[i:], m.Architecture)
		i = encodeVarintModelVersion(dAtA, i, uint64(len(m.Architecture)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IpfsPath) > 0 {
		i -= len(m.IpfsPath)
		copy(dAtA[i:], m.IpfsPath)
		i = encodeVarintModelVersion(dAtA, i, uint64(len(m.IpfsPath)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModelHash) > 0 {
		i -= len(m.ModelHash)
		copy(dAtA[i:], m.ModelHash)
		i = encodeVarintModelVersion(dAtA, i, uint64(len(m.ModelHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ModelId != 0 {
		i = encodeVarintModelVersion(dAtA, i, uint64(m.ModelId))
		i--
		dAtA[i] = 0x10
	}
	if m.VersionNumber != 0 {
		i = encodeVarintModelVersion(dAtA, i, uint64(m.VersionNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModelUpgradeProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelUpgradeProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelUpgradeProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintModelVersion(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x6a
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintModelVersion(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x62
	}
	{
		size, err := m.VotingPeriod.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintModelVersion(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintModelVersion(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x52
	}
	if m.MigrationWindow != 0 {
		i = encodeVarintModelVersion(dAtA, i, uint64(m.MigrationWindow))
		i--
		dAtA[i] = 0x48
	}
	if len(m.CompatibilityInfo) > 0 {
		i -= len(m.CompatibilityInfo)
		copy(dAtA[i:], m.CompatibilityInfo)
		i = encodeVarintModelVersion(dAtA, i, uint64(len(m.CompatibilityInfo)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Architecture) > 0 {
		i -= len(m.Architecture)
		copy(dAtA[i:], m.Architecture)
		i = encodeVarintModelVersion(dAtA, i, uint64(len(m.Architecture)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.IpfsPath) > 0 {
		i -= len(m.IpfsPath)
		copy(dAtA[i:], m.IpfsPath)
		i = encodeVarintModelVersion(dAtA, i, uint64(len(m.IpfsPath)))
		i--
		dAtA[i] = 0x32
	}
	if m.NewModelId != 0 {
		i = encodeVarintModelVersion(dAtA, i, uint64(m.NewModelId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.NewModelHash) > 0 {
		i -= len(m.NewModelHash)
		copy(dAtA[i:], m.NewModelHash)
		i = encodeVarintModelVersion(dAtA, i, uint64(len(m.NewModelHash)))
		i--
		dAtA[i] = 0x22
	}
	if m.NewModelVersion != 0 {
		i = encodeVarintModelVersion(dAtA, i, uint64(m.NewModelVersion))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintModelVersion(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalId != 0 {
		i = encodeVarintModelVersion(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VotingPeriod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VotingPeriod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VotingPeriod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndHeight != 0 {
		i = encodeVarintModelVersion(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.StartHeight != 0 {
		i = encodeVarintModelVersion(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActiveModelVersions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveModelVersions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActiveModelVersions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrimaryVersion != 0 {
		i = encodeVarintModelVersion(dAtA, i, uint64(m.PrimaryVersion))
		i--
		dAtA[i] = 0x18
	}
	if m.MigrationWindowActive {
		i--
		if m.MigrationWindowActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.VersionNumbers) > 0 {
		dAtA5 := make([]byte, len(m.VersionNumbers)*10)
		var j4 int
		for _, num := range m.VersionNumbers {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintModelVersion(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintModelVersion(dAtA []byte, offset int, v uint64) int {
	offset -= sovModelVersion(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ModelVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionNumber != 0 {
		n += 1 + sovModelVersion(uint64(m.VersionNumber))
	}
	if m.ModelId != 0 {
		n += 1 + sovModelVersion(uint64(m.ModelId))
	}
	l = len(m.ModelHash)
	if l > 0 {
		n += 1 + l + sovModelVersion(uint64(l))
	}
	l = len(m.IpfsPath)
	if l > 0 {
		n += 1 + l + sovModelVersion(uint64(l))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovModelVersion(uint64(l))
	}
	l = len(m.CompatibilityInfo)
	if l > 0 {
		n += 1 + l + sovModelVersion(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovModelVersion(uint64(l))
	}
	if m.ActivationHeight != 0 {
		n += 1 + sovModelVersion(uint64(m.ActivationHeight))
	}
	if m.MigrationWindowStart != 0 {
		n += 1 + sovModelVersion(uint64(m.MigrationWindowStart))
	}
	if m.MigrationWindowEnd != 0 {
		n += 1 + sovModelVersion(uint64(m.MigrationWindowEnd))
	}
	if m.GovernanceProposalId != 0 {
		n += 1 + sovModelVersion(uint64(m.GovernanceProposalId))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovModelVersion(uint64(l))
	return n
}

func (m *ModelUpgradeProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovModelVersion(uint64(m.ProposalId))
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovModelVersion(uint64(l))
	}
	if m.NewModelVersion != 0 {
		n += 1 + sovModelVersion(uint64(m.NewModelVersion))
	}
	l = len(m.NewModelHash)
	if l > 0 {
		n += 1 + l + sovModelVersion(uint64(l))
	}
	if m.NewModelId != 0 {
		n += 1 + sovModelVersion(uint64(m.NewModelId))
	}
	l = len(m.IpfsPath)
	if l > 0 {
		n += 1 + l + sovModelVersion(uint64(l))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovModelVersion(uint64(l))
	}
	l = len(m.CompatibilityInfo)
	if l > 0 {
		n += 1 + l + sovModelVersion(uint64(l))
	}
	if m.MigrationWindow != 0 {
		n += 1 + sovModelVersion(uint64(m.MigrationWindow))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovModelVersion(uint64(l))
	}
	l = m.VotingPeriod.Size()
	n += 1 + l + sovModelVersion(uint64(l))
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovModelVersion(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovModelVersion(uint64(l))
	return n
}

func (m *VotingPeriod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartHeight != 0 {
		n += 1 + sovModelVersion(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovModelVersion(uint64(m.EndHeight))
	}
	return n
}

func (m *ActiveModelVersions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VersionNumbers) > 0 {
		l = 0
		for _, e := range m.VersionNumbers {
			l += sovModelVersion(uint64(e))
		}
		n += 1 + sovModelVersion(uint64(l)) + l
	}
	if m.MigrationWindowActive {
		n += 2
	}
	if m.PrimaryVersion != 0 {
		n += 1 + sovModelVersion(uint64(m.PrimaryVersion))
	}
	return n
}

func sovModelVersion(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModelVersion(x uint64) (n int) {
	return sovModelVersion(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ModelVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionNumber", wireType)
			}
			m.VersionNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelId", wireType)
			}
			m.ModelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpfsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpfsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompatibilityInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompatibilityInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationHeight", wireType)
			}
			m.ActivationHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivationHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationWindowStart", wireType)
			}
			m.MigrationWindowStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigrationWindowStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationWindowEnd", wireType)
			}
			m.MigrationWindowEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigrationWindowEnd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GovernanceProposalId", wireType)
			}
			m.GovernanceProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GovernanceProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelUpgradeProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelUpgradeProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelUpgradeProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewModelVersion", wireType)
			}
			m.NewModelVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewModelVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewModelHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewModelHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewModelId", wireType)
			}
			m.NewModelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewModelId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpfsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpfsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompatibilityInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompatibilityInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationWindow", wireType)
			}
			m.MigrationWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigrationWindow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VotingPeriod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelVersion
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelVersion
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VotingPeriod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VotingPeriod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VotingPeriod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveModelVersions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveModelVersions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveModelVersions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelVersion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VersionNumbers = append(m.VersionNumbers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelVersion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModelVersion
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModelVersion
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.VersionNumbers) == 0 {
					m.VersionNumbers = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelVersion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VersionNumbers = append(m.VersionNumbers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionNumbers", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationWindowActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MigrationWindowActive = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryVersion", wireType)
			}
			m.PrimaryVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModelVersion(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModelVersion
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModelVersion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModelVersion
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModelVersion
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModelVersion
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModelVersion        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModelVersion          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModelVersion = fmt.Errorf("proto: unexpected end of group")
)
