// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: remes/remes/v1/slashing.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SlashingAppeal represents an appeal for a slashing decision
type SlashingAppeal struct {
	// appeal_id is the unique identifier for this appeal
	AppealId string `protobuf:"bytes,1,opt,name=appeal_id,json=appealId,proto3" json:"appeal_id,omitempty"`
	// slashed_node is the address of the slashed node
	SlashedNode string `protobuf:"bytes,2,opt,name=slashed_node,json=slashedNode,proto3" json:"slashed_node,omitempty"`
	// slashing_reason is the original reason for slashing
	SlashingReason string `protobuf:"bytes,3,opt,name=slashing_reason,json=slashingReason,proto3" json:"slashing_reason,omitempty"`
	// appeal_reason is the reason for the appeal
	AppealReason string `protobuf:"bytes,4,opt,name=appeal_reason,json=appealReason,proto3" json:"appeal_reason,omitempty"`
	// evidence_ipfs_hash is the IPFS hash of evidence supporting the appeal
	EvidenceIpfsHash string `protobuf:"bytes,5,opt,name=evidence_ipfs_hash,json=evidenceIpfsHash,proto3" json:"evidence_ipfs_hash,omitempty"`
	// created_at_height is the block height when appeal was created
	CreatedAtHeight int64 `protobuf:"varint,6,opt,name=created_at_height,json=createdAtHeight,proto3" json:"created_at_height,omitempty"`
	// status is the appeal status (pending, approved, rejected)
	Status string `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	// cpu_verification_result is the result of CPU Iron Sandbox verification
	CpuVerificationResult bool `protobuf:"varint,8,opt,name=cpu_verification_result,json=cpuVerificationResult,proto3" json:"cpu_verification_result,omitempty"`
	// resolution_height is the block height when appeal was resolved
	ResolutionHeight int64 `protobuf:"varint,9,opt,name=resolution_height,json=resolutionHeight,proto3" json:"resolution_height,omitempty"`
}

func (m *SlashingAppeal) Reset()         { *m = SlashingAppeal{} }
func (m *SlashingAppeal) String() string { return proto.CompactTextString(m) }
func (*SlashingAppeal) ProtoMessage()    {}
func (*SlashingAppeal) Descriptor() ([]byte, []int) {
	return fileDescriptor_fb01a072aa87ff07, []int{0}
}
func (m *SlashingAppeal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashingAppeal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashingAppeal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashingAppeal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashingAppeal.Merge(m, src)
}
func (m *SlashingAppeal) XXX_Size() int {
	return m.Size()
}
func (m *SlashingAppeal) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashingAppeal.DiscardUnknown(m)
}

var xxx_messageInfo_SlashingAppeal proto.InternalMessageInfo

func (m *SlashingAppeal) GetAppealId() string {
	if m != nil {
		return m.AppealId
	}
	return ""
}

func (m *SlashingAppeal) GetSlashedNode() string {
	if m != nil {
		return m.SlashedNode
	}
	return ""
}

func (m *SlashingAppeal) GetSlashingReason() string {
	if m != nil {
		return m.SlashingReason
	}
	return ""
}

func (m *SlashingAppeal) GetAppealReason() string {
	if m != nil {
		return m.AppealReason
	}
	return ""
}

func (m *SlashingAppeal) GetEvidenceIpfsHash() string {
	if m != nil {
		return m.EvidenceIpfsHash
	}
	return ""
}

func (m *SlashingAppeal) GetCreatedAtHeight() int64 {
	if m != nil {
		return m.CreatedAtHeight
	}
	return 0
}

func (m *SlashingAppeal) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *SlashingAppeal) GetCpuVerificationResult() bool {
	if m != nil {
		return m.CpuVerificationResult
	}
	return false
}

func (m *SlashingAppeal) GetResolutionHeight() int64 {
	if m != nil {
		return m.ResolutionHeight
	}
	return 0
}

// ValidatorVerificationRecord tracks validator verification activity
type ValidatorVerificationRecord struct {
	// validator_address is the address of the validator
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	// total_verifications is the total number of verifications performed
	TotalVerifications uint64 `protobuf:"varint,2,opt,name=total_verifications,json=totalVerifications,proto3" json:"total_verifications,omitempty"`
	// successful_verifications is the number of successful verifications
	SuccessfulVerifications uint64 `protobuf:"varint,3,opt,name=successful_verifications,json=successfulVerifications,proto3" json:"successful_verifications,omitempty"`
	// false_verdicts is the number of false verdicts (malicious validation)
	FalseVerdicts uint64 `protobuf:"varint,4,opt,name=false_verdicts,json=falseVerdicts,proto3" json:"false_verdicts,omitempty"`
	// lazy_validation_count is the number of lazy validation incidents
	LazyValidationCount uint64 `protobuf:"varint,5,opt,name=lazy_validation_count,json=lazyValidationCount,proto3" json:"lazy_validation_count,omitempty"`
	// last_verification_height is the block height of the last verification
	LastVerificationHeight int64 `protobuf:"varint,6,opt,name=last_verification_height,json=lastVerificationHeight,proto3" json:"last_verification_height,omitempty"`
}

func (m *ValidatorVerificationRecord) Reset()         { *m = ValidatorVerificationRecord{} }
func (m *ValidatorVerificationRecord) String() string { return proto.CompactTextString(m) }
func (*ValidatorVerificationRecord) ProtoMessage()    {}
func (*ValidatorVerificationRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_fb01a072aa87ff07, []int{1}
}
func (m *ValidatorVerificationRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorVerificationRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorVerificationRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorVerificationRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorVerificationRecord.Merge(m, src)
}
func (m *ValidatorVerificationRecord) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorVerificationRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorVerificationRecord.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorVerificationRecord proto.InternalMessageInfo

func (m *ValidatorVerificationRecord) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *ValidatorVerificationRecord) GetTotalVerifications() uint64 {
	if m != nil {
		return m.TotalVerifications
	}
	return 0
}

func (m *ValidatorVerificationRecord) GetSuccessfulVerifications() uint64 {
	if m != nil {
		return m.SuccessfulVerifications
	}
	return 0
}

func (m *ValidatorVerificationRecord) GetFalseVerdicts() uint64 {
	if m != nil {
		return m.FalseVerdicts
	}
	return 0
}

func (m *ValidatorVerificationRecord) GetLazyValidationCount() uint64 {
	if m != nil {
		return m.LazyValidationCount
	}
	return 0
}

func (m *ValidatorVerificationRecord) GetLastVerificationHeight() int64 {
	if m != nil {
		return m.LastVerificationHeight
	}
	return 0
}

// ProposerCensorshipRecord tracks proposer censorship activity
type ProposerCensorshipRecord struct {
	// proposer_address is the address of the proposer
	ProposerAddress string `protobuf:"bytes,1,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
	// total_aggregations is the total number of aggregations proposed
	TotalAggregations uint64 `protobuf:"varint,2,opt,name=total_aggregations,json=totalAggregations,proto3" json:"total_aggregations,omitempty"`
	// censored_gradients is the number of valid gradients excluded from aggregations
	CensoredGradients uint64 `protobuf:"varint,3,opt,name=censored_gradients,json=censoredGradients,proto3" json:"censored_gradients,omitempty"`
	// last_aggregation_height is the block height of the last aggregation
	LastAggregationHeight int64 `protobuf:"varint,4,opt,name=last_aggregation_height,json=lastAggregationHeight,proto3" json:"last_aggregation_height,omitempty"`
}

func (m *ProposerCensorshipRecord) Reset()         { *m = ProposerCensorshipRecord{} }
func (m *ProposerCensorshipRecord) String() string { return proto.CompactTextString(m) }
func (*ProposerCensorshipRecord) ProtoMessage()    {}
func (*ProposerCensorshipRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_fb01a072aa87ff07, []int{2}
}
func (m *ProposerCensorshipRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposerCensorshipRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposerCensorshipRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposerCensorshipRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposerCensorshipRecord.Merge(m, src)
}
func (m *ProposerCensorshipRecord) XXX_Size() int {
	return m.Size()
}
func (m *ProposerCensorshipRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposerCensorshipRecord.DiscardUnknown(m)
}

var xxx_messageInfo_ProposerCensorshipRecord proto.InternalMessageInfo

func (m *ProposerCensorshipRecord) GetProposerAddress() string {
	if m != nil {
		return m.ProposerAddress
	}
	return ""
}

func (m *ProposerCensorshipRecord) GetTotalAggregations() uint64 {
	if m != nil {
		return m.TotalAggregations
	}
	return 0
}

func (m *ProposerCensorshipRecord) GetCensoredGradients() uint64 {
	if m != nil {
		return m.CensoredGradients
	}
	return 0
}

func (m *ProposerCensorshipRecord) GetLastAggregationHeight() int64 {
	if m != nil {
		return m.LastAggregationHeight
	}
	return 0
}

// MentorRelationship represents a mentor-mentee relationship
type MentorRelationship struct {
	// mentor_address is the address of the mentor
	MentorAddress string `protobuf:"bytes,1,opt,name=mentor_address,json=mentorAddress,proto3" json:"mentor_address,omitempty"`
	// mentee_address is the address of the mentee (new miner)
	MenteeAddress string `protobuf:"bytes,2,opt,name=mentee_address,json=menteeAddress,proto3" json:"mentee_address,omitempty"`
	// reduced_stake_percentage is the reduced stake requirement for mentee (e.g., 50% = 0.5)
	ReducedStakePercentage string `protobuf:"bytes,3,opt,name=reduced_stake_percentage,json=reducedStakePercentage,proto3" json:"reduced_stake_percentage,omitempty"`
	// created_at_height is the block height when relationship was created
	CreatedAtHeight int64 `protobuf:"varint,4,opt,name=created_at_height,json=createdAtHeight,proto3" json:"created_at_height,omitempty"`
	// status is the relationship status (active, completed, terminated)
	Status string `protobuf:"bytes,5,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *MentorRelationship) Reset()         { *m = MentorRelationship{} }
func (m *MentorRelationship) String() string { return proto.CompactTextString(m) }
func (*MentorRelationship) ProtoMessage()    {}
func (*MentorRelationship) Descriptor() ([]byte, []int) {
	return fileDescriptor_fb01a072aa87ff07, []int{3}
}
func (m *MentorRelationship) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MentorRelationship) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MentorRelationship.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MentorRelationship) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MentorRelationship.Merge(m, src)
}
func (m *MentorRelationship) XXX_Size() int {
	return m.Size()
}
func (m *MentorRelationship) XXX_DiscardUnknown() {
	xxx_messageInfo_MentorRelationship.DiscardUnknown(m)
}

var xxx_messageInfo_MentorRelationship proto.InternalMessageInfo

func (m *MentorRelationship) GetMentorAddress() string {
	if m != nil {
		return m.MentorAddress
	}
	return ""
}

func (m *MentorRelationship) GetMenteeAddress() string {
	if m != nil {
		return m.MenteeAddress
	}
	return ""
}

func (m *MentorRelationship) GetReducedStakePercentage() string {
	if m != nil {
		return m.ReducedStakePercentage
	}
	return ""
}

func (m *MentorRelationship) GetCreatedAtHeight() int64 {
	if m != nil {
		return m.CreatedAtHeight
	}
	return 0
}

func (m *MentorRelationship) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func init() {
	proto.RegisterType((*SlashingAppeal)(nil), "remes.remes.v1.SlashingAppeal")
	proto.RegisterType((*ValidatorVerificationRecord)(nil), "remes.remes.v1.ValidatorVerificationRecord")
	proto.RegisterType((*ProposerCensorshipRecord)(nil), "remes.remes.v1.ProposerCensorshipRecord")
	proto.RegisterType((*MentorRelationship)(nil), "remes.remes.v1.MentorRelationship")
}

func init() { proto.RegisterFile("remes/remes/v1/slashing.proto", fileDescriptor_fb01a072aa87ff07) }

var fileDescriptor_fb01a072aa87ff07 = []byte{
	// 670 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x94, 0x4d, 0x4f, 0xd4, 0x40,
	0x18, 0xc7, 0xe9, 0xb2, 0x20, 0x8c, 0xb0, 0xec, 0x0e, 0x02, 0x0d, 0xc4, 0x15, 0x31, 0x46, 0x7c,
	0x81, 0x0d, 0x9a, 0x18, 0x3c, 0xae, 0x1c, 0x84, 0x83, 0x86, 0x94, 0x64, 0x0f, 0x5e, 0x26, 0x43,
	0xe7, 0xd9, 0xb6, 0xb1, 0xdb, 0x99, 0xcc, 0x33, 0xdd, 0x88, 0x9f, 0xc2, 0x8f, 0x65, 0xe2, 0x85,
	0xa3, 0x89, 0x17, 0x02, 0x9f, 0xc1, 0xbb, 0xe9, 0x74, 0xba, 0x74, 0x89, 0x89, 0x97, 0xa6, 0xfd,
	0xff, 0xfe, 0x33, 0xcf, 0x5b, 0x67, 0xc8, 0x43, 0x0d, 0x23, 0xc0, 0x5e, 0xf9, 0x1c, 0x1f, 0xf4,
	0x30, 0xe5, 0x18, 0x27, 0x59, 0xb4, 0xaf, 0xb4, 0x34, 0x92, 0xb6, 0x2c, 0xd8, 0x2f, 0x9f, 0xe3,
	0x83, 0xcd, 0x07, 0x91, 0x8c, 0xa4, 0x45, 0xbd, 0xe2, 0xad, 0x74, 0x6d, 0x3e, 0x8a, 0xa4, 0x8c,
	0x52, 0xe8, 0xd9, 0xaf, 0xf3, 0x7c, 0xd8, 0x33, 0xc9, 0x08, 0xd0, 0xf0, 0x91, 0x2a, 0x0d, 0x3b,
	0x7f, 0x1a, 0xa4, 0x75, 0xe6, 0x76, 0xee, 0x2b, 0x05, 0x3c, 0xa5, 0x5b, 0x64, 0x91, 0xdb, 0x37,
	0x96, 0x08, 0xdf, 0xdb, 0xf6, 0x76, 0x17, 0x83, 0x85, 0x52, 0x38, 0x11, 0xf4, 0x31, 0x59, 0xb2,
	0x89, 0x80, 0x60, 0x99, 0x14, 0xe0, 0x37, 0x2c, 0xbf, 0xef, 0xb4, 0x4f, 0x52, 0x00, 0x7d, 0x46,
	0x56, 0xaa, 0x5c, 0x99, 0x06, 0x8e, 0x32, 0xf3, 0x67, 0xad, 0xab, 0x55, 0xc9, 0x81, 0x55, 0xe9,
	0x13, 0xb2, 0xec, 0x02, 0x39, 0x5b, 0xd3, 0xda, 0x96, 0x4a, 0xd1, 0x99, 0x5e, 0x11, 0x0a, 0xe3,
	0x44, 0x40, 0x16, 0x02, 0x4b, 0xd4, 0x10, 0x59, 0xcc, 0x31, 0xf6, 0xe7, 0xac, 0xb3, 0x5d, 0x91,
	0x13, 0x35, 0xc4, 0x63, 0x8e, 0x31, 0x7d, 0x41, 0x3a, 0xa1, 0x06, 0x6e, 0x40, 0x30, 0x6e, 0x58,
	0x0c, 0x49, 0x14, 0x1b, 0x7f, 0x7e, 0xdb, 0xdb, 0x9d, 0x0d, 0x56, 0x1c, 0xe8, 0x9b, 0x63, 0x2b,
	0xd3, 0x75, 0x32, 0x8f, 0x86, 0x9b, 0x1c, 0xfd, 0x7b, 0x76, 0x37, 0xf7, 0x45, 0xdf, 0x92, 0x8d,
	0x50, 0xe5, 0x6c, 0x0c, 0x3a, 0x19, 0x26, 0x21, 0x37, 0x89, 0xcc, 0x98, 0x06, 0xcc, 0x53, 0xe3,
	0x2f, 0x6c, 0x7b, 0xbb, 0x0b, 0xc1, 0x5a, 0xa8, 0xf2, 0x41, 0x8d, 0x06, 0x16, 0xd2, 0x97, 0xa4,
	0xa3, 0x01, 0x65, 0x9a, 0xdb, 0x15, 0x2e, 0xf6, 0xa2, 0x8d, 0xdd, 0xbe, 0x05, 0x65, 0xf0, 0x9d,
	0x9f, 0x0d, 0xb2, 0x35, 0xe0, 0x69, 0x22, 0xb8, 0x91, 0x7a, 0x7a, 0xb3, 0x50, 0x6a, 0x51, 0x6c,
	0x36, 0xae, 0x30, 0xe3, 0x42, 0x68, 0x40, 0x74, 0xc3, 0x68, 0x4f, 0x40, 0xbf, 0xd4, 0x69, 0x8f,
	0xac, 0x1a, 0x69, 0x78, 0x3a, 0x95, 0x33, 0xda, 0xd9, 0x34, 0x03, 0x6a, 0x51, 0x3d, 0x04, 0xd2,
	0x77, 0xc4, 0xc7, 0x3c, 0x0c, 0x01, 0x71, 0x98, 0xdf, 0x5d, 0x35, 0x6b, 0x57, 0x6d, 0xdc, 0xf2,
	0xe9, 0xa5, 0x4f, 0x49, 0x6b, 0xc8, 0x53, 0x84, 0x62, 0x95, 0x48, 0x42, 0x83, 0x76, 0x6a, 0xcd,
	0x60, 0xd9, 0xaa, 0x03, 0x27, 0xd2, 0xd7, 0x64, 0x2d, 0xe5, 0xdf, 0x2e, 0x98, 0xcb, 0xb5, 0xe8,
	0x48, 0x28, 0xf3, 0xcc, 0xd8, 0xc9, 0x35, 0x83, 0xd5, 0x02, 0x0e, 0x26, 0xec, 0xa8, 0x40, 0xf4,
	0x90, 0xf8, 0x29, 0x47, 0x33, 0xdd, 0xf9, 0xa9, 0x19, 0xae, 0x17, 0xbc, 0x9e, 0x8f, 0xeb, 0xe6,
	0x6f, 0x8f, 0xf8, 0xa7, 0x5a, 0x2a, 0x89, 0xa0, 0x8f, 0x20, 0x43, 0xa9, 0x31, 0x4e, 0x94, 0x6b,
	0xe5, 0x73, 0xd2, 0x56, 0x8e, 0xdd, 0xe9, 0xe4, 0x4a, 0xa5, 0x57, 0x8d, 0xdc, 0x23, 0x65, 0xb7,
	0x18, 0x8f, 0x22, 0x0d, 0xd1, 0x54, 0x1f, 0x3b, 0x96, 0xf4, 0x6b, 0xa0, 0xb0, 0x87, 0x36, 0x1a,
	0x08, 0x16, 0x69, 0x2e, 0x12, 0xc8, 0x4c, 0xd5, 0xc0, 0x4e, 0x45, 0x3e, 0x54, 0xa0, 0xf8, 0xb1,
	0x6c, 0x7d, 0xb5, 0xcd, 0xab, 0xf2, 0x9a, 0xb6, 0xbc, 0xb5, 0x02, 0xd7, 0x22, 0xb8, 0xea, 0xae,
	0x3c, 0x42, 0x3f, 0x42, 0x66, 0xa4, 0x0e, 0x20, 0x2d, 0x43, 0xc7, 0x89, 0x2a, 0x26, 0x31, 0xb2,
	0xea, 0x9d, 0xaa, 0x96, 0x4b, 0xb5, 0xaa, 0xc9, 0xd9, 0x00, 0x26, 0xb6, 0xc6, 0xad, 0x0d, 0xa0,
	0xb2, 0x1d, 0x12, 0x5f, 0x83, 0xc8, 0x43, 0x10, 0x0c, 0x0d, 0xff, 0x02, 0x4c, 0x81, 0x0e, 0x21,
	0x33, 0x3c, 0x02, 0x77, 0x7c, 0xd7, 0x1d, 0x3f, 0x2b, 0xf0, 0xe9, 0x84, 0xfe, 0xfb, 0xcc, 0x35,
	0xff, 0x77, 0xe6, 0xe6, 0xea, 0x67, 0xee, 0xfd, 0xde, 0x8f, 0xeb, 0xae, 0x77, 0x79, 0xdd, 0xf5,
	0xae, 0xae, 0xbb, 0xde, 0xf7, 0x9b, 0xee, 0xcc, 0xe5, 0x4d, 0x77, 0xe6, 0xd7, 0x4d, 0x77, 0xe6,
	0xf3, 0x6a, 0x79, 0x01, 0x7e, 0x75, 0x17, 0xa1, 0xb9, 0x50, 0x80, 0xe7, 0xf3, 0xf6, 0xf2, 0x7a,
	0xf3, 0x37, 0x00, 0x00, 0xff, 0xff, 0x31, 0xa5, 0xcd, 0xe4, 0x24, 0x05, 0x00, 0x00,
}

func (m *SlashingAppeal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashingAppeal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashingAppeal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResolutionHeight != 0 {
		i = encodeVarintSlashing(dAtA, i, uint64(m.ResolutionHeight))
		i--
		dAtA[i] = 0x48
	}
	if m.CpuVerificationResult {
		i--
		if m.CpuVerificationResult {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintSlashing(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x3a
	}
	if m.CreatedAtHeight != 0 {
		i = encodeVarintSlashing(dAtA, i, uint64(m.CreatedAtHeight))
		i--
		dAtA[i] = 0x30
	}
	if len(m.EvidenceIpfsHash) > 0 {
		i -= len(m.EvidenceIpfsHash)
		copy(dAtA[i:], m.EvidenceIpfsHash)
		i = encodeVarintSlashing(dAtA, i, uint64(len(m.EvidenceIpfsHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AppealReason) > 0 {
		i -= len(m.AppealReason)
		copy(dAtA[i:], m.AppealReason)
		i = encodeVarintSlashing(dAtA, i, uint64(len(m.AppealReason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SlashingReason) > 0 {
		i -= len(m.SlashingReason)
		copy(dAtA[i:], m.SlashingReason)
		i = encodeVarintSlashing(dAtA, i, uint64(len(m.SlashingReason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SlashedNode) > 0 {
		i -= len(m.SlashedNode)
		copy(dAtA[i:], m.SlashedNode)
		i = encodeVarintSlashing(dAtA, i, uint64(len(m.SlashedNode)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppealId) > 0 {
		i -= len(m.AppealId)
		copy(dAtA[i:], m.AppealId)
		i = encodeVarintSlashing(dAtA, i, uint64(len(m.AppealId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorVerificationRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorVerificationRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorVerificationRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastVerificationHeight != 0 {
		i = encodeVarintSlashing(dAtA, i, uint64(m.LastVerificationHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.LazyValidationCount != 0 {
		i = encodeVarintSlashing(dAtA, i, uint64(m.LazyValidationCount))
		i--
		dAtA[i] = 0x28
	}
	if m.FalseVerdicts != 0 {
		i = encodeVarintSlashing(dAtA, i, uint64(m.FalseVerdicts))
		i--
		dAtA[i] = 0x20
	}
	if m.SuccessfulVerifications != 0 {
		i = encodeVarintSlashing(dAtA, i, uint64(m.SuccessfulVerifications))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalVerifications != 0 {
		i = encodeVarintSlashing(dAtA, i, uint64(m.TotalVerifications))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintSlashing(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposerCensorshipRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposerCensorshipRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposerCensorshipRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastAggregationHeight != 0 {
		i = encodeVarintSlashing(dAtA, i, uint64(m.LastAggregationHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.CensoredGradients != 0 {
		i = encodeVarintSlashing(dAtA, i, uint64(m.CensoredGradients))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalAggregations != 0 {
		i = encodeVarintSlashing(dAtA, i, uint64(m.TotalAggregations))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ProposerAddress) > 0 {
		i -= len(m.ProposerAddress)
		copy(dAtA[i:], m.ProposerAddress)
		i = encodeVarintSlashing(dAtA, i, uint64(len(m.ProposerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MentorRelationship) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MentorRelationship) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MentorRelationship) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintSlashing(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CreatedAtHeight != 0 {
		i = encodeVarintSlashing(dAtA, i, uint64(m.CreatedAtHeight))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ReducedStakePercentage) > 0 {
		i -= len(m.ReducedStakePercentage)
		copy(dAtA[i:], m.ReducedStakePercentage)
		i = encodeVarintSlashing(dAtA, i, uint64(len(m.ReducedStakePercentage)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MenteeAddress) > 0 {
		i -= len(m.MenteeAddress)
		copy(dAtA[i:], m.MenteeAddress)
		i = encodeVarintSlashing(dAtA, i, uint64(len(m.MenteeAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MentorAddress) > 0 {
		i -= len(m.MentorAddress)
		copy(dAtA[i:], m.MentorAddress)
		i = encodeVarintSlashing(dAtA, i, uint64(len(m.MentorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSlashing(dAtA []byte, offset int, v uint64) int {
	offset -= sovSlashing(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SlashingAppeal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppealId)
	if l > 0 {
		n += 1 + l + sovSlashing(uint64(l))
	}
	l = len(m.SlashedNode)
	if l > 0 {
		n += 1 + l + sovSlashing(uint64(l))
	}
	l = len(m.SlashingReason)
	if l > 0 {
		n += 1 + l + sovSlashing(uint64(l))
	}
	l = len(m.AppealReason)
	if l > 0 {
		n += 1 + l + sovSlashing(uint64(l))
	}
	l = len(m.EvidenceIpfsHash)
	if l > 0 {
		n += 1 + l + sovSlashing(uint64(l))
	}
	if m.CreatedAtHeight != 0 {
		n += 1 + sovSlashing(uint64(m.CreatedAtHeight))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovSlashing(uint64(l))
	}
	if m.CpuVerificationResult {
		n += 2
	}
	if m.ResolutionHeight != 0 {
		n += 1 + sovSlashing(uint64(m.ResolutionHeight))
	}
	return n
}

func (m *ValidatorVerificationRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovSlashing(uint64(l))
	}
	if m.TotalVerifications != 0 {
		n += 1 + sovSlashing(uint64(m.TotalVerifications))
	}
	if m.SuccessfulVerifications != 0 {
		n += 1 + sovSlashing(uint64(m.SuccessfulVerifications))
	}
	if m.FalseVerdicts != 0 {
		n += 1 + sovSlashing(uint64(m.FalseVerdicts))
	}
	if m.LazyValidationCount != 0 {
		n += 1 + sovSlashing(uint64(m.LazyValidationCount))
	}
	if m.LastVerificationHeight != 0 {
		n += 1 + sovSlashing(uint64(m.LastVerificationHeight))
	}
	return n
}

func (m *ProposerCensorshipRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProposerAddress)
	if l > 0 {
		n += 1 + l + sovSlashing(uint64(l))
	}
	if m.TotalAggregations != 0 {
		n += 1 + sovSlashing(uint64(m.TotalAggregations))
	}
	if m.CensoredGradients != 0 {
		n += 1 + sovSlashing(uint64(m.CensoredGradients))
	}
	if m.LastAggregationHeight != 0 {
		n += 1 + sovSlashing(uint64(m.LastAggregationHeight))
	}
	return n
}

func (m *MentorRelationship) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MentorAddress)
	if l > 0 {
		n += 1 + l + sovSlashing(uint64(l))
	}
	l = len(m.MenteeAddress)
	if l > 0 {
		n += 1 + l + sovSlashing(uint64(l))
	}
	l = len(m.ReducedStakePercentage)
	if l > 0 {
		n += 1 + l + sovSlashing(uint64(l))
	}
	if m.CreatedAtHeight != 0 {
		n += 1 + sovSlashing(uint64(m.CreatedAtHeight))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovSlashing(uint64(l))
	}
	return n
}

func sovSlashing(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSlashing(x uint64) (n int) {
	return sovSlashing(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SlashingAppeal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlashing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashingAppeal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashingAppeal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlashing
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlashing
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlashing
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlashing
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashedNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlashing
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlashing
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashingReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlashing
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlashing
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlashing
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlashing
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAtHeight", wireType)
			}
			m.CreatedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlashing
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlashing
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuVerificationResult", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CpuVerificationResult = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolutionHeight", wireType)
			}
			m.ResolutionHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolutionHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSlashing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSlashing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorVerificationRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlashing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorVerificationRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorVerificationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlashing
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlashing
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVerifications", wireType)
			}
			m.TotalVerifications = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalVerifications |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessfulVerifications", wireType)
			}
			m.SuccessfulVerifications = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessfulVerifications |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FalseVerdicts", wireType)
			}
			m.FalseVerdicts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FalseVerdicts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LazyValidationCount", wireType)
			}
			m.LazyValidationCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LazyValidationCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastVerificationHeight", wireType)
			}
			m.LastVerificationHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastVerificationHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSlashing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSlashing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposerCensorshipRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlashing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposerCensorshipRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposerCensorshipRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlashing
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlashing
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAggregations", wireType)
			}
			m.TotalAggregations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAggregations |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CensoredGradients", wireType)
			}
			m.CensoredGradients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CensoredGradients |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAggregationHeight", wireType)
			}
			m.LastAggregationHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastAggregationHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSlashing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSlashing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MentorRelationship) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSlashing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MentorRelationship: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MentorRelationship: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MentorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlashing
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlashing
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MentorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MenteeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlashing
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlashing
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MenteeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReducedStakePercentage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlashing
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlashing
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReducedStakePercentage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAtHeight", wireType)
			}
			m.CreatedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSlashing
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSlashing
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSlashing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSlashing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSlashing(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSlashing
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSlashing
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSlashing
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSlashing
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSlashing
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSlashing        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSlashing          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSlashing = fmt.Errorf("proto: unexpected end of group")
)
