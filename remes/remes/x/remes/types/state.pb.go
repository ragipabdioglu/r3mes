// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: remes/remes/v1/state.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GlobalModelState represents the current global model state
type GlobalModelState struct {
	// model_ipfs_hash is the IPFS hash of the current global model
	ModelIpfsHash string `protobuf:"bytes,1,opt,name=model_ipfs_hash,json=modelIpfsHash,proto3" json:"model_ipfs_hash,omitempty"`
	// model_version is the version of the current model (e.g., "v1.0.0")
	ModelVersion string `protobuf:"bytes,2,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
	// last_updated_height is the block height when the model was last updated
	LastUpdatedHeight int64 `protobuf:"varint,3,opt,name=last_updated_height,json=lastUpdatedHeight,proto3" json:"last_updated_height,omitempty"`
	// last_updated_time is the timestamp when the model was last updated
	LastUpdatedTime time.Time `protobuf:"bytes,4,opt,name=last_updated_time,json=lastUpdatedTime,proto3,stdtime" json:"last_updated_time"`
	// training_round_id is the training round ID of the current global model
	TrainingRoundId uint64 `protobuf:"varint,5,opt,name=training_round_id,json=trainingRoundId,proto3" json:"training_round_id,omitempty"`
	// last_aggregation_id is the aggregation ID that was used to create this global model
	LastAggregationId uint64 `protobuf:"varint,6,opt,name=last_aggregation_id,json=lastAggregationId,proto3" json:"last_aggregation_id,omitempty"`
}

func (m *GlobalModelState) Reset()         { *m = GlobalModelState{} }
func (m *GlobalModelState) String() string { return proto.CompactTextString(m) }
func (*GlobalModelState) ProtoMessage()    {}
func (*GlobalModelState) Descriptor() ([]byte, []int) {
	return fileDescriptor_939c40a03eb9dc57, []int{0}
}
func (m *GlobalModelState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalModelState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalModelState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalModelState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalModelState.Merge(m, src)
}
func (m *GlobalModelState) XXX_Size() int {
	return m.Size()
}
func (m *GlobalModelState) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalModelState.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalModelState proto.InternalMessageInfo

func (m *GlobalModelState) GetModelIpfsHash() string {
	if m != nil {
		return m.ModelIpfsHash
	}
	return ""
}

func (m *GlobalModelState) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

func (m *GlobalModelState) GetLastUpdatedHeight() int64 {
	if m != nil {
		return m.LastUpdatedHeight
	}
	return 0
}

func (m *GlobalModelState) GetLastUpdatedTime() time.Time {
	if m != nil {
		return m.LastUpdatedTime
	}
	return time.Time{}
}

func (m *GlobalModelState) GetTrainingRoundId() uint64 {
	if m != nil {
		return m.TrainingRoundId
	}
	return 0
}

func (m *GlobalModelState) GetLastAggregationId() uint64 {
	if m != nil {
		return m.LastAggregationId
	}
	return 0
}

// AggregationRecord represents an aggregation record stored on-chain
type AggregationRecord struct {
	// aggregation_id is the unique identifier for this aggregation
	AggregationId uint64 `protobuf:"varint,1,opt,name=aggregation_id,json=aggregationId,proto3" json:"aggregation_id,omitempty"`
	// proposer is the address of the proposer who performed aggregation
	Proposer string `protobuf:"bytes,2,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// aggregated_gradient_ipfs_hash is the IPFS hash of the aggregated gradient result
	AggregatedGradientIpfsHash string `protobuf:"bytes,3,opt,name=aggregated_gradient_ipfs_hash,json=aggregatedGradientIpfsHash,proto3" json:"aggregated_gradient_ipfs_hash,omitempty"`
	// merkle_root is the Merkle root hash of all included gradients
	MerkleRoot string `protobuf:"bytes,4,opt,name=merkle_root,json=merkleRoot,proto3" json:"merkle_root,omitempty"`
	// participant_gradient_ids are the IDs of all gradients included in aggregation
	ParticipantGradientIds []uint64 `protobuf:"varint,5,rep,packed,name=participant_gradient_ids,json=participantGradientIds,proto3" json:"participant_gradient_ids,omitempty"`
	// training_round_id is the identifier for the training round
	TrainingRoundId uint64 `protobuf:"varint,6,opt,name=training_round_id,json=trainingRoundId,proto3" json:"training_round_id,omitempty"`
	// model_version is the version of the model used
	ModelVersion string `protobuf:"bytes,7,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
	// submitted_at_height is the block height when this aggregation was submitted
	SubmittedAtHeight int64 `protobuf:"varint,8,opt,name=submitted_at_height,json=submittedAtHeight,proto3" json:"submitted_at_height,omitempty"`
	// status is the current status (pending, finalized, challenged)
	Status string `protobuf:"bytes,9,opt,name=status,proto3" json:"status,omitempty"`
	// challenge_deadline_height is the block height when challenge period ends (submitted_at_height + challenge_period_blocks)
	ChallengeDeadlineHeight int64 `protobuf:"varint,10,opt,name=challenge_deadline_height,json=challengeDeadlineHeight,proto3" json:"challenge_deadline_height,omitempty"`
}

func (m *AggregationRecord) Reset()         { *m = AggregationRecord{} }
func (m *AggregationRecord) String() string { return proto.CompactTextString(m) }
func (*AggregationRecord) ProtoMessage()    {}
func (*AggregationRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_939c40a03eb9dc57, []int{1}
}
func (m *AggregationRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregationRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggregationRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggregationRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregationRecord.Merge(m, src)
}
func (m *AggregationRecord) XXX_Size() int {
	return m.Size()
}
func (m *AggregationRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregationRecord.DiscardUnknown(m)
}

var xxx_messageInfo_AggregationRecord proto.InternalMessageInfo

func (m *AggregationRecord) GetAggregationId() uint64 {
	if m != nil {
		return m.AggregationId
	}
	return 0
}

func (m *AggregationRecord) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *AggregationRecord) GetAggregatedGradientIpfsHash() string {
	if m != nil {
		return m.AggregatedGradientIpfsHash
	}
	return ""
}

func (m *AggregationRecord) GetMerkleRoot() string {
	if m != nil {
		return m.MerkleRoot
	}
	return ""
}

func (m *AggregationRecord) GetParticipantGradientIds() []uint64 {
	if m != nil {
		return m.ParticipantGradientIds
	}
	return nil
}

func (m *AggregationRecord) GetTrainingRoundId() uint64 {
	if m != nil {
		return m.TrainingRoundId
	}
	return 0
}

func (m *AggregationRecord) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

func (m *AggregationRecord) GetSubmittedAtHeight() int64 {
	if m != nil {
		return m.SubmittedAtHeight
	}
	return 0
}

func (m *AggregationRecord) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *AggregationRecord) GetChallengeDeadlineHeight() int64 {
	if m != nil {
		return m.ChallengeDeadlineHeight
	}
	return 0
}

// AggregationCommitment represents a commitment to an aggregation result (commit-reveal scheme)
type AggregationCommitment struct {
	// commitment_id is the unique identifier for this commitment
	CommitmentId uint64 `protobuf:"varint,1,opt,name=commitment_id,json=commitmentId,proto3" json:"commitment_id,omitempty"`
	// proposer is the address of the proposer who made the commitment
	Proposer string `protobuf:"bytes,2,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// commitment_hash is the hash of (aggregated_hash + merkle_root + participant_ids + salt)
	CommitmentHash string `protobuf:"bytes,3,opt,name=commitment_hash,json=commitmentHash,proto3" json:"commitment_hash,omitempty"`
	// training_round_id is the identifier for the training round
	TrainingRoundId uint64 `protobuf:"varint,4,opt,name=training_round_id,json=trainingRoundId,proto3" json:"training_round_id,omitempty"`
	// participant_gradient_ids are the IDs of all gradients included in aggregation
	ParticipantGradientIds []uint64 `protobuf:"varint,5,rep,packed,name=participant_gradient_ids,json=participantGradientIds,proto3" json:"participant_gradient_ids,omitempty"`
	// committed_at_height is the block height when this commitment was made
	CommittedAtHeight int64 `protobuf:"varint,6,opt,name=committed_at_height,json=committedAtHeight,proto3" json:"committed_at_height,omitempty"`
	// reveal_deadline_height is the block height when reveal period starts
	RevealDeadlineHeight int64 `protobuf:"varint,7,opt,name=reveal_deadline_height,json=revealDeadlineHeight,proto3" json:"reveal_deadline_height,omitempty"`
	// status is the current status (committed, revealed, expired)
	Status string `protobuf:"bytes,8,opt,name=status,proto3" json:"status,omitempty"`
	// revealed_aggregation_id is the aggregation ID created after reveal (if revealed)
	RevealedAggregationId uint64 `protobuf:"varint,9,opt,name=revealed_aggregation_id,json=revealedAggregationId,proto3" json:"revealed_aggregation_id,omitempty"`
}

func (m *AggregationCommitment) Reset()         { *m = AggregationCommitment{} }
func (m *AggregationCommitment) String() string { return proto.CompactTextString(m) }
func (*AggregationCommitment) ProtoMessage()    {}
func (*AggregationCommitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_939c40a03eb9dc57, []int{2}
}
func (m *AggregationCommitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregationCommitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggregationCommitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggregationCommitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregationCommitment.Merge(m, src)
}
func (m *AggregationCommitment) XXX_Size() int {
	return m.Size()
}
func (m *AggregationCommitment) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregationCommitment.DiscardUnknown(m)
}

var xxx_messageInfo_AggregationCommitment proto.InternalMessageInfo

func (m *AggregationCommitment) GetCommitmentId() uint64 {
	if m != nil {
		return m.CommitmentId
	}
	return 0
}

func (m *AggregationCommitment) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *AggregationCommitment) GetCommitmentHash() string {
	if m != nil {
		return m.CommitmentHash
	}
	return ""
}

func (m *AggregationCommitment) GetTrainingRoundId() uint64 {
	if m != nil {
		return m.TrainingRoundId
	}
	return 0
}

func (m *AggregationCommitment) GetParticipantGradientIds() []uint64 {
	if m != nil {
		return m.ParticipantGradientIds
	}
	return nil
}

func (m *AggregationCommitment) GetCommittedAtHeight() int64 {
	if m != nil {
		return m.CommittedAtHeight
	}
	return 0
}

func (m *AggregationCommitment) GetRevealDeadlineHeight() int64 {
	if m != nil {
		return m.RevealDeadlineHeight
	}
	return 0
}

func (m *AggregationCommitment) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *AggregationCommitment) GetRevealedAggregationId() uint64 {
	if m != nil {
		return m.RevealedAggregationId
	}
	return 0
}

// MiningContribution represents a miner's contribution to the network
type MiningContribution struct {
	// miner_address is the address of the miner
	MinerAddress string `protobuf:"bytes,1,opt,name=miner_address,json=minerAddress,proto3" json:"miner_address,omitempty"`
	// total_submissions is the total number of gradient submissions
	TotalSubmissions uint64 `protobuf:"varint,2,opt,name=total_submissions,json=totalSubmissions,proto3" json:"total_submissions,omitempty"`
	// successful_submissions is the number of successful submissions
	SuccessfulSubmissions uint64 `protobuf:"varint,3,opt,name=successful_submissions,json=successfulSubmissions,proto3" json:"successful_submissions,omitempty"`
	// trust_score is the reputation score (0.0 to 1.0)
	TrustScore string `protobuf:"bytes,4,opt,name=trust_score,json=trustScore,proto3" json:"trust_score,omitempty"`
	// reputation_tier is the tier (excellent, trusted, developing, new)
	ReputationTier string `protobuf:"bytes,5,opt,name=reputation_tier,json=reputationTier,proto3" json:"reputation_tier,omitempty"`
	// slashing_events is the number of slashing events
	SlashingEvents uint64 `protobuf:"varint,6,opt,name=slashing_events,json=slashingEvents,proto3" json:"slashing_events,omitempty"`
	// last_submission_height is the block height of the last submission
	LastSubmissionHeight int64 `protobuf:"varint,7,opt,name=last_submission_height,json=lastSubmissionHeight,proto3" json:"last_submission_height,omitempty"`
	// traps_caught is the number of trap jobs successfully completed
	TrapsCaught uint64 `protobuf:"varint,8,opt,name=traps_caught,json=trapsCaught,proto3" json:"traps_caught,omitempty"`
	// traps_failed is the number of trap jobs that failed verification
	TrapsFailed uint64 `protobuf:"varint,9,opt,name=traps_failed,json=trapsFailed,proto3" json:"traps_failed,omitempty"`
	// fraud_score is the fraud risk score (0.0 to 1.0, higher = more fraudulent)
	FraudScore string `protobuf:"bytes,10,opt,name=fraud_score,json=fraudScore,proto3" json:"fraud_score,omitempty"`
}

func (m *MiningContribution) Reset()         { *m = MiningContribution{} }
func (m *MiningContribution) String() string { return proto.CompactTextString(m) }
func (*MiningContribution) ProtoMessage()    {}
func (*MiningContribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_939c40a03eb9dc57, []int{3}
}
func (m *MiningContribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MiningContribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MiningContribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MiningContribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MiningContribution.Merge(m, src)
}
func (m *MiningContribution) XXX_Size() int {
	return m.Size()
}
func (m *MiningContribution) XXX_DiscardUnknown() {
	xxx_messageInfo_MiningContribution.DiscardUnknown(m)
}

var xxx_messageInfo_MiningContribution proto.InternalMessageInfo

func (m *MiningContribution) GetMinerAddress() string {
	if m != nil {
		return m.MinerAddress
	}
	return ""
}

func (m *MiningContribution) GetTotalSubmissions() uint64 {
	if m != nil {
		return m.TotalSubmissions
	}
	return 0
}

func (m *MiningContribution) GetSuccessfulSubmissions() uint64 {
	if m != nil {
		return m.SuccessfulSubmissions
	}
	return 0
}

func (m *MiningContribution) GetTrustScore() string {
	if m != nil {
		return m.TrustScore
	}
	return ""
}

func (m *MiningContribution) GetReputationTier() string {
	if m != nil {
		return m.ReputationTier
	}
	return ""
}

func (m *MiningContribution) GetSlashingEvents() uint64 {
	if m != nil {
		return m.SlashingEvents
	}
	return 0
}

func (m *MiningContribution) GetLastSubmissionHeight() int64 {
	if m != nil {
		return m.LastSubmissionHeight
	}
	return 0
}

func (m *MiningContribution) GetTrapsCaught() uint64 {
	if m != nil {
		return m.TrapsCaught
	}
	return 0
}

func (m *MiningContribution) GetTrapsFailed() uint64 {
	if m != nil {
		return m.TrapsFailed
	}
	return 0
}

func (m *MiningContribution) GetFraudScore() string {
	if m != nil {
		return m.FraudScore
	}
	return ""
}

// ChallengeRecord represents a challenge to an aggregation
type ChallengeRecord struct {
	// challenge_id is the unique identifier for this challenge
	ChallengeId uint64 `protobuf:"varint,1,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id,omitempty"`
	// challenger is the address of the node challenging the aggregation
	Challenger string `protobuf:"bytes,2,opt,name=challenger,proto3" json:"challenger,omitempty"`
	// aggregation_id is the ID of the aggregation being challenged
	AggregationId uint64 `protobuf:"varint,3,opt,name=aggregation_id,json=aggregationId,proto3" json:"aggregation_id,omitempty"`
	// reason is the reason for the challenge
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	// evidence_ipfs_hash is the IPFS hash of evidence supporting the challenge
	EvidenceIpfsHash string `protobuf:"bytes,5,opt,name=evidence_ipfs_hash,json=evidenceIpfsHash,proto3" json:"evidence_ipfs_hash,omitempty"`
	// status is the current status (pending, resolved, rejected)
	Status string `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
	// created_at_height is the block height when this challenge was created
	CreatedAtHeight int64 `protobuf:"varint,7,opt,name=created_at_height,json=createdAtHeight,proto3" json:"created_at_height,omitempty"`
	// cpu_verification_panel is the list of validator addresses selected for CPU verification
	CpuVerificationPanel []string `protobuf:"bytes,8,rep,name=cpu_verification_panel,json=cpuVerificationPanel,proto3" json:"cpu_verification_panel,omitempty"`
	// cpu_verification_results stores verification results from panel validators
	CpuVerificationResults []*CPUVerificationResult `protobuf:"bytes,9,rep,name=cpu_verification_results,json=cpuVerificationResults,proto3" json:"cpu_verification_results,omitempty"`
	// resolution_height is the block height when challenge was resolved
	ResolutionHeight int64 `protobuf:"varint,10,opt,name=resolution_height,json=resolutionHeight,proto3" json:"resolution_height,omitempty"`
	// fraud_detected indicates if fraud was detected
	FraudDetected bool `protobuf:"varint,11,opt,name=fraud_detected,json=fraudDetected,proto3" json:"fraud_detected,omitempty"`
	// layer indicates the verification layer (1=GPU-to-GPU, 2=High-Stakes Challenge, 3=CPU Iron Sandbox)
	Layer uint32 `protobuf:"varint,12,opt,name=layer,proto3" json:"layer,omitempty"`
	// bond_amount is the bond amount required for Layer 2 challenge (10x base reward)
	BondAmount string `protobuf:"bytes,13,opt,name=bond_amount,json=bondAmount,proto3" json:"bond_amount,omitempty"`
	// random_verifier is the randomly selected GPU verifier for Layer 2
	RandomVerifier string `protobuf:"bytes,14,opt,name=random_verifier,json=randomVerifier,proto3" json:"random_verifier,omitempty"`
	// random_verifier_result is the result from random verifier ("valid", "invalid", "pending")
	RandomVerifierResult string `protobuf:"bytes,15,opt,name=random_verifier_result,json=randomVerifierResult,proto3" json:"random_verifier_result,omitempty"`
	// miner_weights_ipfs is the IPFS hash of miner's model weights (for Loss-Based Spot Checking)
	MinerWeightsIpfs string `protobuf:"bytes,16,opt,name=miner_weights_ipfs,json=minerWeightsIpfs,proto3" json:"miner_weights_ipfs,omitempty"`
	// data_batch_seed is the VRF seed for deterministic batch selection (for Loss-Based Spot Checking)
	DataBatchSeed uint64 `protobuf:"varint,17,opt,name=data_batch_seed,json=dataBatchSeed,proto3" json:"data_batch_seed,omitempty"`
	// verifier_loss is the loss calculated by the random verifier (BitNet integer format)
	VerifierLoss string `protobuf:"bytes,18,opt,name=verifier_loss,json=verifierLoss,proto3" json:"verifier_loss,omitempty"`
	// loss_match indicates if miner's claimed loss matches verifier's calculated loss (within tolerance)
	LossMatch bool `protobuf:"varint,19,opt,name=loss_match,json=lossMatch,proto3" json:"loss_match,omitempty"`
	// loss_tolerance is the tolerance used for loss comparison (BitNet integer format, default: Â±1)
	LossTolerance string `protobuf:"bytes,20,opt,name=loss_tolerance,json=lossTolerance,proto3" json:"loss_tolerance,omitempty"`
}

func (m *ChallengeRecord) Reset()         { *m = ChallengeRecord{} }
func (m *ChallengeRecord) String() string { return proto.CompactTextString(m) }
func (*ChallengeRecord) ProtoMessage()    {}
func (*ChallengeRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_939c40a03eb9dc57, []int{4}
}
func (m *ChallengeRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeRecord.Merge(m, src)
}
func (m *ChallengeRecord) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeRecord.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeRecord proto.InternalMessageInfo

func (m *ChallengeRecord) GetChallengeId() uint64 {
	if m != nil {
		return m.ChallengeId
	}
	return 0
}

func (m *ChallengeRecord) GetChallenger() string {
	if m != nil {
		return m.Challenger
	}
	return ""
}

func (m *ChallengeRecord) GetAggregationId() uint64 {
	if m != nil {
		return m.AggregationId
	}
	return 0
}

func (m *ChallengeRecord) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ChallengeRecord) GetEvidenceIpfsHash() string {
	if m != nil {
		return m.EvidenceIpfsHash
	}
	return ""
}

func (m *ChallengeRecord) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ChallengeRecord) GetCreatedAtHeight() int64 {
	if m != nil {
		return m.CreatedAtHeight
	}
	return 0
}

func (m *ChallengeRecord) GetCpuVerificationPanel() []string {
	if m != nil {
		return m.CpuVerificationPanel
	}
	return nil
}

func (m *ChallengeRecord) GetCpuVerificationResults() []*CPUVerificationResult {
	if m != nil {
		return m.CpuVerificationResults
	}
	return nil
}

func (m *ChallengeRecord) GetResolutionHeight() int64 {
	if m != nil {
		return m.ResolutionHeight
	}
	return 0
}

func (m *ChallengeRecord) GetFraudDetected() bool {
	if m != nil {
		return m.FraudDetected
	}
	return false
}

func (m *ChallengeRecord) GetLayer() uint32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *ChallengeRecord) GetBondAmount() string {
	if m != nil {
		return m.BondAmount
	}
	return ""
}

func (m *ChallengeRecord) GetRandomVerifier() string {
	if m != nil {
		return m.RandomVerifier
	}
	return ""
}

func (m *ChallengeRecord) GetRandomVerifierResult() string {
	if m != nil {
		return m.RandomVerifierResult
	}
	return ""
}

func (m *ChallengeRecord) GetMinerWeightsIpfs() string {
	if m != nil {
		return m.MinerWeightsIpfs
	}
	return ""
}

func (m *ChallengeRecord) GetDataBatchSeed() uint64 {
	if m != nil {
		return m.DataBatchSeed
	}
	return 0
}

func (m *ChallengeRecord) GetVerifierLoss() string {
	if m != nil {
		return m.VerifierLoss
	}
	return ""
}

func (m *ChallengeRecord) GetLossMatch() bool {
	if m != nil {
		return m.LossMatch
	}
	return false
}

func (m *ChallengeRecord) GetLossTolerance() string {
	if m != nil {
		return m.LossTolerance
	}
	return ""
}

// CPUVerificationResult represents a CPU verification result from a validator
type CPUVerificationResult struct {
	// validator_address is the address of the validator
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	// is_valid indicates if the gradient is valid
	IsValid bool `protobuf:"varint,2,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`
	// computed_hash is the hash computed by the validator
	ComputedHash string `protobuf:"bytes,3,opt,name=computed_hash,json=computedHash,proto3" json:"computed_hash,omitempty"`
	// expected_hash is the expected hash from the aggregation
	ExpectedHash string `protobuf:"bytes,4,opt,name=expected_hash,json=expectedHash,proto3" json:"expected_hash,omitempty"`
	// verification_time is when the verification was performed
	VerificationTime time.Time `protobuf:"bytes,5,opt,name=verification_time,json=verificationTime,proto3,stdtime" json:"verification_time"`
}

func (m *CPUVerificationResult) Reset()         { *m = CPUVerificationResult{} }
func (m *CPUVerificationResult) String() string { return proto.CompactTextString(m) }
func (*CPUVerificationResult) ProtoMessage()    {}
func (*CPUVerificationResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_939c40a03eb9dc57, []int{5}
}
func (m *CPUVerificationResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPUVerificationResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPUVerificationResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPUVerificationResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPUVerificationResult.Merge(m, src)
}
func (m *CPUVerificationResult) XXX_Size() int {
	return m.Size()
}
func (m *CPUVerificationResult) XXX_DiscardUnknown() {
	xxx_messageInfo_CPUVerificationResult.DiscardUnknown(m)
}

var xxx_messageInfo_CPUVerificationResult proto.InternalMessageInfo

func (m *CPUVerificationResult) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *CPUVerificationResult) GetIsValid() bool {
	if m != nil {
		return m.IsValid
	}
	return false
}

func (m *CPUVerificationResult) GetComputedHash() string {
	if m != nil {
		return m.ComputedHash
	}
	return ""
}

func (m *CPUVerificationResult) GetExpectedHash() string {
	if m != nil {
		return m.ExpectedHash
	}
	return ""
}

func (m *CPUVerificationResult) GetVerificationTime() time.Time {
	if m != nil {
		return m.VerificationTime
	}
	return time.Time{}
}

// ParticipantSyncState represents a participant's synchronization state
type ParticipantSyncState struct {
	// participant_address is the address of the participant (miner or node)
	ParticipantAddress string `protobuf:"bytes,1,opt,name=participant_address,json=participantAddress,proto3" json:"participant_address,omitempty"`
	// current_model_version is the model version the participant is currently using
	CurrentModelVersion string `protobuf:"bytes,2,opt,name=current_model_version,json=currentModelVersion,proto3" json:"current_model_version,omitempty"`
	// last_sync_height is the block height when the participant last synced
	LastSyncHeight int64 `protobuf:"varint,3,opt,name=last_sync_height,json=lastSyncHeight,proto3" json:"last_sync_height,omitempty"`
	// last_sync_time is the timestamp when the participant last synced
	LastSyncTime time.Time `protobuf:"bytes,4,opt,name=last_sync_time,json=lastSyncTime,proto3,stdtime" json:"last_sync_time"`
	// is_synced indicates if the participant is synced with the latest model version
	IsSynced bool `protobuf:"varint,5,opt,name=is_synced,json=isSynced,proto3" json:"is_synced,omitempty"`
	// sync_lag_blocks is the number of blocks behind the participant is
	SyncLagBlocks int64 `protobuf:"varint,6,opt,name=sync_lag_blocks,json=syncLagBlocks,proto3" json:"sync_lag_blocks,omitempty"`
	// participant_type is the type of participant (miner, validator, serving_node)
	ParticipantType string `protobuf:"bytes,7,opt,name=participant_type,json=participantType,proto3" json:"participant_type,omitempty"`
	// is_partitioned indicates if the participant is currently partitioned
	IsPartitioned bool `protobuf:"varint,8,opt,name=is_partitioned,json=isPartitioned,proto3" json:"is_partitioned,omitempty"`
	// partition_detected_at is the block height when partition was detected
	PartitionDetectedAt int64 `protobuf:"varint,9,opt,name=partition_detected_at,json=partitionDetectedAt,proto3" json:"partition_detected_at,omitempty"`
	// partition_detected_time is the timestamp when partition was detected
	PartitionDetectedTime time.Time `protobuf:"bytes,10,opt,name=partition_detected_time,json=partitionDetectedTime,proto3,stdtime" json:"partition_detected_time"`
	// partition_recovered_at is the block height when partition was recovered
	PartitionRecoveredAt int64 `protobuf:"varint,11,opt,name=partition_recovered_at,json=partitionRecoveredAt,proto3" json:"partition_recovered_at,omitempty"`
	// partition_recovered_time is the timestamp when partition was recovered
	PartitionRecoveredTime time.Time `protobuf:"bytes,12,opt,name=partition_recovered_time,json=partitionRecoveredTime,proto3,stdtime" json:"partition_recovered_time"`
}

func (m *ParticipantSyncState) Reset()         { *m = ParticipantSyncState{} }
func (m *ParticipantSyncState) String() string { return proto.CompactTextString(m) }
func (*ParticipantSyncState) ProtoMessage()    {}
func (*ParticipantSyncState) Descriptor() ([]byte, []int) {
	return fileDescriptor_939c40a03eb9dc57, []int{6}
}
func (m *ParticipantSyncState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParticipantSyncState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParticipantSyncState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParticipantSyncState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParticipantSyncState.Merge(m, src)
}
func (m *ParticipantSyncState) XXX_Size() int {
	return m.Size()
}
func (m *ParticipantSyncState) XXX_DiscardUnknown() {
	xxx_messageInfo_ParticipantSyncState.DiscardUnknown(m)
}

var xxx_messageInfo_ParticipantSyncState proto.InternalMessageInfo

func (m *ParticipantSyncState) GetParticipantAddress() string {
	if m != nil {
		return m.ParticipantAddress
	}
	return ""
}

func (m *ParticipantSyncState) GetCurrentModelVersion() string {
	if m != nil {
		return m.CurrentModelVersion
	}
	return ""
}

func (m *ParticipantSyncState) GetLastSyncHeight() int64 {
	if m != nil {
		return m.LastSyncHeight
	}
	return 0
}

func (m *ParticipantSyncState) GetLastSyncTime() time.Time {
	if m != nil {
		return m.LastSyncTime
	}
	return time.Time{}
}

func (m *ParticipantSyncState) GetIsSynced() bool {
	if m != nil {
		return m.IsSynced
	}
	return false
}

func (m *ParticipantSyncState) GetSyncLagBlocks() int64 {
	if m != nil {
		return m.SyncLagBlocks
	}
	return 0
}

func (m *ParticipantSyncState) GetParticipantType() string {
	if m != nil {
		return m.ParticipantType
	}
	return ""
}

func (m *ParticipantSyncState) GetIsPartitioned() bool {
	if m != nil {
		return m.IsPartitioned
	}
	return false
}

func (m *ParticipantSyncState) GetPartitionDetectedAt() int64 {
	if m != nil {
		return m.PartitionDetectedAt
	}
	return 0
}

func (m *ParticipantSyncState) GetPartitionDetectedTime() time.Time {
	if m != nil {
		return m.PartitionDetectedTime
	}
	return time.Time{}
}

func (m *ParticipantSyncState) GetPartitionRecoveredAt() int64 {
	if m != nil {
		return m.PartitionRecoveredAt
	}
	return 0
}

func (m *ParticipantSyncState) GetPartitionRecoveredTime() time.Time {
	if m != nil {
		return m.PartitionRecoveredTime
	}
	return time.Time{}
}

// PartitionRecoveryInfo contains information for partition recovery
type PartitionRecoveryInfo struct {
	// participant_address is the address of the participant
	ParticipantAddress string `protobuf:"bytes,1,opt,name=participant_address,json=participantAddress,proto3" json:"participant_address,omitempty"`
	// was_partitioned indicates if the participant was partitioned
	WasPartitioned bool `protobuf:"varint,2,opt,name=was_partitioned,json=wasPartitioned,proto3" json:"was_partitioned,omitempty"`
	// partition_duration is the duration of the partition in blocks
	PartitionDuration int64 `protobuf:"varint,3,opt,name=partition_duration,json=partitionDuration,proto3" json:"partition_duration,omitempty"`
	// recovery_type is the type of recovery (incremental, full_catchup)
	RecoveryType string `protobuf:"bytes,4,opt,name=recovery_type,json=recoveryType,proto3" json:"recovery_type,omitempty"`
	// requires_full_sync indicates if full sync is required
	RequiresFullSync bool `protobuf:"varint,5,opt,name=requires_full_sync,json=requiresFullSync,proto3" json:"requires_full_sync,omitempty"`
	// sync_lag_blocks is the number of blocks behind
	SyncLagBlocks int64 `protobuf:"varint,6,opt,name=sync_lag_blocks,json=syncLagBlocks,proto3" json:"sync_lag_blocks,omitempty"`
	// global_state is the current global model state (if incremental recovery)
	GlobalState GlobalModelState `protobuf:"bytes,7,opt,name=global_state,json=globalState,proto3" json:"global_state"`
	// catch_up_gradients are the gradients needed for catch-up (if incremental recovery)
	CatchUpGradients []StoredGradient `protobuf:"bytes,8,rep,name=catch_up_gradients,json=catchUpGradients,proto3" json:"catch_up_gradients"`
}

func (m *PartitionRecoveryInfo) Reset()         { *m = PartitionRecoveryInfo{} }
func (m *PartitionRecoveryInfo) String() string { return proto.CompactTextString(m) }
func (*PartitionRecoveryInfo) ProtoMessage()    {}
func (*PartitionRecoveryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_939c40a03eb9dc57, []int{7}
}
func (m *PartitionRecoveryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionRecoveryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionRecoveryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionRecoveryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionRecoveryInfo.Merge(m, src)
}
func (m *PartitionRecoveryInfo) XXX_Size() int {
	return m.Size()
}
func (m *PartitionRecoveryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionRecoveryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionRecoveryInfo proto.InternalMessageInfo

func (m *PartitionRecoveryInfo) GetParticipantAddress() string {
	if m != nil {
		return m.ParticipantAddress
	}
	return ""
}

func (m *PartitionRecoveryInfo) GetWasPartitioned() bool {
	if m != nil {
		return m.WasPartitioned
	}
	return false
}

func (m *PartitionRecoveryInfo) GetPartitionDuration() int64 {
	if m != nil {
		return m.PartitionDuration
	}
	return 0
}

func (m *PartitionRecoveryInfo) GetRecoveryType() string {
	if m != nil {
		return m.RecoveryType
	}
	return ""
}

func (m *PartitionRecoveryInfo) GetRequiresFullSync() bool {
	if m != nil {
		return m.RequiresFullSync
	}
	return false
}

func (m *PartitionRecoveryInfo) GetSyncLagBlocks() int64 {
	if m != nil {
		return m.SyncLagBlocks
	}
	return 0
}

func (m *PartitionRecoveryInfo) GetGlobalState() GlobalModelState {
	if m != nil {
		return m.GlobalState
	}
	return GlobalModelState{}
}

func (m *PartitionRecoveryInfo) GetCatchUpGradients() []StoredGradient {
	if m != nil {
		return m.CatchUpGradients
	}
	return nil
}

// ProofOfReplication represents a cryptographic proof that a miner stores actual data
type ProofOfReplication struct {
	// data_hash is the hash of the original gradient data
	DataHash string `protobuf:"bytes,1,opt,name=data_hash,json=dataHash,proto3" json:"data_hash,omitempty"`
	// replica_hash is the hash of the stored replica (miner-specific encoding)
	ReplicaHash string `protobuf:"bytes,2,opt,name=replica_hash,json=replicaHash,proto3" json:"replica_hash,omitempty"`
	// merkle_proof is the Merkle proof of inclusion (serialized)
	MerkleProof []byte `protobuf:"bytes,3,opt,name=merkle_proof,json=merkleProof,proto3" json:"merkle_proof,omitempty"`
	// storage_proof is the proof that data is stored (serialized)
	StorageProof []byte `protobuf:"bytes,4,opt,name=storage_proof,json=storageProof,proto3" json:"storage_proof,omitempty"`
	// replication_id is the unique replication identifier
	ReplicationId string `protobuf:"bytes,5,opt,name=replication_id,json=replicationId,proto3" json:"replication_id,omitempty"`
	// miner_address is the address of the miner storing the replica
	MinerAddress string `protobuf:"bytes,6,opt,name=miner_address,json=minerAddress,proto3" json:"miner_address,omitempty"`
	// timestamp is when replication occurred (Unix timestamp)
	Timestamp int64 `protobuf:"varint,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *ProofOfReplication) Reset()         { *m = ProofOfReplication{} }
func (m *ProofOfReplication) String() string { return proto.CompactTextString(m) }
func (*ProofOfReplication) ProtoMessage()    {}
func (*ProofOfReplication) Descriptor() ([]byte, []int) {
	return fileDescriptor_939c40a03eb9dc57, []int{8}
}
func (m *ProofOfReplication) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProofOfReplication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProofOfReplication.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProofOfReplication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProofOfReplication.Merge(m, src)
}
func (m *ProofOfReplication) XXX_Size() int {
	return m.Size()
}
func (m *ProofOfReplication) XXX_DiscardUnknown() {
	xxx_messageInfo_ProofOfReplication.DiscardUnknown(m)
}

var xxx_messageInfo_ProofOfReplication proto.InternalMessageInfo

func (m *ProofOfReplication) GetDataHash() string {
	if m != nil {
		return m.DataHash
	}
	return ""
}

func (m *ProofOfReplication) GetReplicaHash() string {
	if m != nil {
		return m.ReplicaHash
	}
	return ""
}

func (m *ProofOfReplication) GetMerkleProof() []byte {
	if m != nil {
		return m.MerkleProof
	}
	return nil
}

func (m *ProofOfReplication) GetStorageProof() []byte {
	if m != nil {
		return m.StorageProof
	}
	return nil
}

func (m *ProofOfReplication) GetReplicationId() string {
	if m != nil {
		return m.ReplicationId
	}
	return ""
}

func (m *ProofOfReplication) GetMinerAddress() string {
	if m != nil {
		return m.MinerAddress
	}
	return ""
}

func (m *ProofOfReplication) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// PartitionStatus represents the partition status of a participant
type PartitionStatus struct {
	// is_partitioned indicates if the participant is currently partitioned
	IsPartitioned bool `protobuf:"varint,1,opt,name=is_partitioned,json=isPartitioned,proto3" json:"is_partitioned,omitempty"`
	// sync_lag_blocks is the number of blocks behind
	SyncLagBlocks int64 `protobuf:"varint,2,opt,name=sync_lag_blocks,json=syncLagBlocks,proto3" json:"sync_lag_blocks,omitempty"`
	// time_since_last_sync is the time since last sync
	TimeSinceLastSync string `protobuf:"bytes,3,opt,name=time_since_last_sync,json=timeSinceLastSync,proto3" json:"time_since_last_sync,omitempty"`
	// last_sync_height is the block height of last sync
	LastSyncHeight int64 `protobuf:"varint,4,opt,name=last_sync_height,json=lastSyncHeight,proto3" json:"last_sync_height,omitempty"`
	// last_sync_time is the timestamp of last sync
	LastSyncTime time.Time `protobuf:"bytes,5,opt,name=last_sync_time,json=lastSyncTime,proto3,stdtime" json:"last_sync_time"`
	// partition_detected_at is the block height when partition was detected
	PartitionDetectedAt int64 `protobuf:"varint,6,opt,name=partition_detected_at,json=partitionDetectedAt,proto3" json:"partition_detected_at,omitempty"`
	// partition_recovered_at is the block height when partition was recovered
	PartitionRecoveredAt int64 `protobuf:"varint,7,opt,name=partition_recovered_at,json=partitionRecoveredAt,proto3" json:"partition_recovered_at,omitempty"`
	// partition_duration is the duration of the partition in blocks
	PartitionDuration int64 `protobuf:"varint,8,opt,name=partition_duration,json=partitionDuration,proto3" json:"partition_duration,omitempty"`
}

func (m *PartitionStatus) Reset()         { *m = PartitionStatus{} }
func (m *PartitionStatus) String() string { return proto.CompactTextString(m) }
func (*PartitionStatus) ProtoMessage()    {}
func (*PartitionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_939c40a03eb9dc57, []int{9}
}
func (m *PartitionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionStatus.Merge(m, src)
}
func (m *PartitionStatus) XXX_Size() int {
	return m.Size()
}
func (m *PartitionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionStatus proto.InternalMessageInfo

func (m *PartitionStatus) GetIsPartitioned() bool {
	if m != nil {
		return m.IsPartitioned
	}
	return false
}

func (m *PartitionStatus) GetSyncLagBlocks() int64 {
	if m != nil {
		return m.SyncLagBlocks
	}
	return 0
}

func (m *PartitionStatus) GetTimeSinceLastSync() string {
	if m != nil {
		return m.TimeSinceLastSync
	}
	return ""
}

func (m *PartitionStatus) GetLastSyncHeight() int64 {
	if m != nil {
		return m.LastSyncHeight
	}
	return 0
}

func (m *PartitionStatus) GetLastSyncTime() time.Time {
	if m != nil {
		return m.LastSyncTime
	}
	return time.Time{}
}

func (m *PartitionStatus) GetPartitionDetectedAt() int64 {
	if m != nil {
		return m.PartitionDetectedAt
	}
	return 0
}

func (m *PartitionStatus) GetPartitionRecoveredAt() int64 {
	if m != nil {
		return m.PartitionRecoveredAt
	}
	return 0
}

func (m *PartitionStatus) GetPartitionDuration() int64 {
	if m != nil {
		return m.PartitionDuration
	}
	return 0
}

// ConvergenceMetrics tracks model convergence metrics
type ConvergenceMetrics struct {
	// training_round_id is the training round identifier
	TrainingRoundId uint64 `protobuf:"varint,1,opt,name=training_round_id,json=trainingRoundId,proto3" json:"training_round_id,omitempty"`
	// average_loss is the average loss value (BitNet integer format)
	AverageLoss string `protobuf:"bytes,2,opt,name=average_loss,json=averageLoss,proto3" json:"average_loss,omitempty"`
	// loss_history is the last N loss values for trend analysis (BitNet integer format)
	LossHistory []string `protobuf:"bytes,3,rep,name=loss_history,json=lossHistory,proto3" json:"loss_history,omitempty"`
	// convergence_rate is the rate of loss reduction (decimal string)
	ConvergenceRate string `protobuf:"bytes,4,opt,name=convergence_rate,json=convergenceRate,proto3" json:"convergence_rate,omitempty"`
	// is_converged indicates if the model has converged
	IsConverged bool `protobuf:"varint,5,opt,name=is_converged,json=isConverged,proto3" json:"is_converged,omitempty"`
	// convergence_threshold is the loss change threshold for convergence (decimal string)
	ConvergenceThreshold string `protobuf:"bytes,6,opt,name=convergence_threshold,json=convergenceThreshold,proto3" json:"convergence_threshold,omitempty"`
	// last_updated_height is the block height when metrics were last updated
	LastUpdatedHeight int64 `protobuf:"varint,7,opt,name=last_updated_height,json=lastUpdatedHeight,proto3" json:"last_updated_height,omitempty"`
}

func (m *ConvergenceMetrics) Reset()         { *m = ConvergenceMetrics{} }
func (m *ConvergenceMetrics) String() string { return proto.CompactTextString(m) }
func (*ConvergenceMetrics) ProtoMessage()    {}
func (*ConvergenceMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_939c40a03eb9dc57, []int{10}
}
func (m *ConvergenceMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvergenceMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvergenceMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvergenceMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvergenceMetrics.Merge(m, src)
}
func (m *ConvergenceMetrics) XXX_Size() int {
	return m.Size()
}
func (m *ConvergenceMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvergenceMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_ConvergenceMetrics proto.InternalMessageInfo

func (m *ConvergenceMetrics) GetTrainingRoundId() uint64 {
	if m != nil {
		return m.TrainingRoundId
	}
	return 0
}

func (m *ConvergenceMetrics) GetAverageLoss() string {
	if m != nil {
		return m.AverageLoss
	}
	return ""
}

func (m *ConvergenceMetrics) GetLossHistory() []string {
	if m != nil {
		return m.LossHistory
	}
	return nil
}

func (m *ConvergenceMetrics) GetConvergenceRate() string {
	if m != nil {
		return m.ConvergenceRate
	}
	return ""
}

func (m *ConvergenceMetrics) GetIsConverged() bool {
	if m != nil {
		return m.IsConverged
	}
	return false
}

func (m *ConvergenceMetrics) GetConvergenceThreshold() string {
	if m != nil {
		return m.ConvergenceThreshold
	}
	return ""
}

func (m *ConvergenceMetrics) GetLastUpdatedHeight() int64 {
	if m != nil {
		return m.LastUpdatedHeight
	}
	return 0
}

// PinInfo represents information about a pinned IPFS content
type PinInfo struct {
	// pinner is the address of the node that pinned the content
	Pinner string `protobuf:"bytes,1,opt,name=pinner,proto3" json:"pinner,omitempty"`
	// cid is the IPFS content identifier
	Cid string `protobuf:"bytes,2,opt,name=cid,proto3" json:"cid,omitempty"`
	// size_bytes is the size of the pinned content in bytes
	SizeBytes uint64 `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// pinned_at is the Unix timestamp when the content was pinned
	PinnedAt int64 `protobuf:"varint,4,opt,name=pinned_at,json=pinnedAt,proto3" json:"pinned_at,omitempty"`
	// unpinned_at is the Unix timestamp when the content was unpinned (0 if still pinned)
	UnpinnedAt int64 `protobuf:"varint,5,opt,name=unpinned_at,json=unpinnedAt,proto3" json:"unpinned_at,omitempty"`
}

func (m *PinInfo) Reset()         { *m = PinInfo{} }
func (m *PinInfo) String() string { return proto.CompactTextString(m) }
func (*PinInfo) ProtoMessage()    {}
func (*PinInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_939c40a03eb9dc57, []int{11}
}
func (m *PinInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PinInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PinInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PinInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PinInfo.Merge(m, src)
}
func (m *PinInfo) XXX_Size() int {
	return m.Size()
}
func (m *PinInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PinInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PinInfo proto.InternalMessageInfo

func (m *PinInfo) GetPinner() string {
	if m != nil {
		return m.Pinner
	}
	return ""
}

func (m *PinInfo) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *PinInfo) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *PinInfo) GetPinnedAt() int64 {
	if m != nil {
		return m.PinnedAt
	}
	return 0
}

func (m *PinInfo) GetUnpinnedAt() int64 {
	if m != nil {
		return m.UnpinnedAt
	}
	return 0
}

// AggregationIDList stores a list of aggregation IDs for the deadline index
type AggregationIDList struct {
	AggregationIds []uint64 `protobuf:"varint,1,rep,packed,name=aggregation_ids,json=aggregationIds,proto3" json:"aggregation_ids,omitempty"`
}

func (m *AggregationIDList) Reset()         { *m = AggregationIDList{} }
func (m *AggregationIDList) String() string { return proto.CompactTextString(m) }
func (*AggregationIDList) ProtoMessage()    {}
func (*AggregationIDList) Descriptor() ([]byte, []int) {
	return fileDescriptor_939c40a03eb9dc57, []int{12}
}
func (m *AggregationIDList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregationIDList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggregationIDList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggregationIDList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregationIDList.Merge(m, src)
}
func (m *AggregationIDList) XXX_Size() int {
	return m.Size()
}
func (m *AggregationIDList) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregationIDList.DiscardUnknown(m)
}

var xxx_messageInfo_AggregationIDList proto.InternalMessageInfo

func (m *AggregationIDList) GetAggregationIds() []uint64 {
	if m != nil {
		return m.AggregationIds
	}
	return nil
}

func init() {
	proto.RegisterType((*GlobalModelState)(nil), "remes.remes.v1.GlobalModelState")
	proto.RegisterType((*AggregationRecord)(nil), "remes.remes.v1.AggregationRecord")
	proto.RegisterType((*AggregationCommitment)(nil), "remes.remes.v1.AggregationCommitment")
	proto.RegisterType((*MiningContribution)(nil), "remes.remes.v1.MiningContribution")
	proto.RegisterType((*ChallengeRecord)(nil), "remes.remes.v1.ChallengeRecord")
	proto.RegisterType((*CPUVerificationResult)(nil), "remes.remes.v1.CPUVerificationResult")
	proto.RegisterType((*ParticipantSyncState)(nil), "remes.remes.v1.ParticipantSyncState")
	proto.RegisterType((*PartitionRecoveryInfo)(nil), "remes.remes.v1.PartitionRecoveryInfo")
	proto.RegisterType((*ProofOfReplication)(nil), "remes.remes.v1.ProofOfReplication")
	proto.RegisterType((*PartitionStatus)(nil), "remes.remes.v1.PartitionStatus")
	proto.RegisterType((*ConvergenceMetrics)(nil), "remes.remes.v1.ConvergenceMetrics")
	proto.RegisterType((*PinInfo)(nil), "remes.remes.v1.PinInfo")
	proto.RegisterType((*AggregationIDList)(nil), "remes.remes.v1.AggregationIDList")
}

func init() { proto.RegisterFile("remes/remes/v1/state.proto", fileDescriptor_939c40a03eb9dc57) }

var fileDescriptor_939c40a03eb9dc57 = []byte{
	// 2126 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x5b, 0x73, 0x1b, 0xb7,
	0x15, 0x36, 0x45, 0x89, 0x22, 0x41, 0x8a, 0xa4, 0x56, 0x17, 0x6f, 0xd4, 0x5a, 0x17, 0xa6, 0x8e,
	0x19, 0xc7, 0x91, 0x26, 0x4e, 0xda, 0xe9, 0xe8, 0x4d, 0x92, 0x9b, 0x58, 0x1d, 0x7b, 0xaa, 0xae,
	0x6c, 0x77, 0xa6, 0xd3, 0xe9, 0x0e, 0xb4, 0x0b, 0x92, 0x98, 0x2c, 0x17, 0x5b, 0x00, 0x2b, 0x87,
	0xfd, 0x09, 0x7d, 0xca, 0x4f, 0xe8, 0x73, 0x9f, 0xd2, 0x7f, 0xe1, 0x99, 0xbe, 0xe4, 0x31, 0x2f,
	0xbd, 0x8c, 0xdd, 0x69, 0xf3, 0xd6, 0x87, 0xfe, 0x81, 0x0e, 0x0e, 0x80, 0xbd, 0xf0, 0xd2, 0x58,
	0x79, 0xe1, 0x70, 0xbf, 0x73, 0x80, 0x05, 0xce, 0x77, 0xce, 0x87, 0x83, 0x45, 0x3b, 0x9c, 0x8c,
	0x89, 0x38, 0xd2, 0xbf, 0xd7, 0x1f, 0x1d, 0x09, 0x89, 0x25, 0x39, 0x4c, 0x38, 0x93, 0xcc, 0x69,
	0x03, 0x7a, 0xa8, 0x7f, 0xaf, 0x3f, 0xda, 0x59, 0xc7, 0x63, 0x1a, 0xb3, 0x23, 0xf8, 0xd5, 0x2e,
	0x3b, 0x9b, 0x43, 0x36, 0x64, 0xf0, 0xf7, 0x48, 0xfd, 0x33, 0xe8, 0xde, 0x90, 0xb1, 0x61, 0x44,
	0x8e, 0xe0, 0xe9, 0x2a, 0x1d, 0x1c, 0x49, 0x3a, 0x26, 0x42, 0xe2, 0x71, 0x62, 0x1c, 0x7e, 0x34,
	0xf3, 0x56, 0xc6, 0x49, 0xe8, 0x0f, 0x39, 0x0e, 0x29, 0x89, 0xa5, 0xf6, 0xea, 0xfd, 0x6b, 0x09,
	0x75, 0x3f, 0x8b, 0xd8, 0x15, 0x8e, 0x9e, 0xb2, 0x90, 0x44, 0x97, 0x6a, 0x69, 0xce, 0x7b, 0xa8,
	0x33, 0x56, 0x4f, 0x3e, 0x4d, 0x06, 0xc2, 0x1f, 0x61, 0x31, 0x72, 0x2b, 0xfb, 0x95, 0x7e, 0xc3,
	0x5b, 0x03, 0xf8, 0x3c, 0x19, 0x88, 0xc7, 0x58, 0x8c, 0x9c, 0x77, 0x91, 0x06, 0xfc, 0x6b, 0xc2,
	0x05, 0x65, 0xb1, 0xbb, 0x04, 0x5e, 0x2d, 0x00, 0x5f, 0x68, 0xcc, 0x39, 0x44, 0x1b, 0x11, 0x16,
	0xd2, 0x4f, 0x93, 0x10, 0x4b, 0x12, 0xfa, 0x23, 0x42, 0x87, 0x23, 0xe9, 0x56, 0xf7, 0x2b, 0xfd,
	0xaa, 0xb7, 0xae, 0x4c, 0xcf, 0xb5, 0xe5, 0x31, 0x18, 0x9c, 0x0b, 0xb4, 0x5e, 0xf2, 0x57, 0xfb,
	0x72, 0x97, 0xf7, 0x2b, 0xfd, 0xe6, 0xc3, 0x9d, 0x43, 0xbd, 0xe9, 0x43, 0xbb, 0xe9, 0xc3, 0x67,
	0x76, 0xd3, 0xa7, 0xf5, 0x57, 0x7f, 0xdb, 0xbb, 0xf5, 0xe5, 0xdf, 0xf7, 0x2a, 0x5e, 0xa7, 0x30,
	0xa7, 0xb2, 0x3b, 0xf7, 0xd1, 0xba, 0xe4, 0x98, 0xc6, 0x34, 0x1e, 0xfa, 0x9c, 0xa5, 0x71, 0xe8,
	0xd3, 0xd0, 0x5d, 0xd9, 0xaf, 0xf4, 0x97, 0xbd, 0x8e, 0x35, 0x78, 0x0a, 0x3f, 0x0f, 0xb3, 0xd5,
	0xe2, 0xe1, 0x90, 0x93, 0x21, 0x96, 0x94, 0xc5, 0xca, 0xbb, 0x06, 0xde, 0xb0, 0xb0, 0x93, 0xdc,
	0x72, 0x1e, 0x1e, 0xdf, 0xfb, 0xf6, 0x8f, 0x7b, 0x95, 0x3f, 0xfc, 0xfb, 0xab, 0xfb, 0xbb, 0x3a,
	0xd0, 0x5f, 0x98, 0x80, 0x4f, 0xc7, 0xb4, 0xf7, 0xdf, 0x2a, 0x5a, 0x2f, 0x0c, 0xf5, 0x48, 0xc0,
	0x78, 0xe8, 0xdc, 0x45, 0xed, 0xa9, 0x37, 0x55, 0xe0, 0x4d, 0x6b, 0xb8, 0xf8, 0x16, 0x67, 0x07,
	0xd5, 0x13, 0xce, 0x12, 0x26, 0x08, 0x37, 0x31, 0xce, 0x9e, 0x9d, 0x13, 0x74, 0xc7, 0x3a, 0x17,
	0xe8, 0x2d, 0x50, 0x57, 0x85, 0x01, 0x3b, 0xb9, 0xd3, 0x67, 0xc6, 0x27, 0xe3, 0x71, 0x0f, 0x35,
	0xc7, 0x84, 0x7f, 0x1e, 0x11, 0x9f, 0x33, 0x26, 0x21, 0xd8, 0x0d, 0x0f, 0x69, 0xc8, 0x63, 0x4c,
	0x3a, 0x3f, 0x45, 0x6e, 0x82, 0xb9, 0xa4, 0x01, 0x4d, 0x70, 0x2c, 0x0b, 0x2f, 0x09, 0x85, 0xbb,
	0xb2, 0x5f, 0xed, 0x2f, 0x7b, 0xdb, 0x05, 0x7b, 0x36, 0x7f, 0x28, 0xe6, 0xc7, 0xbe, 0x36, 0x3f,
	0xf6, 0x33, 0xe9, 0xb4, 0x3a, 0x3f, 0x9d, 0x44, 0x7a, 0x35, 0xa6, 0x52, 0xed, 0x16, 0x4b, 0x9b,
	0x4e, 0x75, 0x9d, 0x4e, 0x99, 0xe9, 0x44, 0x9a, 0x74, 0xda, 0x46, 0x35, 0x55, 0x6f, 0xa9, 0x70,
	0x1b, 0x30, 0x9b, 0x79, 0x72, 0x8e, 0xd1, 0x3b, 0xc1, 0x08, 0x47, 0x11, 0x89, 0x87, 0xc4, 0x0f,
	0x09, 0x0e, 0x23, 0x1a, 0x13, 0x3b, 0x1b, 0x82, 0xd9, 0x6e, 0x67, 0x0e, 0x8f, 0x8c, 0x5d, 0xcf,
	0x79, 0xdc, 0xb7, 0xa4, 0xef, 0x95, 0x49, 0x9f, 0xe1, 0xb7, 0xf7, 0x97, 0x2a, 0xda, 0x2a, 0xa0,
	0x67, 0x6c, 0x3c, 0xa6, 0x72, 0x4c, 0x62, 0xa9, 0x36, 0x1b, 0x64, 0x4f, 0x39, 0xf1, 0xad, 0x1c,
	0xfc, 0x0e, 0xde, 0xef, 0xa1, 0x4e, 0x61, 0x82, 0x02, 0xd3, 0xed, 0x1c, 0x06, 0x76, 0xe7, 0x52,
	0xb0, 0x3c, 0x9f, 0x82, 0xef, 0x4f, 0xf4, 0x21, 0xda, 0xd0, 0xef, 0x2d, 0xf3, 0x52, 0xd3, 0xbc,
	0x64, 0xa6, 0x8c, 0x97, 0x4f, 0xd0, 0x36, 0x27, 0xd7, 0x04, 0x47, 0x33, 0xc1, 0x5f, 0x85, 0x21,
	0x9b, 0xda, 0x5a, 0x8e, 0x7c, 0x81, 0xcd, 0x7a, 0x89, 0xcd, 0x9f, 0xa0, 0xdb, 0xda, 0x5f, 0xbd,
	0xbc, 0x5c, 0x50, 0x0d, 0xd8, 0xe9, 0x96, 0x35, 0x97, 0xcb, 0xf7, 0x81, 0x65, 0xf2, 0xdd, 0x85,
	0x4c, 0xe6, 0x9c, 0xf5, 0xbe, 0xa9, 0x22, 0xe7, 0x29, 0xc4, 0xeb, 0x8c, 0xc5, 0x92, 0xd3, 0xab,
	0x54, 0x39, 0x40, 0xde, 0xd2, 0x98, 0x70, 0x1f, 0x87, 0x21, 0x27, 0x42, 0x18, 0xb1, 0x6c, 0x01,
	0x78, 0xa2, 0x31, 0xe7, 0x03, 0xb4, 0x2e, 0x99, 0xc4, 0x91, 0x0f, 0x29, 0x2a, 0x54, 0x2e, 0x0b,
	0xe0, 0x74, 0xd9, 0xeb, 0x82, 0xe1, 0x32, 0xc7, 0x9d, 0x1f, 0xa3, 0x6d, 0x91, 0x06, 0x01, 0x11,
	0x62, 0x90, 0x96, 0x47, 0x54, 0xf5, 0x6e, 0x72, 0x6b, 0x71, 0xd8, 0x1e, 0x6a, 0x4a, 0x9e, 0x0a,
	0xe9, 0x8b, 0x80, 0x71, 0x62, 0xeb, 0x18, 0xa0, 0x4b, 0x85, 0xa8, 0x9c, 0xe1, 0x24, 0x49, 0xa5,
	0x0e, 0x8e, 0xa4, 0x84, 0x83, 0x0e, 0x36, 0xbc, 0x76, 0x0e, 0x3f, 0xa3, 0x3a, 0xb9, 0x44, 0x84,
	0xc5, 0x48, 0xe5, 0x0c, 0xb9, 0x26, 0xb1, 0x14, 0xa6, 0x68, 0xdb, 0x16, 0xfe, 0x19, 0xa0, 0x8a,
	0x46, 0xd0, 0xcb, 0x7c, 0x8d, 0x53, 0x34, 0x2a, 0x6b, 0xbe, 0x46, 0x43, 0xe3, 0x01, 0x6a, 0x49,
	0x8e, 0x13, 0xe1, 0x07, 0x38, 0xb5, 0xd5, 0xbb, 0xec, 0x35, 0x01, 0x3b, 0x03, 0x28, 0x77, 0x19,
	0x60, 0x1a, 0x11, 0x4b, 0xa3, 0x76, 0xf9, 0x14, 0x20, 0xb5, 0xdd, 0x01, 0xc7, 0x69, 0x68, 0xb6,
	0x8b, 0xf4, 0x76, 0x01, 0x82, 0xed, 0x1e, 0xbf, 0x6f, 0xd9, 0xdd, 0x2f, 0xb3, 0x3b, 0xcb, 0x61,
	0xef, 0x3f, 0x35, 0xd4, 0x39, 0xb3, 0xe5, 0x6e, 0xc4, 0xf9, 0x00, 0xb5, 0x72, 0x89, 0xc8, 0x2a,
	0xb4, 0x99, 0x61, 0xe7, 0xa1, 0xb3, 0x8b, 0x50, 0xf6, 0x68, 0x4b, 0xb4, 0x80, 0xcc, 0xd1, 0xf7,
	0xea, 0x3c, 0x7d, 0xdf, 0x46, 0x35, 0x4e, 0xb0, 0x60, 0xb1, 0xe1, 0xcc, 0x3c, 0x39, 0x0f, 0x90,
	0x43, 0xae, 0x69, 0x48, 0xe2, 0x80, 0x14, 0x04, 0x5d, 0x53, 0xd6, 0xb5, 0x96, 0x4c, 0xc6, 0xf3,
	0xe2, 0xa8, 0x95, 0x8a, 0xe3, 0x3e, 0x5a, 0x0f, 0x38, 0xc1, 0xe5, 0xc2, 0xd4, 0xf4, 0x74, 0x8c,
	0xa1, 0x58, 0x96, 0x41, 0x92, 0x2a, 0x05, 0xa6, 0x03, 0x1a, 0xe8, 0x55, 0x27, 0x38, 0x26, 0x91,
	0x5b, 0xdf, 0xaf, 0xf6, 0x1b, 0xde, 0x66, 0x90, 0xa4, 0x2f, 0x0a, 0xc6, 0x0b, 0x65, 0x73, 0x7c,
	0xe4, 0xce, 0x8c, 0xe2, 0x44, 0xa4, 0x91, 0x54, 0xb2, 0x5b, 0xed, 0x37, 0x1f, 0xde, 0x3d, 0x2c,
	0x37, 0x3a, 0x87, 0x67, 0x17, 0xcf, 0x8b, 0xf3, 0x78, 0xe0, 0xed, 0x6d, 0x4f, 0x4d, 0xaf, 0x61,
	0xa8, 0x1e, 0x4e, 0x04, 0x8b, 0x80, 0xac, 0xb2, 0x4a, 0x77, 0x73, 0x83, 0xd9, 0xc3, 0x5d, 0xd4,
	0xd6, 0x79, 0x11, 0x12, 0x49, 0x02, 0x49, 0x42, 0xb7, 0xb9, 0x5f, 0xe9, 0xd7, 0xbd, 0x35, 0x40,
	0x1f, 0x19, 0xd0, 0xd9, 0x44, 0x2b, 0x11, 0x9e, 0x10, 0xee, 0xb6, 0xf6, 0x2b, 0xfd, 0x35, 0x4f,
	0x3f, 0xa8, 0xa4, 0xba, 0x62, 0x71, 0xe8, 0xe3, 0x31, 0x4b, 0x63, 0xe9, 0xae, 0x69, 0x4a, 0x15,
	0x74, 0x02, 0x08, 0xd4, 0x10, 0x8e, 0x43, 0x36, 0x36, 0xdb, 0x25, 0xdc, 0x6d, 0x9b, 0x1a, 0x02,
	0xf8, 0x85, 0x41, 0x41, 0xe1, 0xca, 0x8e, 0x26, 0x26, 0x6e, 0x07, 0xfc, 0x37, 0xcb, 0xfe, 0x7a,
	0xab, 0x8a, 0x72, 0x2d, 0x26, 0x2f, 0x61, 0x33, 0x02, 0x78, 0x77, 0xbb, 0x9a, 0x72, 0xb0, 0xfc,
	0x4a, 0x1b, 0x14, 0xed, 0xaa, 0x53, 0x0b, 0xb1, 0xc4, 0xfe, 0x15, 0x96, 0xc1, 0xc8, 0x17, 0x84,
	0x84, 0xee, 0xba, 0x4e, 0x30, 0x05, 0x9f, 0x2a, 0xf4, 0x92, 0x10, 0x38, 0x5a, 0xb3, 0x45, 0x44,
	0x4c, 0x08, 0xd7, 0xd1, 0x12, 0x65, 0xc1, 0x27, 0x4c, 0x08, 0xe7, 0x0e, 0x42, 0xca, 0xe6, 0x8f,
	0xd5, 0x30, 0x77, 0x03, 0x62, 0xd6, 0x50, 0xc8, 0x53, 0x05, 0xa8, 0xb0, 0x82, 0x59, 0xb2, 0x88,
	0x70, 0x1c, 0x07, 0xc4, 0xdd, 0xd4, 0x4d, 0xa1, 0x42, 0x9f, 0x59, 0xf0, 0xf8, 0x3d, 0x5b, 0x74,
	0x77, 0xca, 0x45, 0x37, 0x55, 0x5d, 0xbd, 0x3f, 0x2d, 0xa1, 0xad, 0xb9, 0x49, 0xa0, 0xc8, 0xbe,
	0xc6, 0x11, 0x0d, 0xb1, 0x64, 0xd3, 0x9a, 0xda, 0xcd, 0x0c, 0x56, 0x57, 0xdf, 0x41, 0x75, 0x2a,
	0x7c, 0x80, 0xa1, 0xfe, 0xea, 0xde, 0x2a, 0x15, 0x2f, 0xd4, 0xa3, 0x39, 0x62, 0x93, 0x14, 0xba,
	0xce, 0xfc, 0x7c, 0x6c, 0x59, 0xd0, 0xf6, 0xb0, 0xe4, 0x8b, 0x04, 0x32, 0x42, 0x3b, 0xe9, 0x0a,
	0x6c, 0x59, 0x10, 0x9c, 0x7e, 0x89, 0xd6, 0x4b, 0xb9, 0x0d, 0x3d, 0xe9, 0xca, 0x0d, 0x7a, 0xd2,
	0x6e, 0x71, 0xb8, 0x72, 0x58, 0x78, 0xf2, 0xcc, 0x0d, 0x49, 0xef, 0xaf, 0x2b, 0x68, 0xf3, 0x22,
	0x3f, 0x78, 0x2f, 0x27, 0x71, 0xa0, 0x5b, 0xf5, 0x23, 0xb4, 0x51, 0x3c, 0xb0, 0xcb, 0xd1, 0x72,
	0x0a, 0x26, 0x1b, 0xaf, 0x87, 0x68, 0x2b, 0x48, 0x39, 0x57, 0x87, 0xfa, 0xbc, 0xde, 0x7d, 0xc3,
	0x18, 0x9f, 0x16, 0x7b, 0xae, 0x3e, 0xea, 0x6a, 0x91, 0x9f, 0xc4, 0x41, 0xb9, 0x7f, 0x6f, 0x83,
	0xbc, 0x4f, 0xe2, 0xc0, 0x94, 0xde, 0xcf, 0x51, 0x3b, 0xf7, 0xbc, 0x71, 0xe7, 0xde, 0xb2, 0xb3,
	0x41, 0xdb, 0xfe, 0x03, 0xd4, 0xa0, 0x02, 0x66, 0x22, 0xba, 0x5d, 0xaf, 0x7b, 0x75, 0x2a, 0x2e,
	0xe1, 0x59, 0x25, 0x3e, 0xbc, 0x23, 0xc2, 0x43, 0xff, 0x2a, 0x62, 0xc1, 0xe7, 0xc2, 0xb4, 0x1a,
	0x6b, 0x0a, 0x7e, 0x82, 0x87, 0xa7, 0x00, 0x3a, 0xef, 0xa3, 0x6e, 0x31, 0x3e, 0x72, 0x92, 0x10,
	0xd3, 0x56, 0x76, 0x0a, 0xf8, 0xb3, 0x49, 0x42, 0x54, 0x7e, 0x53, 0xe1, 0x03, 0xaa, 0x22, 0x4f,
	0x42, 0x38, 0x96, 0xea, 0xde, 0x1a, 0x15, 0x17, 0x39, 0xa8, 0x02, 0x98, 0xf9, 0x64, 0x0a, 0xe3,
	0x63, 0x09, 0x27, 0x54, 0xd5, 0xdb, 0xc8, 0x8c, 0x56, 0x68, 0x4e, 0xa4, 0xf3, 0x1b, 0x74, 0x7b,
	0xce, 0x18, 0x88, 0x0f, 0xba, 0x41, 0x7c, 0xb6, 0x66, 0xe6, 0x86, 0x40, 0x7d, 0x82, 0xb6, 0xf3,
	0xd9, 0x39, 0x09, 0xd8, 0x35, 0xe1, 0x7a, 0x49, 0x4d, 0x7d, 0x06, 0x67, 0x56, 0xcf, 0x1a, 0x4f,
	0xa4, 0xf3, 0x5b, 0xd3, 0xea, 0x4d, 0x8d, 0x82, 0x45, 0xb5, 0x6e, 0xb0, 0xa8, 0xed, 0xd9, 0xd9,
	0x21, 0xc1, 0x3f, 0xb0, 0x09, 0xde, 0x2b, 0x27, 0xf8, 0xbc, 0x34, 0xee, 0x7d, 0x5b, 0x45, 0x5b,
	0x17, 0x53, 0xf3, 0x4c, 0xce, 0xe3, 0x01, 0xbb, 0x79, 0x82, 0xdf, 0x43, 0x9d, 0x97, 0xb8, 0xcc,
	0xa3, 0xd6, 0x85, 0xf6, 0x4b, 0x5c, 0x22, 0xf2, 0x43, 0xe4, 0x14, 0x48, 0x49, 0x39, 0xd4, 0x9b,
	0xbd, 0x97, 0xe6, 0x91, 0x36, 0x06, 0x25, 0x14, 0x26, 0x4a, 0x13, 0x9d, 0x46, 0x46, 0x28, 0x2c,
	0x08, 0x39, 0xf4, 0x00, 0x39, 0x9c, 0xfc, 0x2e, 0xa5, 0x9c, 0x08, 0x7f, 0x90, 0x46, 0x11, 0xa4,
	0xaf, 0x49, 0xde, 0xae, 0xb5, 0x7c, 0x9a, 0x46, 0x91, 0xda, 0xfa, 0x5b, 0x27, 0xf1, 0x39, 0x6a,
	0x0d, 0xe1, 0x3e, 0xe9, 0xc3, 0xa7, 0x03, 0x48, 0xe0, 0xe6, 0xc3, 0xfd, 0xe9, 0x23, 0x75, 0xfa,
	0xce, 0x79, 0xba, 0xac, 0x48, 0xf2, 0x9a, 0x7a, 0xac, 0xd6, 0x0b, 0x0f, 0x39, 0x01, 0x9c, 0x15,
	0x69, 0x92, 0x75, 0xf7, 0x02, 0xce, 0xf6, 0xe6, 0xc3, 0xdd, 0xe9, 0x09, 0x2f, 0xe1, 0x93, 0x81,
	0xed, 0xf2, 0xcd, 0x74, 0x5d, 0x18, 0xff, 0x3c, 0xb1, 0xb0, 0x58, 0x28, 0x65, 0x73, 0x09, 0xed,
	0xfd, 0x79, 0x09, 0x39, 0x17, 0x9c, 0xb1, 0xc1, 0x2f, 0x06, 0x1e, 0x49, 0x22, 0xa3, 0x73, 0xaa,
	0xda, 0xe1, 0x24, 0x2b, 0x7c, 0x6d, 0xa8, 0x2b, 0x00, 0xf4, 0xf7, 0x00, 0xb5, 0xb8, 0xf6, 0xd5,
	0x76, 0xad, 0x55, 0x4d, 0x83, 0x59, 0x17, 0x73, 0x87, 0x4d, 0xd4, 0xe4, 0xc0, 0x63, 0xcb, 0x33,
	0xf7, 0x5a, 0x78, 0x9f, 0x62, 0x50, 0x48, 0xc6, 0xf1, 0xd0, 0xfa, 0x2c, 0x83, 0x4f, 0xcb, 0x80,
	0xda, 0xe9, 0x2e, 0x6a, 0xf3, 0x7c, 0x59, 0xf6, 0x4b, 0x41, 0xc3, 0x5b, 0x2b, 0xa0, 0xe6, 0xae,
	0x5a, 0xea, 0xf9, 0x6b, 0x73, 0x7a, 0xfe, 0x1f, 0xa2, 0x46, 0xf6, 0x55, 0xc6, 0x34, 0x5c, 0x39,
	0xb0, 0xb0, 0x3b, 0x9d, 0x0d, 0x4e, 0xef, 0x55, 0x15, 0x75, 0xb2, 0x68, 0x5e, 0xea, 0xae, 0x6e,
	0x56, 0xae, 0x2a, 0xf3, 0xe4, 0x6a, 0x4e, 0x8e, 0x2d, 0xcd, 0xcb, 0xb1, 0x23, 0xb4, 0xa9, 0x96,
	0xe6, 0x0b, 0xaa, 0x9a, 0xcd, 0x4c, 0xc4, 0xcd, 0x99, 0xb9, 0xae, 0x6c, 0x97, 0xca, 0xf4, 0xc4,
	0x48, 0xf4, 0xdc, 0x43, 0x61, 0xf9, 0x2d, 0x0f, 0x85, 0x95, 0xef, 0x7d, 0x28, 0x2c, 0x54, 0xdf,
	0xda, 0x62, 0xf5, 0x5d, 0xac, 0x8f, 0xab, 0xff, 0x47, 0x1f, 0xe7, 0xcb, 0x43, 0x7d, 0x81, 0x3c,
	0x2c, 0x6c, 0x7b, 0xa6, 0x68, 0xeb, 0xfd, 0x73, 0x09, 0x39, 0x67, 0x2c, 0xbe, 0x26, 0x7c, 0xa8,
	0x9a, 0xf7, 0xa7, 0x44, 0x72, 0x1a, 0x2c, 0xf8, 0x4e, 0x52, 0x99, 0x7f, 0x49, 0x3f, 0x40, 0x2d,
	0x7c, 0x4d, 0x20, 0x8f, 0xa1, 0x97, 0x33, 0xd5, 0x60, 0x30, 0x68, 0xe5, 0x0e, 0x50, 0x0b, 0x7a,
	0xb5, 0x11, 0x55, 0xc9, 0x3d, 0x71, 0xab, 0xd0, 0xbc, 0x37, 0x15, 0xf6, 0x58, 0x43, 0xea, 0x64,
	0x0c, 0xf2, 0x75, 0xf8, 0x5c, 0x09, 0x8b, 0x96, 0xb4, 0x4e, 0x01, 0xf7, 0x94, 0x68, 0x1c, 0xa0,
	0x16, 0x15, 0xbe, 0x45, 0xed, 0x61, 0xdc, 0xa4, 0xc2, 0x6e, 0x24, 0x74, 0x3e, 0x46, 0x5b, 0xc5,
	0xd9, 0xe4, 0x88, 0x13, 0x31, 0x62, 0x51, 0x68, 0xea, 0x62, 0xb3, 0x60, 0x7c, 0x66, 0x6d, 0x8b,
	0x3e, 0x0d, 0xae, 0x2e, 0xf8, 0x34, 0xb8, 0xb0, 0x62, 0x66, 0xe3, 0xd9, 0xfb, 0xaa, 0x82, 0x56,
	0x2f, 0x68, 0x0c, 0x47, 0xc8, 0x36, 0xaa, 0x25, 0x34, 0x8e, 0x09, 0x37, 0xba, 0x62, 0x9e, 0x9c,
	0x2e, 0xaa, 0x06, 0xa6, 0x6b, 0x6c, 0x78, 0xea, 0xaf, 0xea, 0x80, 0x05, 0xfd, 0x3d, 0xf1, 0xaf,
	0x26, 0x92, 0xd8, 0xbb, 0x76, 0x43, 0x21, 0xa7, 0x0a, 0x50, 0x1a, 0x05, 0x43, 0x21, 0x77, 0x74,
	0xae, 0xd7, 0x35, 0x70, 0x22, 0xd5, 0xc5, 0x21, 0x8d, 0x73, 0xf3, 0x0a, 0x98, 0x91, 0x85, 0x4e,
	0xe4, 0xf1, 0xae, 0x5d, 0xfd, 0xd6, 0x54, 0x86, 0xe8, 0x65, 0xf6, 0x06, 0xa5, 0x0f, 0x84, 0xe7,
	0x8f, 0x9e, 0x50, 0x01, 0xb7, 0x8d, 0xf2, 0x05, 0x52, 0x1d, 0x7d, 0x55, 0x75, 0x11, 0x2f, 0xdd,
	0x20, 0xc5, 0xdb, 0x7c, 0x93, 0xd2, 0x53, 0x9e, 0x7e, 0xf8, 0xea, 0xf5, 0x6e, 0xe5, 0xeb, 0xd7,
	0xbb, 0x95, 0x7f, 0xbc, 0xde, 0xad, 0x7c, 0xf9, 0x66, 0xf7, 0xd6, 0xd7, 0x6f, 0x76, 0x6f, 0x7d,
	0xf3, 0x66, 0xf7, 0xd6, 0xaf, 0x37, 0xca, 0x43, 0xd5, 0x29, 0x27, 0xae, 0x6a, 0x50, 0x9d, 0x1f,
	0xff, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x3c, 0xc2, 0xe7, 0x0d, 0xc6, 0x16, 0x00, 0x00,
}

func (this *GlobalModelState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalModelState)
	if !ok {
		that2, ok := that.(GlobalModelState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ModelIpfsHash != that1.ModelIpfsHash {
		return false
	}
	if this.ModelVersion != that1.ModelVersion {
		return false
	}
	if this.LastUpdatedHeight != that1.LastUpdatedHeight {
		return false
	}
	if !this.LastUpdatedTime.Equal(that1.LastUpdatedTime) {
		return false
	}
	if this.TrainingRoundId != that1.TrainingRoundId {
		return false
	}
	if this.LastAggregationId != that1.LastAggregationId {
		return false
	}
	return true
}
func (this *AggregationRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregationRecord)
	if !ok {
		that2, ok := that.(AggregationRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AggregationId != that1.AggregationId {
		return false
	}
	if this.Proposer != that1.Proposer {
		return false
	}
	if this.AggregatedGradientIpfsHash != that1.AggregatedGradientIpfsHash {
		return false
	}
	if this.MerkleRoot != that1.MerkleRoot {
		return false
	}
	if len(this.ParticipantGradientIds) != len(that1.ParticipantGradientIds) {
		return false
	}
	for i := range this.ParticipantGradientIds {
		if this.ParticipantGradientIds[i] != that1.ParticipantGradientIds[i] {
			return false
		}
	}
	if this.TrainingRoundId != that1.TrainingRoundId {
		return false
	}
	if this.ModelVersion != that1.ModelVersion {
		return false
	}
	if this.SubmittedAtHeight != that1.SubmittedAtHeight {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.ChallengeDeadlineHeight != that1.ChallengeDeadlineHeight {
		return false
	}
	return true
}
func (this *AggregationCommitment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregationCommitment)
	if !ok {
		that2, ok := that.(AggregationCommitment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CommitmentId != that1.CommitmentId {
		return false
	}
	if this.Proposer != that1.Proposer {
		return false
	}
	if this.CommitmentHash != that1.CommitmentHash {
		return false
	}
	if this.TrainingRoundId != that1.TrainingRoundId {
		return false
	}
	if len(this.ParticipantGradientIds) != len(that1.ParticipantGradientIds) {
		return false
	}
	for i := range this.ParticipantGradientIds {
		if this.ParticipantGradientIds[i] != that1.ParticipantGradientIds[i] {
			return false
		}
	}
	if this.CommittedAtHeight != that1.CommittedAtHeight {
		return false
	}
	if this.RevealDeadlineHeight != that1.RevealDeadlineHeight {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.RevealedAggregationId != that1.RevealedAggregationId {
		return false
	}
	return true
}
func (this *MiningContribution) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MiningContribution)
	if !ok {
		that2, ok := that.(MiningContribution)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinerAddress != that1.MinerAddress {
		return false
	}
	if this.TotalSubmissions != that1.TotalSubmissions {
		return false
	}
	if this.SuccessfulSubmissions != that1.SuccessfulSubmissions {
		return false
	}
	if this.TrustScore != that1.TrustScore {
		return false
	}
	if this.ReputationTier != that1.ReputationTier {
		return false
	}
	if this.SlashingEvents != that1.SlashingEvents {
		return false
	}
	if this.LastSubmissionHeight != that1.LastSubmissionHeight {
		return false
	}
	if this.TrapsCaught != that1.TrapsCaught {
		return false
	}
	if this.TrapsFailed != that1.TrapsFailed {
		return false
	}
	if this.FraudScore != that1.FraudScore {
		return false
	}
	return true
}
func (this *ChallengeRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRecord)
	if !ok {
		that2, ok := that.(ChallengeRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChallengeId != that1.ChallengeId {
		return false
	}
	if this.Challenger != that1.Challenger {
		return false
	}
	if this.AggregationId != that1.AggregationId {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.EvidenceIpfsHash != that1.EvidenceIpfsHash {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.CreatedAtHeight != that1.CreatedAtHeight {
		return false
	}
	if len(this.CpuVerificationPanel) != len(that1.CpuVerificationPanel) {
		return false
	}
	for i := range this.CpuVerificationPanel {
		if this.CpuVerificationPanel[i] != that1.CpuVerificationPanel[i] {
			return false
		}
	}
	if len(this.CpuVerificationResults) != len(that1.CpuVerificationResults) {
		return false
	}
	for i := range this.CpuVerificationResults {
		if !this.CpuVerificationResults[i].Equal(that1.CpuVerificationResults[i]) {
			return false
		}
	}
	if this.ResolutionHeight != that1.ResolutionHeight {
		return false
	}
	if this.FraudDetected != that1.FraudDetected {
		return false
	}
	if this.Layer != that1.Layer {
		return false
	}
	if this.BondAmount != that1.BondAmount {
		return false
	}
	if this.RandomVerifier != that1.RandomVerifier {
		return false
	}
	if this.RandomVerifierResult != that1.RandomVerifierResult {
		return false
	}
	if this.MinerWeightsIpfs != that1.MinerWeightsIpfs {
		return false
	}
	if this.DataBatchSeed != that1.DataBatchSeed {
		return false
	}
	if this.VerifierLoss != that1.VerifierLoss {
		return false
	}
	if this.LossMatch != that1.LossMatch {
		return false
	}
	if this.LossTolerance != that1.LossTolerance {
		return false
	}
	return true
}
func (this *CPUVerificationResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CPUVerificationResult)
	if !ok {
		that2, ok := that.(CPUVerificationResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if this.IsValid != that1.IsValid {
		return false
	}
	if this.ComputedHash != that1.ComputedHash {
		return false
	}
	if this.ExpectedHash != that1.ExpectedHash {
		return false
	}
	if !this.VerificationTime.Equal(that1.VerificationTime) {
		return false
	}
	return true
}
func (this *ParticipantSyncState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ParticipantSyncState)
	if !ok {
		that2, ok := that.(ParticipantSyncState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ParticipantAddress != that1.ParticipantAddress {
		return false
	}
	if this.CurrentModelVersion != that1.CurrentModelVersion {
		return false
	}
	if this.LastSyncHeight != that1.LastSyncHeight {
		return false
	}
	if !this.LastSyncTime.Equal(that1.LastSyncTime) {
		return false
	}
	if this.IsSynced != that1.IsSynced {
		return false
	}
	if this.SyncLagBlocks != that1.SyncLagBlocks {
		return false
	}
	if this.ParticipantType != that1.ParticipantType {
		return false
	}
	if this.IsPartitioned != that1.IsPartitioned {
		return false
	}
	if this.PartitionDetectedAt != that1.PartitionDetectedAt {
		return false
	}
	if !this.PartitionDetectedTime.Equal(that1.PartitionDetectedTime) {
		return false
	}
	if this.PartitionRecoveredAt != that1.PartitionRecoveredAt {
		return false
	}
	if !this.PartitionRecoveredTime.Equal(that1.PartitionRecoveredTime) {
		return false
	}
	return true
}
func (this *PartitionRecoveryInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartitionRecoveryInfo)
	if !ok {
		that2, ok := that.(PartitionRecoveryInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ParticipantAddress != that1.ParticipantAddress {
		return false
	}
	if this.WasPartitioned != that1.WasPartitioned {
		return false
	}
	if this.PartitionDuration != that1.PartitionDuration {
		return false
	}
	if this.RecoveryType != that1.RecoveryType {
		return false
	}
	if this.RequiresFullSync != that1.RequiresFullSync {
		return false
	}
	if this.SyncLagBlocks != that1.SyncLagBlocks {
		return false
	}
	if !this.GlobalState.Equal(&that1.GlobalState) {
		return false
	}
	if len(this.CatchUpGradients) != len(that1.CatchUpGradients) {
		return false
	}
	for i := range this.CatchUpGradients {
		if !this.CatchUpGradients[i].Equal(&that1.CatchUpGradients[i]) {
			return false
		}
	}
	return true
}
func (this *ProofOfReplication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProofOfReplication)
	if !ok {
		that2, ok := that.(ProofOfReplication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataHash != that1.DataHash {
		return false
	}
	if this.ReplicaHash != that1.ReplicaHash {
		return false
	}
	if !bytes.Equal(this.MerkleProof, that1.MerkleProof) {
		return false
	}
	if !bytes.Equal(this.StorageProof, that1.StorageProof) {
		return false
	}
	if this.ReplicationId != that1.ReplicationId {
		return false
	}
	if this.MinerAddress != that1.MinerAddress {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	return true
}
func (this *PartitionStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartitionStatus)
	if !ok {
		that2, ok := that.(PartitionStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IsPartitioned != that1.IsPartitioned {
		return false
	}
	if this.SyncLagBlocks != that1.SyncLagBlocks {
		return false
	}
	if this.TimeSinceLastSync != that1.TimeSinceLastSync {
		return false
	}
	if this.LastSyncHeight != that1.LastSyncHeight {
		return false
	}
	if !this.LastSyncTime.Equal(that1.LastSyncTime) {
		return false
	}
	if this.PartitionDetectedAt != that1.PartitionDetectedAt {
		return false
	}
	if this.PartitionRecoveredAt != that1.PartitionRecoveredAt {
		return false
	}
	if this.PartitionDuration != that1.PartitionDuration {
		return false
	}
	return true
}
func (this *ConvergenceMetrics) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConvergenceMetrics)
	if !ok {
		that2, ok := that.(ConvergenceMetrics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TrainingRoundId != that1.TrainingRoundId {
		return false
	}
	if this.AverageLoss != that1.AverageLoss {
		return false
	}
	if len(this.LossHistory) != len(that1.LossHistory) {
		return false
	}
	for i := range this.LossHistory {
		if this.LossHistory[i] != that1.LossHistory[i] {
			return false
		}
	}
	if this.ConvergenceRate != that1.ConvergenceRate {
		return false
	}
	if this.IsConverged != that1.IsConverged {
		return false
	}
	if this.ConvergenceThreshold != that1.ConvergenceThreshold {
		return false
	}
	if this.LastUpdatedHeight != that1.LastUpdatedHeight {
		return false
	}
	return true
}
func (this *PinInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PinInfo)
	if !ok {
		that2, ok := that.(PinInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pinner != that1.Pinner {
		return false
	}
	if this.Cid != that1.Cid {
		return false
	}
	if this.SizeBytes != that1.SizeBytes {
		return false
	}
	if this.PinnedAt != that1.PinnedAt {
		return false
	}
	if this.UnpinnedAt != that1.UnpinnedAt {
		return false
	}
	return true
}
func (this *AggregationIDList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregationIDList)
	if !ok {
		that2, ok := that.(AggregationIDList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AggregationIds) != len(that1.AggregationIds) {
		return false
	}
	for i := range this.AggregationIds {
		if this.AggregationIds[i] != that1.AggregationIds[i] {
			return false
		}
	}
	return true
}
func (m *GlobalModelState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalModelState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalModelState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastAggregationId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.LastAggregationId))
		i--
		dAtA[i] = 0x30
	}
	if m.TrainingRoundId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TrainingRoundId))
		i--
		dAtA[i] = 0x28
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastUpdatedTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdatedTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintState(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x22
	if m.LastUpdatedHeight != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.LastUpdatedHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintState(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ModelIpfsHash) > 0 {
		i -= len(m.ModelIpfsHash)
		copy(dAtA[i:], m.ModelIpfsHash)
		i = encodeVarintState(dAtA, i, uint64(len(m.ModelIpfsHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AggregationRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregationRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregationRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChallengeDeadlineHeight != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ChallengeDeadlineHeight))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintState(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x4a
	}
	if m.SubmittedAtHeight != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.SubmittedAtHeight))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintState(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TrainingRoundId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TrainingRoundId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ParticipantGradientIds) > 0 {
		dAtA3 := make([]byte, len(m.ParticipantGradientIds)*10)
		var j2 int
		for _, num := range m.ParticipantGradientIds {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintState(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MerkleRoot) > 0 {
		i -= len(m.MerkleRoot)
		copy(dAtA[i:], m.MerkleRoot)
		i = encodeVarintState(dAtA, i, uint64(len(m.MerkleRoot)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AggregatedGradientIpfsHash) > 0 {
		i -= len(m.AggregatedGradientIpfsHash)
		copy(dAtA[i:], m.AggregatedGradientIpfsHash)
		i = encodeVarintState(dAtA, i, uint64(len(m.AggregatedGradientIpfsHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintState(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x12
	}
	if m.AggregationId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.AggregationId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AggregationCommitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregationCommitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregationCommitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RevealedAggregationId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.RevealedAggregationId))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintState(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x42
	}
	if m.RevealDeadlineHeight != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.RevealDeadlineHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.CommittedAtHeight != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.CommittedAtHeight))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ParticipantGradientIds) > 0 {
		dAtA5 := make([]byte, len(m.ParticipantGradientIds)*10)
		var j4 int
		for _, num := range m.ParticipantGradientIds {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintState(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x2a
	}
	if m.TrainingRoundId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TrainingRoundId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CommitmentHash) > 0 {
		i -= len(m.CommitmentHash)
		copy(dAtA[i:], m.CommitmentHash)
		i = encodeVarintState(dAtA, i, uint64(len(m.CommitmentHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintState(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x12
	}
	if m.CommitmentId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.CommitmentId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MiningContribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningContribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MiningContribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FraudScore) > 0 {
		i -= len(m.FraudScore)
		copy(dAtA[i:], m.FraudScore)
		i = encodeVarintState(dAtA, i, uint64(len(m.FraudScore)))
		i--
		dAtA[i] = 0x52
	}
	if m.TrapsFailed != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TrapsFailed))
		i--
		dAtA[i] = 0x48
	}
	if m.TrapsCaught != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TrapsCaught))
		i--
		dAtA[i] = 0x40
	}
	if m.LastSubmissionHeight != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.LastSubmissionHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.SlashingEvents != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.SlashingEvents))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ReputationTier) > 0 {
		i -= len(m.ReputationTier)
		copy(dAtA[i:], m.ReputationTier)
		i = encodeVarintState(dAtA, i, uint64(len(m.ReputationTier)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TrustScore) > 0 {
		i -= len(m.TrustScore)
		copy(dAtA[i:], m.TrustScore)
		i = encodeVarintState(dAtA, i, uint64(len(m.TrustScore)))
		i--
		dAtA[i] = 0x22
	}
	if m.SuccessfulSubmissions != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.SuccessfulSubmissions))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalSubmissions != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TotalSubmissions))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MinerAddress) > 0 {
		i -= len(m.MinerAddress)
		copy(dAtA[i:], m.MinerAddress)
		i = encodeVarintState(dAtA, i, uint64(len(m.MinerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChallengeRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LossTolerance) > 0 {
		i -= len(m.LossTolerance)
		copy(dAtA[i:], m.LossTolerance)
		i = encodeVarintState(dAtA, i, uint64(len(m.LossTolerance)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.LossMatch {
		i--
		if m.LossMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.VerifierLoss) > 0 {
		i -= len(m.VerifierLoss)
		copy(dAtA[i:], m.VerifierLoss)
		i = encodeVarintState(dAtA, i, uint64(len(m.VerifierLoss)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.DataBatchSeed != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.DataBatchSeed))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.MinerWeightsIpfs) > 0 {
		i -= len(m.MinerWeightsIpfs)
		copy(dAtA[i:], m.MinerWeightsIpfs)
		i = encodeVarintState(dAtA, i, uint64(len(m.MinerWeightsIpfs)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.RandomVerifierResult) > 0 {
		i -= len(m.RandomVerifierResult)
		copy(dAtA[i:], m.RandomVerifierResult)
		i = encodeVarintState(dAtA, i, uint64(len(m.RandomVerifierResult)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.RandomVerifier) > 0 {
		i -= len(m.RandomVerifier)
		copy(dAtA[i:], m.RandomVerifier)
		i = encodeVarintState(dAtA, i, uint64(len(m.RandomVerifier)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.BondAmount) > 0 {
		i -= len(m.BondAmount)
		copy(dAtA[i:], m.BondAmount)
		i = encodeVarintState(dAtA, i, uint64(len(m.BondAmount)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Layer != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x60
	}
	if m.FraudDetected {
		i--
		if m.FraudDetected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.ResolutionHeight != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ResolutionHeight))
		i--
		dAtA[i] = 0x50
	}
	if len(m.CpuVerificationResults) > 0 {
		for iNdEx := len(m.CpuVerificationResults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CpuVerificationResults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintState(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CpuVerificationPanel) > 0 {
		for iNdEx := len(m.CpuVerificationPanel) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CpuVerificationPanel[iNdEx])
			copy(dAtA[i:], m.CpuVerificationPanel[iNdEx])
			i = encodeVarintState(dAtA, i, uint64(len(m.CpuVerificationPanel[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.CreatedAtHeight != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.CreatedAtHeight))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintState(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EvidenceIpfsHash) > 0 {
		i -= len(m.EvidenceIpfsHash)
		copy(dAtA[i:], m.EvidenceIpfsHash)
		i = encodeVarintState(dAtA, i, uint64(len(m.EvidenceIpfsHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintState(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if m.AggregationId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.AggregationId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Challenger) > 0 {
		i -= len(m.Challenger)
		copy(dAtA[i:], m.Challenger)
		i = encodeVarintState(dAtA, i, uint64(len(m.Challenger)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChallengeId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ChallengeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CPUVerificationResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUVerificationResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPUVerificationResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.VerificationTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.VerificationTime):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintState(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x2a
	if len(m.ExpectedHash) > 0 {
		i -= len(m.ExpectedHash)
		copy(dAtA[i:], m.ExpectedHash)
		i = encodeVarintState(dAtA, i, uint64(len(m.ExpectedHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ComputedHash) > 0 {
		i -= len(m.ComputedHash)
		copy(dAtA[i:], m.ComputedHash)
		i = encodeVarintState(dAtA, i, uint64(len(m.ComputedHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsValid {
		i--
		if m.IsValid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintState(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParticipantSyncState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParticipantSyncState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParticipantSyncState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.PartitionRecoveredTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PartitionRecoveredTime):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintState(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x62
	if m.PartitionRecoveredAt != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.PartitionRecoveredAt))
		i--
		dAtA[i] = 0x58
	}
	n8, err8 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.PartitionDetectedTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PartitionDetectedTime):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintState(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x52
	if m.PartitionDetectedAt != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.PartitionDetectedAt))
		i--
		dAtA[i] = 0x48
	}
	if m.IsPartitioned {
		i--
		if m.IsPartitioned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.ParticipantType) > 0 {
		i -= len(m.ParticipantType)
		copy(dAtA[i:], m.ParticipantType)
		i = encodeVarintState(dAtA, i, uint64(len(m.ParticipantType)))
		i--
		dAtA[i] = 0x3a
	}
	if m.SyncLagBlocks != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.SyncLagBlocks))
		i--
		dAtA[i] = 0x30
	}
	if m.IsSynced {
		i--
		if m.IsSynced {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	n9, err9 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastSyncTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastSyncTime):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintState(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x22
	if m.LastSyncHeight != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.LastSyncHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CurrentModelVersion) > 0 {
		i -= len(m.CurrentModelVersion)
		copy(dAtA[i:], m.CurrentModelVersion)
		i = encodeVarintState(dAtA, i, uint64(len(m.CurrentModelVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ParticipantAddress) > 0 {
		i -= len(m.ParticipantAddress)
		copy(dAtA[i:], m.ParticipantAddress)
		i = encodeVarintState(dAtA, i, uint64(len(m.ParticipantAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionRecoveryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionRecoveryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionRecoveryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CatchUpGradients) > 0 {
		for iNdEx := len(m.CatchUpGradients) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CatchUpGradients[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintState(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	{
		size, err := m.GlobalState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.SyncLagBlocks != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.SyncLagBlocks))
		i--
		dAtA[i] = 0x30
	}
	if m.RequiresFullSync {
		i--
		if m.RequiresFullSync {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.RecoveryType) > 0 {
		i -= len(m.RecoveryType)
		copy(dAtA[i:], m.RecoveryType)
		i = encodeVarintState(dAtA, i, uint64(len(m.RecoveryType)))
		i--
		dAtA[i] = 0x22
	}
	if m.PartitionDuration != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.PartitionDuration))
		i--
		dAtA[i] = 0x18
	}
	if m.WasPartitioned {
		i--
		if m.WasPartitioned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ParticipantAddress) > 0 {
		i -= len(m.ParticipantAddress)
		copy(dAtA[i:], m.ParticipantAddress)
		i = encodeVarintState(dAtA, i, uint64(len(m.ParticipantAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProofOfReplication) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProofOfReplication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofOfReplication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x38
	}
	if len(m.MinerAddress) > 0 {
		i -= len(m.MinerAddress)
		copy(dAtA[i:], m.MinerAddress)
		i = encodeVarintState(dAtA, i, uint64(len(m.MinerAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ReplicationId) > 0 {
		i -= len(m.ReplicationId)
		copy(dAtA[i:], m.ReplicationId)
		i = encodeVarintState(dAtA, i, uint64(len(m.ReplicationId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StorageProof) > 0 {
		i -= len(m.StorageProof)
		copy(dAtA[i:], m.StorageProof)
		i = encodeVarintState(dAtA, i, uint64(len(m.StorageProof)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MerkleProof) > 0 {
		i -= len(m.MerkleProof)
		copy(dAtA[i:], m.MerkleProof)
		i = encodeVarintState(dAtA, i, uint64(len(m.MerkleProof)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ReplicaHash) > 0 {
		i -= len(m.ReplicaHash)
		copy(dAtA[i:], m.ReplicaHash)
		i = encodeVarintState(dAtA, i, uint64(len(m.ReplicaHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DataHash) > 0 {
		i -= len(m.DataHash)
		copy(dAtA[i:], m.DataHash)
		i = encodeVarintState(dAtA, i, uint64(len(m.DataHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PartitionDuration != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.PartitionDuration))
		i--
		dAtA[i] = 0x40
	}
	if m.PartitionRecoveredAt != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.PartitionRecoveredAt))
		i--
		dAtA[i] = 0x38
	}
	if m.PartitionDetectedAt != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.PartitionDetectedAt))
		i--
		dAtA[i] = 0x30
	}
	n11, err11 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastSyncTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastSyncTime):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintState(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x2a
	if m.LastSyncHeight != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.LastSyncHeight))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TimeSinceLastSync) > 0 {
		i -= len(m.TimeSinceLastSync)
		copy(dAtA[i:], m.TimeSinceLastSync)
		i = encodeVarintState(dAtA, i, uint64(len(m.TimeSinceLastSync)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SyncLagBlocks != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.SyncLagBlocks))
		i--
		dAtA[i] = 0x10
	}
	if m.IsPartitioned {
		i--
		if m.IsPartitioned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConvergenceMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvergenceMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvergenceMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastUpdatedHeight != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.LastUpdatedHeight))
		i--
		dAtA[i] = 0x38
	}
	if len(m.ConvergenceThreshold) > 0 {
		i -= len(m.ConvergenceThreshold)
		copy(dAtA[i:], m.ConvergenceThreshold)
		i = encodeVarintState(dAtA, i, uint64(len(m.ConvergenceThreshold)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsConverged {
		i--
		if m.IsConverged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.ConvergenceRate) > 0 {
		i -= len(m.ConvergenceRate)
		copy(dAtA[i:], m.ConvergenceRate)
		i = encodeVarintState(dAtA, i, uint64(len(m.ConvergenceRate)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LossHistory) > 0 {
		for iNdEx := len(m.LossHistory) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LossHistory[iNdEx])
			copy(dAtA[i:], m.LossHistory[iNdEx])
			i = encodeVarintState(dAtA, i, uint64(len(m.LossHistory[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AverageLoss) > 0 {
		i -= len(m.AverageLoss)
		copy(dAtA[i:], m.AverageLoss)
		i = encodeVarintState(dAtA, i, uint64(len(m.AverageLoss)))
		i--
		dAtA[i] = 0x12
	}
	if m.TrainingRoundId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TrainingRoundId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PinInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PinInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PinInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UnpinnedAt != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.UnpinnedAt))
		i--
		dAtA[i] = 0x28
	}
	if m.PinnedAt != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.PinnedAt))
		i--
		dAtA[i] = 0x20
	}
	if m.SizeBytes != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintState(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Pinner) > 0 {
		i -= len(m.Pinner)
		copy(dAtA[i:], m.Pinner)
		i = encodeVarintState(dAtA, i, uint64(len(m.Pinner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AggregationIDList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregationIDList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregationIDList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AggregationIds) > 0 {
		dAtA13 := make([]byte, len(m.AggregationIds)*10)
		var j12 int
		for _, num := range m.AggregationIds {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintState(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintState(dAtA []byte, offset int, v uint64) int {
	offset -= sovState(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GlobalModelState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModelIpfsHash)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.LastUpdatedHeight != 0 {
		n += 1 + sovState(uint64(m.LastUpdatedHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdatedTime)
	n += 1 + l + sovState(uint64(l))
	if m.TrainingRoundId != 0 {
		n += 1 + sovState(uint64(m.TrainingRoundId))
	}
	if m.LastAggregationId != 0 {
		n += 1 + sovState(uint64(m.LastAggregationId))
	}
	return n
}

func (m *AggregationRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregationId != 0 {
		n += 1 + sovState(uint64(m.AggregationId))
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.AggregatedGradientIpfsHash)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.MerkleRoot)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if len(m.ParticipantGradientIds) > 0 {
		l = 0
		for _, e := range m.ParticipantGradientIds {
			l += sovState(uint64(e))
		}
		n += 1 + sovState(uint64(l)) + l
	}
	if m.TrainingRoundId != 0 {
		n += 1 + sovState(uint64(m.TrainingRoundId))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.SubmittedAtHeight != 0 {
		n += 1 + sovState(uint64(m.SubmittedAtHeight))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.ChallengeDeadlineHeight != 0 {
		n += 1 + sovState(uint64(m.ChallengeDeadlineHeight))
	}
	return n
}

func (m *AggregationCommitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommitmentId != 0 {
		n += 1 + sovState(uint64(m.CommitmentId))
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.CommitmentHash)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.TrainingRoundId != 0 {
		n += 1 + sovState(uint64(m.TrainingRoundId))
	}
	if len(m.ParticipantGradientIds) > 0 {
		l = 0
		for _, e := range m.ParticipantGradientIds {
			l += sovState(uint64(e))
		}
		n += 1 + sovState(uint64(l)) + l
	}
	if m.CommittedAtHeight != 0 {
		n += 1 + sovState(uint64(m.CommittedAtHeight))
	}
	if m.RevealDeadlineHeight != 0 {
		n += 1 + sovState(uint64(m.RevealDeadlineHeight))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.RevealedAggregationId != 0 {
		n += 1 + sovState(uint64(m.RevealedAggregationId))
	}
	return n
}

func (m *MiningContribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MinerAddress)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.TotalSubmissions != 0 {
		n += 1 + sovState(uint64(m.TotalSubmissions))
	}
	if m.SuccessfulSubmissions != 0 {
		n += 1 + sovState(uint64(m.SuccessfulSubmissions))
	}
	l = len(m.TrustScore)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.ReputationTier)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.SlashingEvents != 0 {
		n += 1 + sovState(uint64(m.SlashingEvents))
	}
	if m.LastSubmissionHeight != 0 {
		n += 1 + sovState(uint64(m.LastSubmissionHeight))
	}
	if m.TrapsCaught != 0 {
		n += 1 + sovState(uint64(m.TrapsCaught))
	}
	if m.TrapsFailed != 0 {
		n += 1 + sovState(uint64(m.TrapsFailed))
	}
	l = len(m.FraudScore)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *ChallengeRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChallengeId != 0 {
		n += 1 + sovState(uint64(m.ChallengeId))
	}
	l = len(m.Challenger)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.AggregationId != 0 {
		n += 1 + sovState(uint64(m.AggregationId))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.EvidenceIpfsHash)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.CreatedAtHeight != 0 {
		n += 1 + sovState(uint64(m.CreatedAtHeight))
	}
	if len(m.CpuVerificationPanel) > 0 {
		for _, s := range m.CpuVerificationPanel {
			l = len(s)
			n += 1 + l + sovState(uint64(l))
		}
	}
	if len(m.CpuVerificationResults) > 0 {
		for _, e := range m.CpuVerificationResults {
			l = e.Size()
			n += 1 + l + sovState(uint64(l))
		}
	}
	if m.ResolutionHeight != 0 {
		n += 1 + sovState(uint64(m.ResolutionHeight))
	}
	if m.FraudDetected {
		n += 2
	}
	if m.Layer != 0 {
		n += 1 + sovState(uint64(m.Layer))
	}
	l = len(m.BondAmount)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.RandomVerifier)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.RandomVerifierResult)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.MinerWeightsIpfs)
	if l > 0 {
		n += 2 + l + sovState(uint64(l))
	}
	if m.DataBatchSeed != 0 {
		n += 2 + sovState(uint64(m.DataBatchSeed))
	}
	l = len(m.VerifierLoss)
	if l > 0 {
		n += 2 + l + sovState(uint64(l))
	}
	if m.LossMatch {
		n += 3
	}
	l = len(m.LossTolerance)
	if l > 0 {
		n += 2 + l + sovState(uint64(l))
	}
	return n
}

func (m *CPUVerificationResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.IsValid {
		n += 2
	}
	l = len(m.ComputedHash)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.ExpectedHash)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.VerificationTime)
	n += 1 + l + sovState(uint64(l))
	return n
}

func (m *ParticipantSyncState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ParticipantAddress)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.CurrentModelVersion)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.LastSyncHeight != 0 {
		n += 1 + sovState(uint64(m.LastSyncHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastSyncTime)
	n += 1 + l + sovState(uint64(l))
	if m.IsSynced {
		n += 2
	}
	if m.SyncLagBlocks != 0 {
		n += 1 + sovState(uint64(m.SyncLagBlocks))
	}
	l = len(m.ParticipantType)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.IsPartitioned {
		n += 2
	}
	if m.PartitionDetectedAt != 0 {
		n += 1 + sovState(uint64(m.PartitionDetectedAt))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PartitionDetectedTime)
	n += 1 + l + sovState(uint64(l))
	if m.PartitionRecoveredAt != 0 {
		n += 1 + sovState(uint64(m.PartitionRecoveredAt))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PartitionRecoveredTime)
	n += 1 + l + sovState(uint64(l))
	return n
}

func (m *PartitionRecoveryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ParticipantAddress)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.WasPartitioned {
		n += 2
	}
	if m.PartitionDuration != 0 {
		n += 1 + sovState(uint64(m.PartitionDuration))
	}
	l = len(m.RecoveryType)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.RequiresFullSync {
		n += 2
	}
	if m.SyncLagBlocks != 0 {
		n += 1 + sovState(uint64(m.SyncLagBlocks))
	}
	l = m.GlobalState.Size()
	n += 1 + l + sovState(uint64(l))
	if len(m.CatchUpGradients) > 0 {
		for _, e := range m.CatchUpGradients {
			l = e.Size()
			n += 1 + l + sovState(uint64(l))
		}
	}
	return n
}

func (m *ProofOfReplication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataHash)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.ReplicaHash)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.MerkleProof)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.StorageProof)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.ReplicationId)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.MinerAddress)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovState(uint64(m.Timestamp))
	}
	return n
}

func (m *PartitionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsPartitioned {
		n += 2
	}
	if m.SyncLagBlocks != 0 {
		n += 1 + sovState(uint64(m.SyncLagBlocks))
	}
	l = len(m.TimeSinceLastSync)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.LastSyncHeight != 0 {
		n += 1 + sovState(uint64(m.LastSyncHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastSyncTime)
	n += 1 + l + sovState(uint64(l))
	if m.PartitionDetectedAt != 0 {
		n += 1 + sovState(uint64(m.PartitionDetectedAt))
	}
	if m.PartitionRecoveredAt != 0 {
		n += 1 + sovState(uint64(m.PartitionRecoveredAt))
	}
	if m.PartitionDuration != 0 {
		n += 1 + sovState(uint64(m.PartitionDuration))
	}
	return n
}

func (m *ConvergenceMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrainingRoundId != 0 {
		n += 1 + sovState(uint64(m.TrainingRoundId))
	}
	l = len(m.AverageLoss)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if len(m.LossHistory) > 0 {
		for _, s := range m.LossHistory {
			l = len(s)
			n += 1 + l + sovState(uint64(l))
		}
	}
	l = len(m.ConvergenceRate)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.IsConverged {
		n += 2
	}
	l = len(m.ConvergenceThreshold)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.LastUpdatedHeight != 0 {
		n += 1 + sovState(uint64(m.LastUpdatedHeight))
	}
	return n
}

func (m *PinInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pinner)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovState(uint64(m.SizeBytes))
	}
	if m.PinnedAt != 0 {
		n += 1 + sovState(uint64(m.PinnedAt))
	}
	if m.UnpinnedAt != 0 {
		n += 1 + sovState(uint64(m.UnpinnedAt))
	}
	return n
}

func (m *AggregationIDList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AggregationIds) > 0 {
		l = 0
		for _, e := range m.AggregationIds {
			l += sovState(uint64(e))
		}
		n += 1 + sovState(uint64(l)) + l
	}
	return n
}

func sovState(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozState(x uint64) (n int) {
	return sovState(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GlobalModelState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalModelState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalModelState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedHeight", wireType)
			}
			m.LastUpdatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdatedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastUpdatedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingRoundId", wireType)
			}
			m.TrainingRoundId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainingRoundId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAggregationId", wireType)
			}
			m.LastAggregationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastAggregationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregationRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregationRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationId", wireType)
			}
			m.AggregationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AggregationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatedGradientIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregatedGradientIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowState
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ParticipantGradientIds = append(m.ParticipantGradientIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowState
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthState
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthState
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParticipantGradientIds) == 0 {
					m.ParticipantGradientIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowState
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ParticipantGradientIds = append(m.ParticipantGradientIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantGradientIds", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingRoundId", wireType)
			}
			m.TrainingRoundId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainingRoundId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAtHeight", wireType)
			}
			m.SubmittedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeDeadlineHeight", wireType)
			}
			m.ChallengeDeadlineHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeDeadlineHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregationCommitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregationCommitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregationCommitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitmentId", wireType)
			}
			m.CommitmentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitmentId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitmentHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitmentHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingRoundId", wireType)
			}
			m.TrainingRoundId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainingRoundId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowState
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ParticipantGradientIds = append(m.ParticipantGradientIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowState
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthState
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthState
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParticipantGradientIds) == 0 {
					m.ParticipantGradientIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowState
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ParticipantGradientIds = append(m.ParticipantGradientIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantGradientIds", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedAtHeight", wireType)
			}
			m.CommittedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevealDeadlineHeight", wireType)
			}
			m.RevealDeadlineHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevealDeadlineHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevealedAggregationId", wireType)
			}
			m.RevealedAggregationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevealedAggregationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningContribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningContribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningContribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSubmissions", wireType)
			}
			m.TotalSubmissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSubmissions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessfulSubmissions", wireType)
			}
			m.SuccessfulSubmissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessfulSubmissions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustScore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustScore = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReputationTier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReputationTier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingEvents", wireType)
			}
			m.SlashingEvents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashingEvents |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSubmissionHeight", wireType)
			}
			m.LastSubmissionHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSubmissionHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrapsCaught", wireType)
			}
			m.TrapsCaught = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrapsCaught |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrapsFailed", wireType)
			}
			m.TrapsFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrapsFailed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FraudScore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FraudScore = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeId", wireType)
			}
			m.ChallengeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenger", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenger = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationId", wireType)
			}
			m.AggregationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AggregationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAtHeight", wireType)
			}
			m.CreatedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuVerificationPanel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuVerificationPanel = append(m.CpuVerificationPanel, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuVerificationResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuVerificationResults = append(m.CpuVerificationResults, &CPUVerificationResult{})
			if err := m.CpuVerificationResults[len(m.CpuVerificationResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolutionHeight", wireType)
			}
			m.ResolutionHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolutionHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FraudDetected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FraudDetected = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomVerifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RandomVerifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomVerifierResult", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RandomVerifierResult = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinerWeightsIpfs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinerWeightsIpfs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataBatchSeed", wireType)
			}
			m.DataBatchSeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataBatchSeed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifierLoss", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifierLoss = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LossMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LossMatch = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LossTolerance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LossTolerance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUVerificationResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUVerificationResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUVerificationResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsValid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsValid = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputedHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComputedHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.VerificationTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParticipantSyncState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParticipantSyncState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParticipantSyncState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParticipantAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSyncHeight", wireType)
			}
			m.LastSyncHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSyncHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSyncTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastSyncTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSynced", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSynced = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncLagBlocks", wireType)
			}
			m.SyncLagBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncLagBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParticipantType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPartitioned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPartitioned = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionDetectedAt", wireType)
			}
			m.PartitionDetectedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionDetectedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionDetectedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.PartitionDetectedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionRecoveredAt", wireType)
			}
			m.PartitionRecoveredAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionRecoveredAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionRecoveredTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.PartitionRecoveredTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionRecoveryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionRecoveryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionRecoveryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParticipantAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WasPartitioned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WasPartitioned = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionDuration", wireType)
			}
			m.PartitionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoveryType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiresFullSync", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequiresFullSync = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncLagBlocks", wireType)
			}
			m.SyncLagBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncLagBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GlobalState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatchUpGradients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CatchUpGradients = append(m.CatchUpGradients, StoredGradient{})
			if err := m.CatchUpGradients[len(m.CatchUpGradients)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProofOfReplication) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProofOfReplication: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProofOfReplication: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleProof = append(m.MerkleProof[:0], dAtA[iNdEx:postIndex]...)
			if m.MerkleProof == nil {
				m.MerkleProof = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageProof = append(m.StorageProof[:0], dAtA[iNdEx:postIndex]...)
			if m.StorageProof == nil {
				m.StorageProof = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPartitioned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPartitioned = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncLagBlocks", wireType)
			}
			m.SyncLagBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncLagBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSinceLastSync", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeSinceLastSync = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSyncHeight", wireType)
			}
			m.LastSyncHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSyncHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSyncTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastSyncTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionDetectedAt", wireType)
			}
			m.PartitionDetectedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionDetectedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionRecoveredAt", wireType)
			}
			m.PartitionRecoveredAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionRecoveredAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionDuration", wireType)
			}
			m.PartitionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvergenceMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvergenceMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvergenceMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingRoundId", wireType)
			}
			m.TrainingRoundId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainingRoundId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageLoss", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AverageLoss = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LossHistory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LossHistory = append(m.LossHistory, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConvergenceRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConvergenceRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConverged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConverged = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConvergenceThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConvergenceThreshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedHeight", wireType)
			}
			m.LastUpdatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdatedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PinInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PinInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PinInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pinner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pinner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedAt", wireType)
			}
			m.PinnedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PinnedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpinnedAt", wireType)
			}
			m.UnpinnedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnpinnedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregationIDList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregationIDList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregationIDList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowState
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AggregationIds = append(m.AggregationIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowState
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthState
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthState
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AggregationIds) == 0 {
					m.AggregationIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowState
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AggregationIds = append(m.AggregationIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipState(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowState
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthState
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupState
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthState
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthState        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowState          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupState = fmt.Errorf("proto: unexpected end of group")
)
