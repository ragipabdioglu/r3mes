// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: remes/remes/v1/stored_gradient.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// StoredGradient represents a gradient submission stored on-chain
// Only metadata and IPFS hash are stored, NOT the actual gradient data
type StoredGradient struct {
	// id is the unique identifier for this gradient submission
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// miner is the address of the miner who submitted the gradient
	Miner string `protobuf:"bytes,2,opt,name=miner,proto3" json:"miner,omitempty"`
	// ipfs_hash is the IPFS content hash of the gradient data
	IpfsHash string `protobuf:"bytes,3,opt,name=ipfs_hash,json=ipfsHash,proto3" json:"ipfs_hash,omitempty"`
	// model_version is the version of the model used for training
	// DEPRECATED: Use model_config_id instead. Kept for backward compatibility.
	ModelVersion string `protobuf:"bytes,4,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
	// training_round_id is the identifier for the training round
	TrainingRoundId uint64 `protobuf:"varint,5,opt,name=training_round_id,json=trainingRoundId,proto3" json:"training_round_id,omitempty"`
	// shard_id is the deterministic shard assignment for this miner
	ShardId uint64 `protobuf:"varint,6,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	// gradient_hash is the deterministic hash of the gradient for verification
	GradientHash string `protobuf:"bytes,7,opt,name=gradient_hash,json=gradientHash,proto3" json:"gradient_hash,omitempty"`
	// gpu_architecture is the GPU architecture used (Ampere, Ada, Blackwell, etc.)
	GpuArchitecture string `protobuf:"bytes,8,opt,name=gpu_architecture,json=gpuArchitecture,proto3" json:"gpu_architecture,omitempty"`
	// submitted_at_height is the block height when this gradient was submitted
	SubmittedAtHeight int64 `protobuf:"varint,9,opt,name=submitted_at_height,json=submittedAtHeight,proto3" json:"submitted_at_height,omitempty"`
	// status is the current status of the gradient (pending, aggregated, challenged)
	Status string `protobuf:"bytes,10,opt,name=status,proto3" json:"status,omitempty"`
	// model_config_id references the ModelRegistry entry
	// This enables model-agnostic gradient storage
	// Default: 0 (legacy BitNet model, will be migrated automatically)
	ModelConfigId uint64 `protobuf:"varint,11,opt,name=model_config_id,json=modelConfigId,proto3" json:"model_config_id,omitempty"`
	// encryption_type specifies how this gradient is encrypted
	EncryptionType EncryptionType `protobuf:"varint,12,opt,name=encryption_type,json=encryptionType,proto3,enum=remes.remes.v1.EncryptionType" json:"encryption_type,omitempty"`
	// encrypted_gradient_ipfs_hash is the IPFS hash of encrypted gradient
	// Only used if encryption_type != ENCRYPTION_TYPE_PLAINTEXT
	EncryptedGradientIpfsHash string `protobuf:"bytes,13,opt,name=encrypted_gradient_ipfs_hash,json=encryptedGradientIpfsHash,proto3" json:"encrypted_gradient_ipfs_hash,omitempty"`
	// container_hash is the Docker/OCI image hash used for training
	ContainerHash string `protobuf:"bytes,14,opt,name=container_hash,json=containerHash,proto3" json:"container_hash,omitempty"`
	// container_signature is the cryptographic signature of the container
	ContainerSignature []byte `protobuf:"bytes,15,opt,name=container_signature,json=containerSignature,proto3" json:"container_signature,omitempty"`
	// global_seed is the deterministic seed used for training (derived from block hash + training round)
	GlobalSeed uint64 `protobuf:"varint,16,opt,name=global_seed,json=globalSeed,proto3" json:"global_seed,omitempty"`
	// claimed_loss is the loss value claimed by the miner (BitNet integer format)
	// Used for Loss-Based Spot Checking in Layer 2 verification
	ClaimedLoss string `protobuf:"bytes,17,opt,name=claimed_loss,json=claimedLoss,proto3" json:"claimed_loss,omitempty"`
	// porep_proof_ipfs_hash is the IPFS hash of the Proof of Replication (PoRep) proof
	// PoRep proves that the miner actually stores the gradient data, not just the hash
	PorepProofIpfsHash string `protobuf:"bytes,18,opt,name=porep_proof_ipfs_hash,json=porepProofIpfsHash,proto3" json:"porep_proof_ipfs_hash,omitempty"`
}

func (m *StoredGradient) Reset()         { *m = StoredGradient{} }
func (m *StoredGradient) String() string { return proto.CompactTextString(m) }
func (*StoredGradient) ProtoMessage()    {}
func (*StoredGradient) Descriptor() ([]byte, []int) {
	return fileDescriptor_bcbb9f784846742c, []int{0}
}
func (m *StoredGradient) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoredGradient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoredGradient.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoredGradient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoredGradient.Merge(m, src)
}
func (m *StoredGradient) XXX_Size() int {
	return m.Size()
}
func (m *StoredGradient) XXX_DiscardUnknown() {
	xxx_messageInfo_StoredGradient.DiscardUnknown(m)
}

var xxx_messageInfo_StoredGradient proto.InternalMessageInfo

func (m *StoredGradient) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StoredGradient) GetMiner() string {
	if m != nil {
		return m.Miner
	}
	return ""
}

func (m *StoredGradient) GetIpfsHash() string {
	if m != nil {
		return m.IpfsHash
	}
	return ""
}

func (m *StoredGradient) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

func (m *StoredGradient) GetTrainingRoundId() uint64 {
	if m != nil {
		return m.TrainingRoundId
	}
	return 0
}

func (m *StoredGradient) GetShardId() uint64 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *StoredGradient) GetGradientHash() string {
	if m != nil {
		return m.GradientHash
	}
	return ""
}

func (m *StoredGradient) GetGpuArchitecture() string {
	if m != nil {
		return m.GpuArchitecture
	}
	return ""
}

func (m *StoredGradient) GetSubmittedAtHeight() int64 {
	if m != nil {
		return m.SubmittedAtHeight
	}
	return 0
}

func (m *StoredGradient) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *StoredGradient) GetModelConfigId() uint64 {
	if m != nil {
		return m.ModelConfigId
	}
	return 0
}

func (m *StoredGradient) GetEncryptionType() EncryptionType {
	if m != nil {
		return m.EncryptionType
	}
	return EncryptionType_ENCRYPTION_TYPE_UNSPECIFIED
}

func (m *StoredGradient) GetEncryptedGradientIpfsHash() string {
	if m != nil {
		return m.EncryptedGradientIpfsHash
	}
	return ""
}

func (m *StoredGradient) GetContainerHash() string {
	if m != nil {
		return m.ContainerHash
	}
	return ""
}

func (m *StoredGradient) GetContainerSignature() []byte {
	if m != nil {
		return m.ContainerSignature
	}
	return nil
}

func (m *StoredGradient) GetGlobalSeed() uint64 {
	if m != nil {
		return m.GlobalSeed
	}
	return 0
}

func (m *StoredGradient) GetClaimedLoss() string {
	if m != nil {
		return m.ClaimedLoss
	}
	return ""
}

func (m *StoredGradient) GetPorepProofIpfsHash() string {
	if m != nil {
		return m.PorepProofIpfsHash
	}
	return ""
}

func init() {
	proto.RegisterType((*StoredGradient)(nil), "remes.remes.v1.StoredGradient")
}

func init() {
	proto.RegisterFile("remes/remes/v1/stored_gradient.proto", fileDescriptor_bcbb9f784846742c)
}

var fileDescriptor_bcbb9f784846742c = []byte{
	// 571 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x53, 0xcd, 0x6e, 0x13, 0x3d,
	0x14, 0xed, 0xf4, 0xbf, 0x6e, 0x3a, 0x69, 0xdc, 0x7e, 0x9f, 0xa6, 0xa5, 0x9a, 0x86, 0x9f, 0xa2,
	0x50, 0x89, 0x44, 0x85, 0x1d, 0x1b, 0x54, 0x10, 0x6a, 0x23, 0xb1, 0x40, 0x53, 0xc4, 0x82, 0x8d,
	0xe5, 0x8c, 0x9d, 0x19, 0x4b, 0x19, 0x7b, 0x64, 0x7b, 0x22, 0xf2, 0x0a, 0xac, 0x78, 0x04, 0x1e,
	0x81, 0xc7, 0x60, 0xd9, 0x25, 0x4b, 0x94, 0x2c, 0xe0, 0x2d, 0x40, 0x73, 0x3d, 0x93, 0x26, 0x6c,
	0x2c, 0xdf, 0x73, 0x8e, 0x7d, 0xae, 0xef, 0xbd, 0x46, 0x8f, 0x34, 0xcf, 0xb8, 0xe9, 0xb9, 0x75,
	0x7c, 0xd1, 0x33, 0x56, 0x69, 0xce, 0x48, 0xa2, 0x29, 0x13, 0x5c, 0xda, 0x6e, 0xae, 0x95, 0x55,
	0xd8, 0x07, 0xbe, 0xeb, 0xd6, 0xf1, 0xc5, 0x71, 0x8b, 0x66, 0x42, 0xaa, 0x1e, 0xac, 0x4e, 0x72,
	0x7c, 0x98, 0xa8, 0x44, 0xc1, 0xb6, 0x57, 0xee, 0x2a, 0xf4, 0xf8, 0x9f, 0xeb, 0x33, 0xc5, 0xf8,
	0xc8, 0x71, 0x0f, 0xfe, 0x6c, 0x20, 0xff, 0x06, 0xec, 0xae, 0x2a, 0x37, 0xec, 0xa3, 0x55, 0xc1,
	0x02, 0xaf, 0xed, 0x75, 0xd6, 0xa3, 0x55, 0xc1, 0xf0, 0x21, 0xda, 0xc8, 0x84, 0xe4, 0x3a, 0x58,
	0x6d, 0x7b, 0x9d, 0x9d, 0xc8, 0x05, 0xf8, 0x1e, 0xda, 0x11, 0xf9, 0xd0, 0x90, 0x94, 0x9a, 0x34,
	0x58, 0x03, 0x66, 0xbb, 0x04, 0xae, 0xa9, 0x49, 0xf1, 0x43, 0xb4, 0x07, 0x26, 0x64, 0xcc, 0xb5,
	0x11, 0x4a, 0x06, 0xeb, 0x20, 0x68, 0x00, 0xf8, 0xc1, 0x61, 0xf8, 0x1c, 0xb5, 0xac, 0xa6, 0x42,
	0x0a, 0x99, 0x10, 0xad, 0x0a, 0xc9, 0x88, 0x60, 0xc1, 0x06, 0xd8, 0x36, 0x6b, 0x22, 0x2a, 0xf1,
	0x3e, 0xc3, 0x47, 0x68, 0xdb, 0xa4, 0x54, 0x83, 0x64, 0x13, 0x24, 0x5b, 0x10, 0xf7, 0x59, 0xe9,
	0x55, 0x17, 0xca, 0x25, 0xb3, 0xe5, 0xbc, 0x6a, 0x10, 0x12, 0x7a, 0x82, 0xf6, 0x93, 0xbc, 0x20,
	0x54, 0xc7, 0xa9, 0xb0, 0x3c, 0xb6, 0x85, 0xe6, 0xc1, 0x36, 0xe8, 0x9a, 0x49, 0x5e, 0x5c, 0x2e,
	0xc0, 0xb8, 0x8b, 0x0e, 0x4c, 0x31, 0xc8, 0x84, 0xb5, 0x9c, 0x11, 0x6a, 0x49, 0xca, 0x45, 0x92,
	0xda, 0x60, 0xa7, 0xed, 0x75, 0xd6, 0xa2, 0xd6, 0x9c, 0xba, 0xb4, 0xd7, 0x40, 0xe0, 0xff, 0xd1,
	0xa6, 0xb1, 0xd4, 0x16, 0x26, 0x40, 0x70, 0x61, 0x15, 0xe1, 0xc7, 0xa8, 0xe9, 0x6a, 0x10, 0x2b,
	0x39, 0x14, 0x49, 0x99, 0xf9, 0x2e, 0x64, 0xee, 0x4a, 0xf3, 0x1a, 0xd0, 0x3e, 0xc3, 0x57, 0xa8,
	0xc9, 0x65, 0xac, 0x27, 0xb9, 0x15, 0x4a, 0x12, 0x3b, 0xc9, 0x79, 0xd0, 0x68, 0x7b, 0x1d, 0xff,
	0x59, 0xd8, 0x5d, 0x6e, 0x78, 0xf7, 0xcd, 0x5c, 0xf6, 0x7e, 0x92, 0xf3, 0xc8, 0xe7, 0x4b, 0x31,
	0x7e, 0x89, 0x4e, 0x2a, 0x64, 0x61, 0x76, 0xc8, 0x5d, 0x93, 0xf6, 0x20, 0xbd, 0xa3, 0xb9, 0xa6,
	0x6e, 0x78, 0xbf, 0xee, 0xda, 0x19, 0xf2, 0x63, 0x25, 0x2d, 0x2d, 0xfb, 0xeb, 0x8e, 0xf8, 0x70,
	0x64, 0x6f, 0x8e, 0x82, 0xac, 0x87, 0x0e, 0xee, 0x64, 0x46, 0x24, 0x92, 0x42, 0x39, 0x9b, 0x6d,
	0xaf, 0xd3, 0x88, 0xf0, 0x9c, 0xba, 0xa9, 0x19, 0x7c, 0x8a, 0x76, 0x93, 0x91, 0x1a, 0xd0, 0x11,
	0x31, 0x9c, 0xb3, 0x60, 0x1f, 0xaa, 0x80, 0x1c, 0x74, 0xc3, 0x39, 0xc3, 0xf7, 0x51, 0x23, 0x1e,
	0x51, 0x91, 0x71, 0x46, 0x46, 0xca, 0x98, 0xa0, 0x05, 0xb6, 0xbb, 0x15, 0xf6, 0x56, 0x19, 0x83,
	0x2f, 0xd0, 0x7f, 0xb9, 0xd2, 0x3c, 0x27, 0xb9, 0x56, 0x6a, 0xb8, 0xf0, 0x2a, 0x0c, 0x5a, 0x0c,
	0xe4, 0xbb, 0x92, 0xab, 0x9f, 0xf3, 0xe2, 0xec, 0xf7, 0xd7, 0x53, 0xef, 0xf3, 0xaf, 0x6f, 0xe7,
	0x27, 0x6e, 0xf2, 0x3f, 0x55, 0x3f, 0x60, 0x79, 0xdc, 0x5f, 0x3d, 0xfd, 0x3e, 0x0d, 0xbd, 0xdb,
	0x69, 0xe8, 0xfd, 0x9c, 0x86, 0xde, 0x97, 0x59, 0xb8, 0x72, 0x3b, 0x0b, 0x57, 0x7e, 0xcc, 0xc2,
	0x95, 0x8f, 0x07, 0xcb, 0xe7, 0xca, 0xd6, 0x98, 0xc1, 0x26, 0xfc, 0x9b, 0xe7, 0x7f, 0x03, 0x00,
	0x00, 0xff, 0xff, 0x60, 0x84, 0xa2, 0xe8, 0xb4, 0x03, 0x00, 0x00,
}

func (this *StoredGradient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StoredGradient)
	if !ok {
		that2, ok := that.(StoredGradient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Miner != that1.Miner {
		return false
	}
	if this.IpfsHash != that1.IpfsHash {
		return false
	}
	if this.ModelVersion != that1.ModelVersion {
		return false
	}
	if this.TrainingRoundId != that1.TrainingRoundId {
		return false
	}
	if this.ShardId != that1.ShardId {
		return false
	}
	if this.GradientHash != that1.GradientHash {
		return false
	}
	if this.GpuArchitecture != that1.GpuArchitecture {
		return false
	}
	if this.SubmittedAtHeight != that1.SubmittedAtHeight {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.ModelConfigId != that1.ModelConfigId {
		return false
	}
	if this.EncryptionType != that1.EncryptionType {
		return false
	}
	if this.EncryptedGradientIpfsHash != that1.EncryptedGradientIpfsHash {
		return false
	}
	if this.ContainerHash != that1.ContainerHash {
		return false
	}
	if !bytes.Equal(this.ContainerSignature, that1.ContainerSignature) {
		return false
	}
	if this.GlobalSeed != that1.GlobalSeed {
		return false
	}
	if this.ClaimedLoss != that1.ClaimedLoss {
		return false
	}
	if this.PorepProofIpfsHash != that1.PorepProofIpfsHash {
		return false
	}
	return true
}
func (m *StoredGradient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoredGradient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoredGradient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PorepProofIpfsHash) > 0 {
		i -= len(m.PorepProofIpfsHash)
		copy(dAtA[i:], m.PorepProofIpfsHash)
		i = encodeVarintStoredGradient(dAtA, i, uint64(len(m.PorepProofIpfsHash)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.ClaimedLoss) > 0 {
		i -= len(m.ClaimedLoss)
		copy(dAtA[i:], m.ClaimedLoss)
		i = encodeVarintStoredGradient(dAtA, i, uint64(len(m.ClaimedLoss)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.GlobalSeed != 0 {
		i = encodeVarintStoredGradient(dAtA, i, uint64(m.GlobalSeed))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.ContainerSignature) > 0 {
		i -= len(m.ContainerSignature)
		copy(dAtA[i:], m.ContainerSignature)
		i = encodeVarintStoredGradient(dAtA, i, uint64(len(m.ContainerSignature)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.ContainerHash) > 0 {
		i -= len(m.ContainerHash)
		copy(dAtA[i:], m.ContainerHash)
		i = encodeVarintStoredGradient(dAtA, i, uint64(len(m.ContainerHash)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.EncryptedGradientIpfsHash) > 0 {
		i -= len(m.EncryptedGradientIpfsHash)
		copy(dAtA[i:], m.EncryptedGradientIpfsHash)
		i = encodeVarintStoredGradient(dAtA, i, uint64(len(m.EncryptedGradientIpfsHash)))
		i--
		dAtA[i] = 0x6a
	}
	if m.EncryptionType != 0 {
		i = encodeVarintStoredGradient(dAtA, i, uint64(m.EncryptionType))
		i--
		dAtA[i] = 0x60
	}
	if m.ModelConfigId != 0 {
		i = encodeVarintStoredGradient(dAtA, i, uint64(m.ModelConfigId))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintStoredGradient(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x52
	}
	if m.SubmittedAtHeight != 0 {
		i = encodeVarintStoredGradient(dAtA, i, uint64(m.SubmittedAtHeight))
		i--
		dAtA[i] = 0x48
	}
	if len(m.GpuArchitecture) > 0 {
		i -= len(m.GpuArchitecture)
		copy(dAtA[i:], m.GpuArchitecture)
		i = encodeVarintStoredGradient(dAtA, i, uint64(len(m.GpuArchitecture)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.GradientHash) > 0 {
		i -= len(m.GradientHash)
		copy(dAtA[i:], m.GradientHash)
		i = encodeVarintStoredGradient(dAtA, i, uint64(len(m.GradientHash)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ShardId != 0 {
		i = encodeVarintStoredGradient(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x30
	}
	if m.TrainingRoundId != 0 {
		i = encodeVarintStoredGradient(dAtA, i, uint64(m.TrainingRoundId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintStoredGradient(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IpfsHash) > 0 {
		i -= len(m.IpfsHash)
		copy(dAtA[i:], m.IpfsHash)
		i = encodeVarintStoredGradient(dAtA, i, uint64(len(m.IpfsHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Miner) > 0 {
		i -= len(m.Miner)
		copy(dAtA[i:], m.Miner)
		i = encodeVarintStoredGradient(dAtA, i, uint64(len(m.Miner)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintStoredGradient(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintStoredGradient(dAtA []byte, offset int, v uint64) int {
	offset -= sovStoredGradient(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StoredGradient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStoredGradient(uint64(m.Id))
	}
	l = len(m.Miner)
	if l > 0 {
		n += 1 + l + sovStoredGradient(uint64(l))
	}
	l = len(m.IpfsHash)
	if l > 0 {
		n += 1 + l + sovStoredGradient(uint64(l))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovStoredGradient(uint64(l))
	}
	if m.TrainingRoundId != 0 {
		n += 1 + sovStoredGradient(uint64(m.TrainingRoundId))
	}
	if m.ShardId != 0 {
		n += 1 + sovStoredGradient(uint64(m.ShardId))
	}
	l = len(m.GradientHash)
	if l > 0 {
		n += 1 + l + sovStoredGradient(uint64(l))
	}
	l = len(m.GpuArchitecture)
	if l > 0 {
		n += 1 + l + sovStoredGradient(uint64(l))
	}
	if m.SubmittedAtHeight != 0 {
		n += 1 + sovStoredGradient(uint64(m.SubmittedAtHeight))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovStoredGradient(uint64(l))
	}
	if m.ModelConfigId != 0 {
		n += 1 + sovStoredGradient(uint64(m.ModelConfigId))
	}
	if m.EncryptionType != 0 {
		n += 1 + sovStoredGradient(uint64(m.EncryptionType))
	}
	l = len(m.EncryptedGradientIpfsHash)
	if l > 0 {
		n += 1 + l + sovStoredGradient(uint64(l))
	}
	l = len(m.ContainerHash)
	if l > 0 {
		n += 1 + l + sovStoredGradient(uint64(l))
	}
	l = len(m.ContainerSignature)
	if l > 0 {
		n += 1 + l + sovStoredGradient(uint64(l))
	}
	if m.GlobalSeed != 0 {
		n += 2 + sovStoredGradient(uint64(m.GlobalSeed))
	}
	l = len(m.ClaimedLoss)
	if l > 0 {
		n += 2 + l + sovStoredGradient(uint64(l))
	}
	l = len(m.PorepProofIpfsHash)
	if l > 0 {
		n += 2 + l + sovStoredGradient(uint64(l))
	}
	return n
}

func sovStoredGradient(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStoredGradient(x uint64) (n int) {
	return sovStoredGradient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StoredGradient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStoredGradient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoredGradient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoredGradient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStoredGradient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStoredGradient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Miner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStoredGradient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStoredGradient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStoredGradient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStoredGradient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingRoundId", wireType)
			}
			m.TrainingRoundId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainingRoundId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GradientHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStoredGradient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStoredGradient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GradientHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuArchitecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStoredGradient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStoredGradient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuArchitecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAtHeight", wireType)
			}
			m.SubmittedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStoredGradient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStoredGradient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelConfigId", wireType)
			}
			m.ModelConfigId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelConfigId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionType", wireType)
			}
			m.EncryptionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncryptionType |= EncryptionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedGradientIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStoredGradient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStoredGradient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedGradientIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStoredGradient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStoredGradient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStoredGradient
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStoredGradient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerSignature = append(m.ContainerSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.ContainerSignature == nil {
				m.ContainerSignature = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalSeed", wireType)
			}
			m.GlobalSeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalSeed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedLoss", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStoredGradient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStoredGradient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimedLoss = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PorepProofIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStoredGradient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStoredGradient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PorepProofIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStoredGradient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStoredGradient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStoredGradient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStoredGradient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStoredGradient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStoredGradient
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStoredGradient
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStoredGradient
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStoredGradient        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStoredGradient          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStoredGradient = fmt.Errorf("proto: unexpected end of group")
)
