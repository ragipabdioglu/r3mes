// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: remes/remes/v1/trap_job.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TrapJob represents a trap job for lazy mining detection
type TrapJob struct {
	// trap_job_id is the unique identifier for this trap job
	TrapJobId string `protobuf:"bytes,1,opt,name=trap_job_id,json=trapJobId,proto3" json:"trap_job_id,omitempty"`
	// target_miner is the address of the miner being tested
	TargetMiner string `protobuf:"bytes,2,opt,name=target_miner,json=targetMiner,proto3" json:"target_miner,omitempty"`
	// dataset_ipfs_hash is the IPFS hash of the trap dataset (obfuscated with dummy data)
	DatasetIpfsHash string `protobuf:"bytes,3,opt,name=dataset_ipfs_hash,json=datasetIpfsHash,proto3" json:"dataset_ipfs_hash,omitempty"`
	// expected_gradient_hash is the known correct gradient hash (from Protocol Oracle)
	ExpectedGradientHash string `protobuf:"bytes,4,opt,name=expected_gradient_hash,json=expectedGradientHash,proto3" json:"expected_gradient_hash,omitempty"`
	// created_at_height is the block height when trap job was created
	CreatedAtHeight int64 `protobuf:"varint,5,opt,name=created_at_height,json=createdAtHeight,proto3" json:"created_at_height,omitempty"`
	// deadline_height is the block height when trap job expires
	DeadlineHeight int64 `protobuf:"varint,6,opt,name=deadline_height,json=deadlineHeight,proto3" json:"deadline_height,omitempty"`
	// status is the trap job status (pending, submitted, verified, failed)
	Status string `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	// submitted_gradient_hash is the gradient hash submitted by miner
	SubmittedGradientHash string `protobuf:"bytes,8,opt,name=submitted_gradient_hash,json=submittedGradientHash,proto3" json:"submitted_gradient_hash,omitempty"`
	// verification_result indicates if the submitted gradient matches expected
	VerificationResult bool `protobuf:"varint,9,opt,name=verification_result,json=verificationResult,proto3" json:"verification_result,omitempty"`
	// is_obfuscated indicates if trap job was obfuscated with dummy data
	IsObfuscated bool `protobuf:"varint,10,opt,name=is_obfuscated,json=isObfuscated,proto3" json:"is_obfuscated,omitempty"`
	// obfuscation_seed is the seed used for dummy data injection
	ObfuscationSeed uint64 `protobuf:"varint,11,opt,name=obfuscation_seed,json=obfuscationSeed,proto3" json:"obfuscation_seed,omitempty"`
	// federated_signers are the top 3 validators who signed this trap job (multi-sig)
	// Replaces single Protocol Oracle for decentralized security
	FederatedSigners []string `protobuf:"bytes,12,rep,name=federated_signers,json=federatedSigners,proto3" json:"federated_signers,omitempty"`
	// federated_signatures are the signatures from federated validators (2/3 threshold required)
	FederatedSignatures [][]byte `protobuf:"bytes,13,rep,name=federated_signatures,json=federatedSignatures,proto3" json:"federated_signatures,omitempty"`
	// created_by indicates who created this trap job ("federated_validators" or "protocol_oracle" for legacy)
	CreatedBy string `protobuf:"bytes,14,opt,name=created_by,json=createdBy,proto3" json:"created_by,omitempty"`
	// blinding_factor is the random factor used to obfuscate the expected gradient hash
	// This prevents miners from detecting trap jobs by comparing hashes
	BlindingFactor string `protobuf:"bytes,15,opt,name=blinding_factor,json=blindingFactor,proto3" json:"blinding_factor,omitempty"`
	// is_blinded indicates if this trap job uses blinding factor obfuscation
	IsBlinded bool `protobuf:"varint,16,opt,name=is_blinded,json=isBlinded,proto3" json:"is_blinded,omitempty"`
}

func (m *TrapJob) Reset()         { *m = TrapJob{} }
func (m *TrapJob) String() string { return proto.CompactTextString(m) }
func (*TrapJob) ProtoMessage()    {}
func (*TrapJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa25d43cb828e5d3, []int{0}
}
func (m *TrapJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrapJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrapJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrapJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrapJob.Merge(m, src)
}
func (m *TrapJob) XXX_Size() int {
	return m.Size()
}
func (m *TrapJob) XXX_DiscardUnknown() {
	xxx_messageInfo_TrapJob.DiscardUnknown(m)
}

var xxx_messageInfo_TrapJob proto.InternalMessageInfo

func (m *TrapJob) GetTrapJobId() string {
	if m != nil {
		return m.TrapJobId
	}
	return ""
}

func (m *TrapJob) GetTargetMiner() string {
	if m != nil {
		return m.TargetMiner
	}
	return ""
}

func (m *TrapJob) GetDatasetIpfsHash() string {
	if m != nil {
		return m.DatasetIpfsHash
	}
	return ""
}

func (m *TrapJob) GetExpectedGradientHash() string {
	if m != nil {
		return m.ExpectedGradientHash
	}
	return ""
}

func (m *TrapJob) GetCreatedAtHeight() int64 {
	if m != nil {
		return m.CreatedAtHeight
	}
	return 0
}

func (m *TrapJob) GetDeadlineHeight() int64 {
	if m != nil {
		return m.DeadlineHeight
	}
	return 0
}

func (m *TrapJob) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *TrapJob) GetSubmittedGradientHash() string {
	if m != nil {
		return m.SubmittedGradientHash
	}
	return ""
}

func (m *TrapJob) GetVerificationResult() bool {
	if m != nil {
		return m.VerificationResult
	}
	return false
}

func (m *TrapJob) GetIsObfuscated() bool {
	if m != nil {
		return m.IsObfuscated
	}
	return false
}

func (m *TrapJob) GetObfuscationSeed() uint64 {
	if m != nil {
		return m.ObfuscationSeed
	}
	return 0
}

func (m *TrapJob) GetFederatedSigners() []string {
	if m != nil {
		return m.FederatedSigners
	}
	return nil
}

func (m *TrapJob) GetFederatedSignatures() [][]byte {
	if m != nil {
		return m.FederatedSignatures
	}
	return nil
}

func (m *TrapJob) GetCreatedBy() string {
	if m != nil {
		return m.CreatedBy
	}
	return ""
}

func (m *TrapJob) GetBlindingFactor() string {
	if m != nil {
		return m.BlindingFactor
	}
	return ""
}

func (m *TrapJob) GetIsBlinded() bool {
	if m != nil {
		return m.IsBlinded
	}
	return false
}

// TrapJobAppeal represents an appeal for a trap job slashing
type TrapJobAppeal struct {
	// appeal_id is the unique identifier for this appeal
	AppealId string `protobuf:"bytes,1,opt,name=appeal_id,json=appealId,proto3" json:"appeal_id,omitempty"`
	// trap_job_id is the ID of the trap job being appealed
	TrapJobId string `protobuf:"bytes,2,opt,name=trap_job_id,json=trapJobId,proto3" json:"trap_job_id,omitempty"`
	// appellant is the address of the miner appealing
	Appellant string `protobuf:"bytes,3,opt,name=appellant,proto3" json:"appellant,omitempty"`
	// reason is the reason for the appeal
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	// evidence_ipfs_hash is the IPFS hash of evidence supporting the appeal
	EvidenceIpfsHash string `protobuf:"bytes,5,opt,name=evidence_ipfs_hash,json=evidenceIpfsHash,proto3" json:"evidence_ipfs_hash,omitempty"`
	// created_at_height is the block height when appeal was created
	CreatedAtHeight int64 `protobuf:"varint,6,opt,name=created_at_height,json=createdAtHeight,proto3" json:"created_at_height,omitempty"`
	// status is the appeal status (pending, approved, rejected)
	Status string `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	// cpu_verification_result is the result of CPU Iron Sandbox verification
	CpuVerificationResult bool `protobuf:"varint,8,opt,name=cpu_verification_result,json=cpuVerificationResult,proto3" json:"cpu_verification_result,omitempty"`
}

func (m *TrapJobAppeal) Reset()         { *m = TrapJobAppeal{} }
func (m *TrapJobAppeal) String() string { return proto.CompactTextString(m) }
func (*TrapJobAppeal) ProtoMessage()    {}
func (*TrapJobAppeal) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa25d43cb828e5d3, []int{1}
}
func (m *TrapJobAppeal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrapJobAppeal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrapJobAppeal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrapJobAppeal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrapJobAppeal.Merge(m, src)
}
func (m *TrapJobAppeal) XXX_Size() int {
	return m.Size()
}
func (m *TrapJobAppeal) XXX_DiscardUnknown() {
	xxx_messageInfo_TrapJobAppeal.DiscardUnknown(m)
}

var xxx_messageInfo_TrapJobAppeal proto.InternalMessageInfo

func (m *TrapJobAppeal) GetAppealId() string {
	if m != nil {
		return m.AppealId
	}
	return ""
}

func (m *TrapJobAppeal) GetTrapJobId() string {
	if m != nil {
		return m.TrapJobId
	}
	return ""
}

func (m *TrapJobAppeal) GetAppellant() string {
	if m != nil {
		return m.Appellant
	}
	return ""
}

func (m *TrapJobAppeal) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *TrapJobAppeal) GetEvidenceIpfsHash() string {
	if m != nil {
		return m.EvidenceIpfsHash
	}
	return ""
}

func (m *TrapJobAppeal) GetCreatedAtHeight() int64 {
	if m != nil {
		return m.CreatedAtHeight
	}
	return 0
}

func (m *TrapJobAppeal) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *TrapJobAppeal) GetCpuVerificationResult() bool {
	if m != nil {
		return m.CpuVerificationResult
	}
	return false
}

func init() {
	proto.RegisterType((*TrapJob)(nil), "remes.remes.v1.TrapJob")
	proto.RegisterType((*TrapJobAppeal)(nil), "remes.remes.v1.TrapJobAppeal")
}

func init() { proto.RegisterFile("remes/remes/v1/trap_job.proto", fileDescriptor_fa25d43cb828e5d3) }

var fileDescriptor_fa25d43cb828e5d3 = []byte{
	// 611 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0x4d, 0x6f, 0xd3, 0x3e,
	0x1c, 0xc7, 0x97, 0x75, 0xeb, 0x5a, 0xaf, 0x6b, 0x3b, 0xef, 0xe1, 0x6f, 0xed, 0xcf, 0x42, 0x19,
	0x07, 0xca, 0x80, 0x55, 0x13, 0x88, 0xfb, 0x76, 0x80, 0x0d, 0x09, 0x21, 0x65, 0x88, 0x03, 0x97,
	0xc8, 0x89, 0x7f, 0x49, 0x8d, 0xd2, 0xd8, 0xb2, 0x9d, 0x6a, 0x7b, 0x17, 0xdc, 0x79, 0x0b, 0xbc,
	0x10, 0x8e, 0x3b, 0x72, 0x44, 0xdb, 0x1b, 0x41, 0xb1, 0x93, 0xee, 0xa9, 0xe2, 0x12, 0xd9, 0xdf,
	0xef, 0xf7, 0xe7, 0xa7, 0x7c, 0xf4, 0x43, 0xbb, 0x0a, 0x26, 0xa0, 0x47, 0xee, 0x3b, 0x3d, 0x1c,
	0x19, 0x45, 0x65, 0xf8, 0x4d, 0x44, 0x07, 0x52, 0x09, 0x23, 0x70, 0xd7, 0x1a, 0x07, 0xee, 0x3b,
	0x3d, 0xdc, 0xd9, 0x4c, 0x45, 0x2a, 0xac, 0x35, 0x2a, 0x47, 0x2e, 0xb5, 0xf3, 0x38, 0x15, 0x22,
	0xcd, 0x60, 0x64, 0x67, 0x51, 0x91, 0x8c, 0x0c, 0x9f, 0x80, 0x36, 0x74, 0x22, 0x5d, 0x60, 0xef,
	0xc7, 0x32, 0x5a, 0xf9, 0xac, 0xa8, 0xfc, 0x20, 0x22, 0xec, 0xa3, 0xd5, 0x7a, 0x93, 0x90, 0x33,
	0xe2, 0x0d, 0xbc, 0x61, 0x3b, 0x68, 0x1b, 0xe7, 0x9e, 0x32, 0xfc, 0x04, 0x75, 0x0c, 0x55, 0x29,
	0x98, 0x70, 0xc2, 0x73, 0x50, 0x64, 0xd1, 0x06, 0x56, 0x9d, 0xf6, 0xb1, 0x94, 0xf0, 0x3e, 0x5a,
	0x67, 0xd4, 0x50, 0x0d, 0x26, 0xe4, 0x32, 0xd1, 0xe1, 0x98, 0xea, 0x31, 0x69, 0xd8, 0x5c, 0xaf,
	0x32, 0x4e, 0x65, 0xa2, 0x4f, 0xa8, 0x1e, 0xe3, 0x37, 0x68, 0x1b, 0xce, 0x25, 0xc4, 0x06, 0x58,
	0x98, 0x2a, 0xca, 0x38, 0xe4, 0xc6, 0x15, 0x2c, 0xd9, 0x82, 0xcd, 0xda, 0x7d, 0x5f, 0x99, 0xb6,
	0x6a, 0x1f, 0xad, 0xc7, 0x0a, 0x68, 0x59, 0x44, 0x4d, 0x38, 0x06, 0x9e, 0x8e, 0x0d, 0x59, 0x1e,
	0x78, 0xc3, 0x46, 0xd0, 0xab, 0x8c, 0x23, 0x73, 0x62, 0x65, 0xfc, 0x0c, 0xf5, 0x18, 0x50, 0x96,
	0xf1, 0x1c, 0xea, 0x64, 0xd3, 0x26, 0xbb, 0xb5, 0x5c, 0x05, 0xb7, 0x51, 0x53, 0x1b, 0x6a, 0x0a,
	0x4d, 0x56, 0xec, 0xd6, 0xd5, 0x0c, 0xbf, 0x45, 0xff, 0xe9, 0x22, 0x9a, 0x70, 0xf3, 0xf0, 0x8c,
	0x2d, 0x1b, 0xdc, 0x9a, 0xd9, 0x77, 0x0e, 0x39, 0x42, 0x1b, 0x53, 0x50, 0x3c, 0xe1, 0x31, 0x35,
	0x5c, 0xe4, 0xa1, 0x02, 0x5d, 0x64, 0x86, 0xb4, 0x07, 0xde, 0xb0, 0x15, 0xe0, 0xdb, 0x56, 0x60,
	0x1d, 0xfc, 0x14, 0xad, 0x71, 0x1d, 0x8a, 0x28, 0x29, 0x74, 0x5c, 0x5e, 0x81, 0x20, 0x1b, 0xed,
	0x70, 0xfd, 0x69, 0xa6, 0xe1, 0xe7, 0xa8, 0x5f, 0x27, 0xca, 0x45, 0x35, 0x00, 0x23, 0xab, 0x03,
	0x6f, 0xb8, 0x14, 0xf4, 0x6e, 0xe9, 0x67, 0x00, 0x0c, 0xbf, 0x40, 0xeb, 0x09, 0x30, 0x50, 0xf6,
	0x9d, 0x34, 0x4f, 0x73, 0x50, 0x9a, 0x74, 0x06, 0x8d, 0x61, 0x3b, 0xe8, 0xcf, 0x8c, 0x33, 0xa7,
	0xe3, 0x43, 0xb4, 0x79, 0x37, 0x4c, 0x4d, 0xa1, 0x40, 0x93, 0xb5, 0x41, 0x63, 0xd8, 0x09, 0x36,
	0xee, 0xe4, 0x9d, 0x85, 0x77, 0x11, 0xaa, 0xff, 0x42, 0x74, 0x41, 0xba, 0x8e, 0x94, 0x4a, 0x39,
	0xbe, 0x28, 0x1f, 0x3e, 0xca, 0x78, 0xce, 0x78, 0x9e, 0x86, 0x09, 0x8d, 0x8d, 0x50, 0xa4, 0x67,
	0x33, 0xdd, 0x5a, 0x7e, 0x67, 0xd5, 0x72, 0x1d, 0xae, 0x43, 0x2b, 0x02, 0x23, 0x7d, 0x7b, 0xe9,
	0x36, 0xd7, 0xc7, 0x4e, 0xd8, 0xfb, 0xb9, 0x88, 0xd6, 0x2a, 0x3a, 0x8f, 0xa4, 0x04, 0x9a, 0xe1,
	0xff, 0x51, 0x9b, 0xda, 0xd1, 0x0d, 0xa1, 0x2d, 0x27, 0x9c, 0xb2, 0xfb, 0x00, 0x2f, 0xde, 0x07,
	0xf8, 0x91, 0x2b, 0xce, 0x32, 0x9a, 0x9b, 0x8a, 0xca, 0x1b, 0xa1, 0x84, 0x40, 0x01, 0xd5, 0x22,
	0xaf, 0xf8, 0xab, 0x66, 0xf8, 0x25, 0xc2, 0x30, 0xe5, 0x0c, 0xf2, 0x18, 0x6e, 0x41, 0xbd, 0x6c,
	0x33, 0xfd, 0xda, 0x99, 0x51, 0x3d, 0x97, 0xcf, 0xe6, 0x7c, 0x3e, 0xff, 0x81, 0x5d, 0x2c, 0x8b,
	0x70, 0x1e, 0x42, 0x2d, 0xfb, 0x44, 0x5b, 0xb1, 0x2c, 0xbe, 0x3c, 0xa0, 0xe8, 0xf8, 0xd5, 0xaf,
	0x2b, 0xdf, 0xbb, 0xbc, 0xf2, 0xbd, 0x3f, 0x57, 0xbe, 0xf7, 0xfd, 0xda, 0x5f, 0xb8, 0xbc, 0xf6,
	0x17, 0x7e, 0x5f, 0xfb, 0x0b, 0x5f, 0x37, 0x5c, 0x1b, 0x39, 0xaf, 0xda, 0x89, 0xb9, 0x90, 0xa0,
	0xa3, 0xa6, 0x6d, 0x01, 0xaf, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x61, 0x47, 0x61, 0xcd, 0x6a,
	0x04, 0x00, 0x00,
}

func (m *TrapJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrapJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrapJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsBlinded {
		i--
		if m.IsBlinded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.BlindingFactor) > 0 {
		i -= len(m.BlindingFactor)
		copy(dAtA[i:], m.BlindingFactor)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.BlindingFactor)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.CreatedBy) > 0 {
		i -= len(m.CreatedBy)
		copy(dAtA[i:], m.CreatedBy)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.CreatedBy)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.FederatedSignatures) > 0 {
		for iNdEx := len(m.FederatedSignatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FederatedSignatures[iNdEx])
			copy(dAtA[i:], m.FederatedSignatures[iNdEx])
			i = encodeVarintTrapJob(dAtA, i, uint64(len(m.FederatedSignatures[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.FederatedSigners) > 0 {
		for iNdEx := len(m.FederatedSigners) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FederatedSigners[iNdEx])
			copy(dAtA[i:], m.FederatedSigners[iNdEx])
			i = encodeVarintTrapJob(dAtA, i, uint64(len(m.FederatedSigners[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.ObfuscationSeed != 0 {
		i = encodeVarintTrapJob(dAtA, i, uint64(m.ObfuscationSeed))
		i--
		dAtA[i] = 0x58
	}
	if m.IsObfuscated {
		i--
		if m.IsObfuscated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.VerificationResult {
		i--
		if m.VerificationResult {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.SubmittedGradientHash) > 0 {
		i -= len(m.SubmittedGradientHash)
		copy(dAtA[i:], m.SubmittedGradientHash)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.SubmittedGradientHash)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DeadlineHeight != 0 {
		i = encodeVarintTrapJob(dAtA, i, uint64(m.DeadlineHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.CreatedAtHeight != 0 {
		i = encodeVarintTrapJob(dAtA, i, uint64(m.CreatedAtHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ExpectedGradientHash) > 0 {
		i -= len(m.ExpectedGradientHash)
		copy(dAtA[i:], m.ExpectedGradientHash)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.ExpectedGradientHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DatasetIpfsHash) > 0 {
		i -= len(m.DatasetIpfsHash)
		copy(dAtA[i:], m.DatasetIpfsHash)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.DatasetIpfsHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TargetMiner) > 0 {
		i -= len(m.TargetMiner)
		copy(dAtA[i:], m.TargetMiner)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.TargetMiner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TrapJobId) > 0 {
		i -= len(m.TrapJobId)
		copy(dAtA[i:], m.TrapJobId)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.TrapJobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrapJobAppeal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrapJobAppeal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrapJobAppeal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CpuVerificationResult {
		i--
		if m.CpuVerificationResult {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x3a
	}
	if m.CreatedAtHeight != 0 {
		i = encodeVarintTrapJob(dAtA, i, uint64(m.CreatedAtHeight))
		i--
		dAtA[i] = 0x30
	}
	if len(m.EvidenceIpfsHash) > 0 {
		i -= len(m.EvidenceIpfsHash)
		copy(dAtA[i:], m.EvidenceIpfsHash)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.EvidenceIpfsHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Appellant) > 0 {
		i -= len(m.Appellant)
		copy(dAtA[i:], m.Appellant)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.Appellant)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TrapJobId) > 0 {
		i -= len(m.TrapJobId)
		copy(dAtA[i:], m.TrapJobId)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.TrapJobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppealId) > 0 {
		i -= len(m.AppealId)
		copy(dAtA[i:], m.AppealId)
		i = encodeVarintTrapJob(dAtA, i, uint64(len(m.AppealId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTrapJob(dAtA []byte, offset int, v uint64) int {
	offset -= sovTrapJob(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TrapJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TrapJobId)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	l = len(m.TargetMiner)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	l = len(m.DatasetIpfsHash)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	l = len(m.ExpectedGradientHash)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	if m.CreatedAtHeight != 0 {
		n += 1 + sovTrapJob(uint64(m.CreatedAtHeight))
	}
	if m.DeadlineHeight != 0 {
		n += 1 + sovTrapJob(uint64(m.DeadlineHeight))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	l = len(m.SubmittedGradientHash)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	if m.VerificationResult {
		n += 2
	}
	if m.IsObfuscated {
		n += 2
	}
	if m.ObfuscationSeed != 0 {
		n += 1 + sovTrapJob(uint64(m.ObfuscationSeed))
	}
	if len(m.FederatedSigners) > 0 {
		for _, s := range m.FederatedSigners {
			l = len(s)
			n += 1 + l + sovTrapJob(uint64(l))
		}
	}
	if len(m.FederatedSignatures) > 0 {
		for _, b := range m.FederatedSignatures {
			l = len(b)
			n += 1 + l + sovTrapJob(uint64(l))
		}
	}
	l = len(m.CreatedBy)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	l = len(m.BlindingFactor)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	if m.IsBlinded {
		n += 3
	}
	return n
}

func (m *TrapJobAppeal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppealId)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	l = len(m.TrapJobId)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	l = len(m.Appellant)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	l = len(m.EvidenceIpfsHash)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	if m.CreatedAtHeight != 0 {
		n += 1 + sovTrapJob(uint64(m.CreatedAtHeight))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTrapJob(uint64(l))
	}
	if m.CpuVerificationResult {
		n += 2
	}
	return n
}

func sovTrapJob(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTrapJob(x uint64) (n int) {
	return sovTrapJob(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TrapJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrapJob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrapJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrapJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrapJobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrapJobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetMiner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetMiner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedGradientHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedGradientHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAtHeight", wireType)
			}
			m.CreatedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadlineHeight", wireType)
			}
			m.DeadlineHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeadlineHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedGradientHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubmittedGradientHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationResult", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VerificationResult = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsObfuscated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsObfuscated = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObfuscationSeed", wireType)
			}
			m.ObfuscationSeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObfuscationSeed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FederatedSigners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FederatedSigners = append(m.FederatedSigners, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FederatedSignatures", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FederatedSignatures = append(m.FederatedSignatures, make([]byte, postIndex-iNdEx))
			copy(m.FederatedSignatures[len(m.FederatedSignatures)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindingFactor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlindingFactor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBlinded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBlinded = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTrapJob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTrapJob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrapJobAppeal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrapJob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrapJobAppeal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrapJobAppeal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrapJobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrapJobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appellant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Appellant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAtHeight", wireType)
			}
			m.CreatedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrapJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrapJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuVerificationResult", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CpuVerificationResult = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTrapJob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTrapJob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTrapJob(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTrapJob
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTrapJob
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTrapJob
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTrapJob
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTrapJob
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTrapJob        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTrapJob          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTrapJob = fmt.Errorf("proto: unexpected end of group")
)
