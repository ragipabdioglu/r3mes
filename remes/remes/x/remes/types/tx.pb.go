// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: remes/remes/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// params defines the module parameters to update.
	//
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{0}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{1}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

// MsgRegisterModel registers a new model configuration (governance-only)
type MsgRegisterModel struct {
	// authority is the address that controls the module (defaults to x/gov)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// config is the model configuration to register
	Config ModelConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config"`
	// proposal_id is the governance proposal ID that approved this model (0 if direct authority)
	ProposalId uint64 `protobuf:"varint,3,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
}

func (m *MsgRegisterModel) Reset()         { *m = MsgRegisterModel{} }
func (m *MsgRegisterModel) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterModel) ProtoMessage()    {}
func (*MsgRegisterModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{2}
}
func (m *MsgRegisterModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterModel.Merge(m, src)
}
func (m *MsgRegisterModel) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterModel) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterModel.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterModel proto.InternalMessageInfo

func (m *MsgRegisterModel) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgRegisterModel) GetConfig() ModelConfig {
	if m != nil {
		return m.Config
	}
	return ModelConfig{}
}

func (m *MsgRegisterModel) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

// MsgRegisterModelResponse defines the response structure for RegisterModel
type MsgRegisterModelResponse struct {
	// model_id is the unique identifier for the registered model
	ModelId uint64 `protobuf:"varint,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
}

func (m *MsgRegisterModelResponse) Reset()         { *m = MsgRegisterModelResponse{} }
func (m *MsgRegisterModelResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterModelResponse) ProtoMessage()    {}
func (*MsgRegisterModelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{3}
}
func (m *MsgRegisterModelResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterModelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterModelResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterModelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterModelResponse.Merge(m, src)
}
func (m *MsgRegisterModelResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterModelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterModelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterModelResponse proto.InternalMessageInfo

func (m *MsgRegisterModelResponse) GetModelId() uint64 {
	if m != nil {
		return m.ModelId
	}
	return 0
}

// MsgActivateModel activates a model for training (governance-only)
type MsgActivateModel struct {
	// authority is the address that controls the module (defaults to x/gov)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// model_id is the ID of the model to activate
	ModelId uint64 `protobuf:"varint,2,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
}

func (m *MsgActivateModel) Reset()         { *m = MsgActivateModel{} }
func (m *MsgActivateModel) String() string { return proto.CompactTextString(m) }
func (*MsgActivateModel) ProtoMessage()    {}
func (*MsgActivateModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{4}
}
func (m *MsgActivateModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateModel.Merge(m, src)
}
func (m *MsgActivateModel) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateModel) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateModel.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateModel proto.InternalMessageInfo

func (m *MsgActivateModel) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgActivateModel) GetModelId() uint64 {
	if m != nil {
		return m.ModelId
	}
	return 0
}

// MsgActivateModelResponse defines the response structure for ActivateModel
type MsgActivateModelResponse struct {
}

func (m *MsgActivateModelResponse) Reset()         { *m = MsgActivateModelResponse{} }
func (m *MsgActivateModelResponse) String() string { return proto.CompactTextString(m) }
func (*MsgActivateModelResponse) ProtoMessage()    {}
func (*MsgActivateModelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{5}
}
func (m *MsgActivateModelResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateModelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateModelResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateModelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateModelResponse.Merge(m, src)
}
func (m *MsgActivateModelResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateModelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateModelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateModelResponse proto.InternalMessageInfo

// MsgSubmitGradient submits a gradient update with IPFS hash
// IMPORTANT: Only IPFS hash + metadata is stored on-chain, NOT gradient data
// Python miner uploads gradient data directly to IPFS before sending this message
type MsgSubmitGradient struct {
	// miner is the address of the miner submitting the gradient
	Miner string `protobuf:"bytes,1,opt,name=miner,proto3" json:"miner,omitempty"`
	// ipfs_hash is the IPFS content hash of the gradient data (LoRA adapter gradients, MB scale)
	IpfsHash string `protobuf:"bytes,2,opt,name=ipfs_hash,json=ipfsHash,proto3" json:"ipfs_hash,omitempty"`
	// model_version is the version of the model used for training
	ModelVersion string `protobuf:"bytes,3,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
	// training_round_id is the identifier for the training round
	TrainingRoundId uint64 `protobuf:"varint,4,opt,name=training_round_id,json=trainingRoundId,proto3" json:"training_round_id,omitempty"`
	// shard_id is the deterministic shard assignment for this miner
	ShardId uint64 `protobuf:"varint,5,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	// gradient_hash is the deterministic hash of the gradient for verification
	GradientHash string `protobuf:"bytes,6,opt,name=gradient_hash,json=gradientHash,proto3" json:"gradient_hash,omitempty"`
	// gpu_architecture is the GPU architecture used (Ampere, Ada, Blackwell, etc.)
	GpuArchitecture string `protobuf:"bytes,7,opt,name=gpu_architecture,json=gpuArchitecture,proto3" json:"gpu_architecture,omitempty"`
	// nonce is a unique identifier to prevent replay attacks
	Nonce uint64 `protobuf:"varint,8,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// signature is the cryptographic signature of the message
	Signature []byte `protobuf:"bytes,9,opt,name=signature,proto3" json:"signature,omitempty"`
	// proof_of_work_nonce is the nonce used for proof-of-work (anti-spam)
	ProofOfWorkNonce uint64 `protobuf:"varint,10,opt,name=proof_of_work_nonce,json=proofOfWorkNonce,proto3" json:"proof_of_work_nonce,omitempty"`
	// model_config_id references the ModelRegistry entry (0 = legacy BitNet)
	// Default: 0 (backward compatibility with legacy model_version field)
	ModelConfigId uint64 `protobuf:"varint,11,opt,name=model_config_id,json=modelConfigId,proto3" json:"model_config_id,omitempty"`
	// container_hash is the Docker/OCI image hash used for training
	ContainerHash string `protobuf:"bytes,12,opt,name=container_hash,json=containerHash,proto3" json:"container_hash,omitempty"`
	// container_signature is the cryptographic signature of the container
	ContainerSignature []byte `protobuf:"bytes,13,opt,name=container_signature,json=containerSignature,proto3" json:"container_signature,omitempty"`
	// global_seed is the deterministic seed used for training (derived from block hash + training round)
	GlobalSeed uint64 `protobuf:"varint,14,opt,name=global_seed,json=globalSeed,proto3" json:"global_seed,omitempty"`
	// claimed_loss is the loss value claimed by the miner (BitNet integer format)
	// Used for Loss-Based Spot Checking in Layer 2 verification
	ClaimedLoss string `protobuf:"bytes,15,opt,name=claimed_loss,json=claimedLoss,proto3" json:"claimed_loss,omitempty"`
	// porep_proof_ipfs_hash is the IPFS hash of the Proof of Replication (PoRep) proof
	// PoRep proves that the miner actually stores the gradient data, not just the hash
	// This is required to prevent data withholding attacks
	PorepProofIpfsHash string `protobuf:"bytes,16,opt,name=porep_proof_ipfs_hash,json=porepProofIpfsHash,proto3" json:"porep_proof_ipfs_hash,omitempty"`
}

func (m *MsgSubmitGradient) Reset()         { *m = MsgSubmitGradient{} }
func (m *MsgSubmitGradient) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitGradient) ProtoMessage()    {}
func (*MsgSubmitGradient) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{6}
}
func (m *MsgSubmitGradient) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitGradient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitGradient.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitGradient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitGradient.Merge(m, src)
}
func (m *MsgSubmitGradient) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitGradient) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitGradient.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitGradient proto.InternalMessageInfo

func (m *MsgSubmitGradient) GetMiner() string {
	if m != nil {
		return m.Miner
	}
	return ""
}

func (m *MsgSubmitGradient) GetIpfsHash() string {
	if m != nil {
		return m.IpfsHash
	}
	return ""
}

func (m *MsgSubmitGradient) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

func (m *MsgSubmitGradient) GetTrainingRoundId() uint64 {
	if m != nil {
		return m.TrainingRoundId
	}
	return 0
}

func (m *MsgSubmitGradient) GetShardId() uint64 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *MsgSubmitGradient) GetGradientHash() string {
	if m != nil {
		return m.GradientHash
	}
	return ""
}

func (m *MsgSubmitGradient) GetGpuArchitecture() string {
	if m != nil {
		return m.GpuArchitecture
	}
	return ""
}

func (m *MsgSubmitGradient) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *MsgSubmitGradient) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *MsgSubmitGradient) GetProofOfWorkNonce() uint64 {
	if m != nil {
		return m.ProofOfWorkNonce
	}
	return 0
}

func (m *MsgSubmitGradient) GetModelConfigId() uint64 {
	if m != nil {
		return m.ModelConfigId
	}
	return 0
}

func (m *MsgSubmitGradient) GetContainerHash() string {
	if m != nil {
		return m.ContainerHash
	}
	return ""
}

func (m *MsgSubmitGradient) GetContainerSignature() []byte {
	if m != nil {
		return m.ContainerSignature
	}
	return nil
}

func (m *MsgSubmitGradient) GetGlobalSeed() uint64 {
	if m != nil {
		return m.GlobalSeed
	}
	return 0
}

func (m *MsgSubmitGradient) GetClaimedLoss() string {
	if m != nil {
		return m.ClaimedLoss
	}
	return ""
}

func (m *MsgSubmitGradient) GetPorepProofIpfsHash() string {
	if m != nil {
		return m.PorepProofIpfsHash
	}
	return ""
}

// MsgSubmitGradientResponse defines the response structure for SubmitGradient
type MsgSubmitGradientResponse struct {
	// stored_gradient_id is the unique identifier for the stored gradient
	StoredGradientId uint64 `protobuf:"varint,1,opt,name=stored_gradient_id,json=storedGradientId,proto3" json:"stored_gradient_id,omitempty"`
	// tx_hash is the transaction hash (hex encoded)
	// This is calculated from the transaction bytes in the SDK context
	TxHash string `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
}

func (m *MsgSubmitGradientResponse) Reset()         { *m = MsgSubmitGradientResponse{} }
func (m *MsgSubmitGradientResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitGradientResponse) ProtoMessage()    {}
func (*MsgSubmitGradientResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{7}
}
func (m *MsgSubmitGradientResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitGradientResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitGradientResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitGradientResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitGradientResponse.Merge(m, src)
}
func (m *MsgSubmitGradientResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitGradientResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitGradientResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitGradientResponse proto.InternalMessageInfo

func (m *MsgSubmitGradientResponse) GetStoredGradientId() uint64 {
	if m != nil {
		return m.StoredGradientId
	}
	return 0
}

func (m *MsgSubmitGradientResponse) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

// MsgSubmitAggregation submits aggregated gradient results
type MsgSubmitAggregation struct {
	// proposer is the address of the proposer node performing aggregation
	Proposer string `protobuf:"bytes,1,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// aggregated_gradient_ipfs_hash is the IPFS hash of the aggregated gradient result
	AggregatedGradientIpfsHash string `protobuf:"bytes,2,opt,name=aggregated_gradient_ipfs_hash,json=aggregatedGradientIpfsHash,proto3" json:"aggregated_gradient_ipfs_hash,omitempty"`
	// merkle_root is the Merkle root hash of all included gradients
	MerkleRoot string `protobuf:"bytes,3,opt,name=merkle_root,json=merkleRoot,proto3" json:"merkle_root,omitempty"`
	// participant_gradient_ids are the IDs of all gradients included in aggregation
	ParticipantGradientIds []uint64 `protobuf:"varint,4,rep,packed,name=participant_gradient_ids,json=participantGradientIds,proto3" json:"participant_gradient_ids,omitempty"`
	// training_round_id is the identifier for the training round
	TrainingRoundId uint64 `protobuf:"varint,5,opt,name=training_round_id,json=trainingRoundId,proto3" json:"training_round_id,omitempty"`
	// model_version is the version of the model used
	ModelVersion string `protobuf:"bytes,6,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
}

func (m *MsgSubmitAggregation) Reset()         { *m = MsgSubmitAggregation{} }
func (m *MsgSubmitAggregation) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitAggregation) ProtoMessage()    {}
func (*MsgSubmitAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{8}
}
func (m *MsgSubmitAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitAggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitAggregation.Merge(m, src)
}
func (m *MsgSubmitAggregation) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitAggregation proto.InternalMessageInfo

func (m *MsgSubmitAggregation) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *MsgSubmitAggregation) GetAggregatedGradientIpfsHash() string {
	if m != nil {
		return m.AggregatedGradientIpfsHash
	}
	return ""
}

func (m *MsgSubmitAggregation) GetMerkleRoot() string {
	if m != nil {
		return m.MerkleRoot
	}
	return ""
}

func (m *MsgSubmitAggregation) GetParticipantGradientIds() []uint64 {
	if m != nil {
		return m.ParticipantGradientIds
	}
	return nil
}

func (m *MsgSubmitAggregation) GetTrainingRoundId() uint64 {
	if m != nil {
		return m.TrainingRoundId
	}
	return 0
}

func (m *MsgSubmitAggregation) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

// MsgSubmitAggregationResponse defines the response structure for SubmitAggregation
type MsgSubmitAggregationResponse struct {
	// aggregation_id is the unique identifier for the aggregation record
	AggregationId uint64 `protobuf:"varint,1,opt,name=aggregation_id,json=aggregationId,proto3" json:"aggregation_id,omitempty"`
}

func (m *MsgSubmitAggregationResponse) Reset()         { *m = MsgSubmitAggregationResponse{} }
func (m *MsgSubmitAggregationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitAggregationResponse) ProtoMessage()    {}
func (*MsgSubmitAggregationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{9}
}
func (m *MsgSubmitAggregationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitAggregationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitAggregationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitAggregationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitAggregationResponse.Merge(m, src)
}
func (m *MsgSubmitAggregationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitAggregationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitAggregationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitAggregationResponse proto.InternalMessageInfo

func (m *MsgSubmitAggregationResponse) GetAggregationId() uint64 {
	if m != nil {
		return m.AggregationId
	}
	return 0
}

// MsgCommitAggregation commits to an aggregation result (commit-reveal scheme)
// Proposers first commit to a hash of their aggregation result to prevent collusion
type MsgCommitAggregation struct {
	// proposer is the address of the proposer node
	Proposer string `protobuf:"bytes,1,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// commitment_hash is the hash of (aggregated_hash + merkle_root + participant_ids + salt)
	CommitmentHash string `protobuf:"bytes,2,opt,name=commitment_hash,json=commitmentHash,proto3" json:"commitment_hash,omitempty"`
	// training_round_id is the identifier for the training round
	TrainingRoundId uint64 `protobuf:"varint,3,opt,name=training_round_id,json=trainingRoundId,proto3" json:"training_round_id,omitempty"`
	// participant_gradient_ids are the IDs of all gradients included in aggregation
	ParticipantGradientIds []uint64 `protobuf:"varint,4,rep,packed,name=participant_gradient_ids,json=participantGradientIds,proto3" json:"participant_gradient_ids,omitempty"`
}

func (m *MsgCommitAggregation) Reset()         { *m = MsgCommitAggregation{} }
func (m *MsgCommitAggregation) String() string { return proto.CompactTextString(m) }
func (*MsgCommitAggregation) ProtoMessage()    {}
func (*MsgCommitAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{10}
}
func (m *MsgCommitAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCommitAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCommitAggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCommitAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCommitAggregation.Merge(m, src)
}
func (m *MsgCommitAggregation) XXX_Size() int {
	return m.Size()
}
func (m *MsgCommitAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCommitAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCommitAggregation proto.InternalMessageInfo

func (m *MsgCommitAggregation) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *MsgCommitAggregation) GetCommitmentHash() string {
	if m != nil {
		return m.CommitmentHash
	}
	return ""
}

func (m *MsgCommitAggregation) GetTrainingRoundId() uint64 {
	if m != nil {
		return m.TrainingRoundId
	}
	return 0
}

func (m *MsgCommitAggregation) GetParticipantGradientIds() []uint64 {
	if m != nil {
		return m.ParticipantGradientIds
	}
	return nil
}

// MsgCommitAggregationResponse defines the response structure for CommitAggregation
type MsgCommitAggregationResponse struct {
	// commitment_id is the unique identifier for the commitment
	CommitmentId uint64 `protobuf:"varint,1,opt,name=commitment_id,json=commitmentId,proto3" json:"commitment_id,omitempty"`
	// reveal_deadline_height is the block height when reveal period starts
	RevealDeadlineHeight int64 `protobuf:"varint,2,opt,name=reveal_deadline_height,json=revealDeadlineHeight,proto3" json:"reveal_deadline_height,omitempty"`
}

func (m *MsgCommitAggregationResponse) Reset()         { *m = MsgCommitAggregationResponse{} }
func (m *MsgCommitAggregationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCommitAggregationResponse) ProtoMessage()    {}
func (*MsgCommitAggregationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{11}
}
func (m *MsgCommitAggregationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCommitAggregationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCommitAggregationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCommitAggregationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCommitAggregationResponse.Merge(m, src)
}
func (m *MsgCommitAggregationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCommitAggregationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCommitAggregationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCommitAggregationResponse proto.InternalMessageInfo

func (m *MsgCommitAggregationResponse) GetCommitmentId() uint64 {
	if m != nil {
		return m.CommitmentId
	}
	return 0
}

func (m *MsgCommitAggregationResponse) GetRevealDeadlineHeight() int64 {
	if m != nil {
		return m.RevealDeadlineHeight
	}
	return 0
}

// MsgRevealAggregation reveals the aggregation result and verifies commitment
type MsgRevealAggregation struct {
	// proposer is the address of the proposer node
	Proposer string `protobuf:"bytes,1,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// commitment_id is the ID of the commitment to reveal
	CommitmentId uint64 `protobuf:"varint,2,opt,name=commitment_id,json=commitmentId,proto3" json:"commitment_id,omitempty"`
	// aggregated_gradient_ipfs_hash is the IPFS hash of the aggregated gradient result
	AggregatedGradientIpfsHash string `protobuf:"bytes,3,opt,name=aggregated_gradient_ipfs_hash,json=aggregatedGradientIpfsHash,proto3" json:"aggregated_gradient_ipfs_hash,omitempty"`
	// merkle_root is the Merkle root hash of all included gradients
	MerkleRoot string `protobuf:"bytes,4,opt,name=merkle_root,json=merkleRoot,proto3" json:"merkle_root,omitempty"`
	// participant_gradient_ids are the IDs of all gradients included in aggregation
	ParticipantGradientIds []uint64 `protobuf:"varint,5,rep,packed,name=participant_gradient_ids,json=participantGradientIds,proto3" json:"participant_gradient_ids,omitempty"`
	// training_round_id is the identifier for the training round
	TrainingRoundId uint64 `protobuf:"varint,6,opt,name=training_round_id,json=trainingRoundId,proto3" json:"training_round_id,omitempty"`
	// model_version is the version of the model used
	ModelVersion string `protobuf:"bytes,7,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
	// salt is the random salt used in the commitment (revealed for verification)
	Salt string `protobuf:"bytes,8,opt,name=salt,proto3" json:"salt,omitempty"`
}

func (m *MsgRevealAggregation) Reset()         { *m = MsgRevealAggregation{} }
func (m *MsgRevealAggregation) String() string { return proto.CompactTextString(m) }
func (*MsgRevealAggregation) ProtoMessage()    {}
func (*MsgRevealAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{12}
}
func (m *MsgRevealAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevealAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevealAggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevealAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevealAggregation.Merge(m, src)
}
func (m *MsgRevealAggregation) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevealAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevealAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevealAggregation proto.InternalMessageInfo

func (m *MsgRevealAggregation) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *MsgRevealAggregation) GetCommitmentId() uint64 {
	if m != nil {
		return m.CommitmentId
	}
	return 0
}

func (m *MsgRevealAggregation) GetAggregatedGradientIpfsHash() string {
	if m != nil {
		return m.AggregatedGradientIpfsHash
	}
	return ""
}

func (m *MsgRevealAggregation) GetMerkleRoot() string {
	if m != nil {
		return m.MerkleRoot
	}
	return ""
}

func (m *MsgRevealAggregation) GetParticipantGradientIds() []uint64 {
	if m != nil {
		return m.ParticipantGradientIds
	}
	return nil
}

func (m *MsgRevealAggregation) GetTrainingRoundId() uint64 {
	if m != nil {
		return m.TrainingRoundId
	}
	return 0
}

func (m *MsgRevealAggregation) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

func (m *MsgRevealAggregation) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

// MsgRevealAggregationResponse defines the response structure for RevealAggregation
type MsgRevealAggregationResponse struct {
	// aggregation_id is the unique identifier for the aggregation record
	AggregationId uint64 `protobuf:"varint,1,opt,name=aggregation_id,json=aggregationId,proto3" json:"aggregation_id,omitempty"`
	// commitment_verified indicates if the commitment was successfully verified
	CommitmentVerified bool `protobuf:"varint,2,opt,name=commitment_verified,json=commitmentVerified,proto3" json:"commitment_verified,omitempty"`
}

func (m *MsgRevealAggregationResponse) Reset()         { *m = MsgRevealAggregationResponse{} }
func (m *MsgRevealAggregationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRevealAggregationResponse) ProtoMessage()    {}
func (*MsgRevealAggregationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{13}
}
func (m *MsgRevealAggregationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevealAggregationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevealAggregationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevealAggregationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevealAggregationResponse.Merge(m, src)
}
func (m *MsgRevealAggregationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevealAggregationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevealAggregationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevealAggregationResponse proto.InternalMessageInfo

func (m *MsgRevealAggregationResponse) GetAggregationId() uint64 {
	if m != nil {
		return m.AggregationId
	}
	return 0
}

func (m *MsgRevealAggregationResponse) GetCommitmentVerified() bool {
	if m != nil {
		return m.CommitmentVerified
	}
	return false
}

// MsgChallengeAggregation challenges an aggregation result
type MsgChallengeAggregation struct {
	// challenger is the address of the node challenging the aggregation
	Challenger string `protobuf:"bytes,1,opt,name=challenger,proto3" json:"challenger,omitempty"`
	// aggregation_id is the ID of the aggregation being challenged
	AggregationId uint64 `protobuf:"varint,2,opt,name=aggregation_id,json=aggregationId,proto3" json:"aggregation_id,omitempty"`
	// reason is the reason for the challenge
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// evidence_ipfs_hash is the IPFS hash of evidence supporting the challenge
	EvidenceIpfsHash string `protobuf:"bytes,4,opt,name=evidence_ipfs_hash,json=evidenceIpfsHash,proto3" json:"evidence_ipfs_hash,omitempty"`
	// bond_amount is the bond amount for Layer 2 challenge (10x base reward)
	// Required for high-stakes challenge
	BondAmount []types.Coin `protobuf:"bytes,5,rep,name=bond_amount,json=bondAmount,proto3" json:"bond_amount"`
}

func (m *MsgChallengeAggregation) Reset()         { *m = MsgChallengeAggregation{} }
func (m *MsgChallengeAggregation) String() string { return proto.CompactTextString(m) }
func (*MsgChallengeAggregation) ProtoMessage()    {}
func (*MsgChallengeAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{14}
}
func (m *MsgChallengeAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgChallengeAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgChallengeAggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgChallengeAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgChallengeAggregation.Merge(m, src)
}
func (m *MsgChallengeAggregation) XXX_Size() int {
	return m.Size()
}
func (m *MsgChallengeAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgChallengeAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_MsgChallengeAggregation proto.InternalMessageInfo

func (m *MsgChallengeAggregation) GetChallenger() string {
	if m != nil {
		return m.Challenger
	}
	return ""
}

func (m *MsgChallengeAggregation) GetAggregationId() uint64 {
	if m != nil {
		return m.AggregationId
	}
	return 0
}

func (m *MsgChallengeAggregation) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *MsgChallengeAggregation) GetEvidenceIpfsHash() string {
	if m != nil {
		return m.EvidenceIpfsHash
	}
	return ""
}

func (m *MsgChallengeAggregation) GetBondAmount() []types.Coin {
	if m != nil {
		return m.BondAmount
	}
	return nil
}

// MsgChallengeAggregationResponse defines the response structure for ChallengeAggregation
type MsgChallengeAggregationResponse struct {
	// challenge_id is the unique identifier for the challenge
	ChallengeId uint64 `protobuf:"varint,1,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id,omitempty"`
}

func (m *MsgChallengeAggregationResponse) Reset()         { *m = MsgChallengeAggregationResponse{} }
func (m *MsgChallengeAggregationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgChallengeAggregationResponse) ProtoMessage()    {}
func (*MsgChallengeAggregationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{15}
}
func (m *MsgChallengeAggregationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgChallengeAggregationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgChallengeAggregationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgChallengeAggregationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgChallengeAggregationResponse.Merge(m, src)
}
func (m *MsgChallengeAggregationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgChallengeAggregationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgChallengeAggregationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgChallengeAggregationResponse proto.InternalMessageInfo

func (m *MsgChallengeAggregationResponse) GetChallengeId() uint64 {
	if m != nil {
		return m.ChallengeId
	}
	return 0
}

// MsgProposeDataset proposes a dataset for governance approval
type MsgProposeDataset struct {
	// proposer is the address of the proposer
	Proposer string `protobuf:"bytes,1,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// dataset_ipfs_hash is the IPFS hash of the dataset
	DatasetIpfsHash string `protobuf:"bytes,2,opt,name=dataset_ipfs_hash,json=datasetIpfsHash,proto3" json:"dataset_ipfs_hash,omitempty"`
	// metadata is the dataset metadata
	Metadata DatasetMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata"`
	// deposit is the deposit amount for the proposal
	Deposit string `protobuf:"bytes,4,opt,name=deposit,proto3" json:"deposit,omitempty"`
}

func (m *MsgProposeDataset) Reset()         { *m = MsgProposeDataset{} }
func (m *MsgProposeDataset) String() string { return proto.CompactTextString(m) }
func (*MsgProposeDataset) ProtoMessage()    {}
func (*MsgProposeDataset) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{16}
}
func (m *MsgProposeDataset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposeDataset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposeDataset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposeDataset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposeDataset.Merge(m, src)
}
func (m *MsgProposeDataset) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposeDataset) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposeDataset.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposeDataset proto.InternalMessageInfo

func (m *MsgProposeDataset) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *MsgProposeDataset) GetDatasetIpfsHash() string {
	if m != nil {
		return m.DatasetIpfsHash
	}
	return ""
}

func (m *MsgProposeDataset) GetMetadata() DatasetMetadata {
	if m != nil {
		return m.Metadata
	}
	return DatasetMetadata{}
}

func (m *MsgProposeDataset) GetDeposit() string {
	if m != nil {
		return m.Deposit
	}
	return ""
}

// MsgProposeDatasetResponse defines the response structure for ProposeDataset
type MsgProposeDatasetResponse struct {
	// proposal_id is the unique identifier for the proposal
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
}

func (m *MsgProposeDatasetResponse) Reset()         { *m = MsgProposeDatasetResponse{} }
func (m *MsgProposeDatasetResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProposeDatasetResponse) ProtoMessage()    {}
func (*MsgProposeDatasetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{17}
}
func (m *MsgProposeDatasetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposeDatasetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposeDatasetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposeDatasetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposeDatasetResponse.Merge(m, src)
}
func (m *MsgProposeDatasetResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposeDatasetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposeDatasetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposeDatasetResponse proto.InternalMessageInfo

func (m *MsgProposeDatasetResponse) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

// MsgVoteDataset votes on a dataset proposal
type MsgVoteDataset struct {
	// voter is the address of the voter
	Voter string `protobuf:"bytes,1,opt,name=voter,proto3" json:"voter,omitempty"`
	// proposal_id is the ID of the proposal being voted on
	ProposalId uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// option is the vote option ("yes", "no", "abstain")
	Option string `protobuf:"bytes,3,opt,name=option,proto3" json:"option,omitempty"`
	// quality_score is the quality assessment score (0-100)
	QualityScore uint32 `protobuf:"varint,4,opt,name=quality_score,json=qualityScore,proto3" json:"quality_score,omitempty"`
	// relevance_score is the relevance assessment score (0-100)
	RelevanceScore uint32 `protobuf:"varint,5,opt,name=relevance_score,json=relevanceScore,proto3" json:"relevance_score,omitempty"`
}

func (m *MsgVoteDataset) Reset()         { *m = MsgVoteDataset{} }
func (m *MsgVoteDataset) String() string { return proto.CompactTextString(m) }
func (*MsgVoteDataset) ProtoMessage()    {}
func (*MsgVoteDataset) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{18}
}
func (m *MsgVoteDataset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgVoteDataset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgVoteDataset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgVoteDataset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgVoteDataset.Merge(m, src)
}
func (m *MsgVoteDataset) XXX_Size() int {
	return m.Size()
}
func (m *MsgVoteDataset) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgVoteDataset.DiscardUnknown(m)
}

var xxx_messageInfo_MsgVoteDataset proto.InternalMessageInfo

func (m *MsgVoteDataset) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

func (m *MsgVoteDataset) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *MsgVoteDataset) GetOption() string {
	if m != nil {
		return m.Option
	}
	return ""
}

func (m *MsgVoteDataset) GetQualityScore() uint32 {
	if m != nil {
		return m.QualityScore
	}
	return 0
}

func (m *MsgVoteDataset) GetRelevanceScore() uint32 {
	if m != nil {
		return m.RelevanceScore
	}
	return 0
}

// MsgVoteDatasetResponse defines the response structure for VoteDataset
type MsgVoteDatasetResponse struct {
	// vote_id is the unique identifier for the vote
	VoteId uint64 `protobuf:"varint,1,opt,name=vote_id,json=voteId,proto3" json:"vote_id,omitempty"`
}

func (m *MsgVoteDatasetResponse) Reset()         { *m = MsgVoteDatasetResponse{} }
func (m *MsgVoteDatasetResponse) String() string { return proto.CompactTextString(m) }
func (*MsgVoteDatasetResponse) ProtoMessage()    {}
func (*MsgVoteDatasetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{19}
}
func (m *MsgVoteDatasetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgVoteDatasetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgVoteDatasetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgVoteDatasetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgVoteDatasetResponse.Merge(m, src)
}
func (m *MsgVoteDatasetResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgVoteDatasetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgVoteDatasetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgVoteDatasetResponse proto.InternalMessageInfo

func (m *MsgVoteDatasetResponse) GetVoteId() uint64 {
	if m != nil {
		return m.VoteId
	}
	return 0
}

// MsgMarkDatasetAsOfficial marks an approved dataset as "Official Training Data"
type MsgMarkDatasetAsOfficial struct {
	// authority is the address that controls the module (defaults to x/gov)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// dataset_id is the ID of the approved dataset
	DatasetId uint64 `protobuf:"varint,2,opt,name=dataset_id,json=datasetId,proto3" json:"dataset_id,omitempty"`
}

func (m *MsgMarkDatasetAsOfficial) Reset()         { *m = MsgMarkDatasetAsOfficial{} }
func (m *MsgMarkDatasetAsOfficial) String() string { return proto.CompactTextString(m) }
func (*MsgMarkDatasetAsOfficial) ProtoMessage()    {}
func (*MsgMarkDatasetAsOfficial) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{20}
}
func (m *MsgMarkDatasetAsOfficial) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMarkDatasetAsOfficial) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMarkDatasetAsOfficial.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMarkDatasetAsOfficial) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMarkDatasetAsOfficial.Merge(m, src)
}
func (m *MsgMarkDatasetAsOfficial) XXX_Size() int {
	return m.Size()
}
func (m *MsgMarkDatasetAsOfficial) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMarkDatasetAsOfficial.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMarkDatasetAsOfficial proto.InternalMessageInfo

func (m *MsgMarkDatasetAsOfficial) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgMarkDatasetAsOfficial) GetDatasetId() uint64 {
	if m != nil {
		return m.DatasetId
	}
	return 0
}

// MsgMarkDatasetAsOfficialResponse defines the response structure for MarkDatasetAsOfficial
type MsgMarkDatasetAsOfficialResponse struct {
}

func (m *MsgMarkDatasetAsOfficialResponse) Reset()         { *m = MsgMarkDatasetAsOfficialResponse{} }
func (m *MsgMarkDatasetAsOfficialResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMarkDatasetAsOfficialResponse) ProtoMessage()    {}
func (*MsgMarkDatasetAsOfficialResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{21}
}
func (m *MsgMarkDatasetAsOfficialResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMarkDatasetAsOfficialResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMarkDatasetAsOfficialResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMarkDatasetAsOfficialResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMarkDatasetAsOfficialResponse.Merge(m, src)
}
func (m *MsgMarkDatasetAsOfficialResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMarkDatasetAsOfficialResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMarkDatasetAsOfficialResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMarkDatasetAsOfficialResponse proto.InternalMessageInfo

// MsgRemoveDataset removes an approved dataset from the registry
type MsgRemoveDataset struct {
	// authority is the address that controls the module (defaults to x/gov)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// dataset_id is the ID of the dataset to remove
	DatasetId uint64 `protobuf:"varint,2,opt,name=dataset_id,json=datasetId,proto3" json:"dataset_id,omitempty"`
	// reason is the reason for removal
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgRemoveDataset) Reset()         { *m = MsgRemoveDataset{} }
func (m *MsgRemoveDataset) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveDataset) ProtoMessage()    {}
func (*MsgRemoveDataset) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{22}
}
func (m *MsgRemoveDataset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveDataset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveDataset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveDataset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveDataset.Merge(m, src)
}
func (m *MsgRemoveDataset) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveDataset) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveDataset.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveDataset proto.InternalMessageInfo

func (m *MsgRemoveDataset) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgRemoveDataset) GetDatasetId() uint64 {
	if m != nil {
		return m.DatasetId
	}
	return 0
}

func (m *MsgRemoveDataset) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// MsgRemoveDatasetResponse defines the response structure for RemoveDataset
type MsgRemoveDatasetResponse struct {
}

func (m *MsgRemoveDatasetResponse) Reset()         { *m = MsgRemoveDatasetResponse{} }
func (m *MsgRemoveDatasetResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveDatasetResponse) ProtoMessage()    {}
func (*MsgRemoveDatasetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{23}
}
func (m *MsgRemoveDatasetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveDatasetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveDatasetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveDatasetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveDatasetResponse.Merge(m, src)
}
func (m *MsgRemoveDatasetResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveDatasetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveDatasetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveDatasetResponse proto.InternalMessageInfo

// MsgRegisterNode registers a node with role specification and resource quotas
type MsgRegisterNode struct {
	// node_address is the address of the node
	NodeAddress string `protobuf:"bytes,1,opt,name=node_address,json=nodeAddress,proto3" json:"node_address,omitempty"`
	// node_type is the primary node type
	NodeType NodeType `protobuf:"varint,2,opt,name=node_type,json=nodeType,proto3,enum=remes.remes.v1.NodeType" json:"node_type,omitempty"`
	// resources is the total resource specification
	Resources ResourceSpec `protobuf:"bytes,3,opt,name=resources,proto3" json:"resources"`
	// stake is the staked amount
	Stake string `protobuf:"bytes,4,opt,name=stake,proto3" json:"stake,omitempty"`
	// roles is the list of roles this node can perform (multi-role support)
	Roles []NodeType `protobuf:"varint,5,rep,packed,name=roles,proto3,enum=remes.remes.v1.NodeType" json:"roles,omitempty"`
	// role_allocations maps roles to resource quotas
	RoleAllocations []*RoleAllocation `protobuf:"bytes,6,rep,name=role_allocations,json=roleAllocations,proto3" json:"role_allocations,omitempty"`
	// resource_proof_ipfs_hash is the IPFS hash of the resource allocation proof
	ResourceProofIpfsHash string `protobuf:"bytes,7,opt,name=resource_proof_ipfs_hash,json=resourceProofIpfsHash,proto3" json:"resource_proof_ipfs_hash,omitempty"`
}

func (m *MsgRegisterNode) Reset()         { *m = MsgRegisterNode{} }
func (m *MsgRegisterNode) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterNode) ProtoMessage()    {}
func (*MsgRegisterNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{24}
}
func (m *MsgRegisterNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterNode.Merge(m, src)
}
func (m *MsgRegisterNode) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterNode) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterNode.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterNode proto.InternalMessageInfo

func (m *MsgRegisterNode) GetNodeAddress() string {
	if m != nil {
		return m.NodeAddress
	}
	return ""
}

func (m *MsgRegisterNode) GetNodeType() NodeType {
	if m != nil {
		return m.NodeType
	}
	return NODE_TYPE_UNSPECIFIED
}

func (m *MsgRegisterNode) GetResources() ResourceSpec {
	if m != nil {
		return m.Resources
	}
	return ResourceSpec{}
}

func (m *MsgRegisterNode) GetStake() string {
	if m != nil {
		return m.Stake
	}
	return ""
}

func (m *MsgRegisterNode) GetRoles() []NodeType {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *MsgRegisterNode) GetRoleAllocations() []*RoleAllocation {
	if m != nil {
		return m.RoleAllocations
	}
	return nil
}

func (m *MsgRegisterNode) GetResourceProofIpfsHash() string {
	if m != nil {
		return m.ResourceProofIpfsHash
	}
	return ""
}

// MsgRegisterNodeResponse defines the response structure for RegisterNode
type MsgRegisterNodeResponse struct {
	// registration_id is the unique identifier for the registration
	RegistrationId uint64 `protobuf:"varint,1,opt,name=registration_id,json=registrationId,proto3" json:"registration_id,omitempty"`
}

func (m *MsgRegisterNodeResponse) Reset()         { *m = MsgRegisterNodeResponse{} }
func (m *MsgRegisterNodeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterNodeResponse) ProtoMessage()    {}
func (*MsgRegisterNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{25}
}
func (m *MsgRegisterNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterNodeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterNodeResponse.Merge(m, src)
}
func (m *MsgRegisterNodeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterNodeResponse proto.InternalMessageInfo

func (m *MsgRegisterNodeResponse) GetRegistrationId() uint64 {
	if m != nil {
		return m.RegistrationId
	}
	return 0
}

// MsgUpdateNodeRegistration updates node registration information
type MsgUpdateNodeRegistration struct {
	// node_address is the address of the node
	NodeAddress string `protobuf:"bytes,1,opt,name=node_address,json=nodeAddress,proto3" json:"node_address,omitempty"`
	// resources is the updated resource specification (optional)
	Resources *ResourceSpec `protobuf:"bytes,2,opt,name=resources,proto3" json:"resources,omitempty"`
	// roles is the updated list of roles (optional)
	Roles []NodeType `protobuf:"varint,3,rep,packed,name=roles,proto3,enum=remes.remes.v1.NodeType" json:"roles,omitempty"`
	// role_allocations is the updated role allocations (optional)
	RoleAllocations []*RoleAllocation `protobuf:"bytes,4,rep,name=role_allocations,json=roleAllocations,proto3" json:"role_allocations,omitempty"`
	// resource_proof_ipfs_hash is the updated resource proof IPFS hash (optional)
	ResourceProofIpfsHash string `protobuf:"bytes,5,opt,name=resource_proof_ipfs_hash,json=resourceProofIpfsHash,proto3" json:"resource_proof_ipfs_hash,omitempty"`
}

func (m *MsgUpdateNodeRegistration) Reset()         { *m = MsgUpdateNodeRegistration{} }
func (m *MsgUpdateNodeRegistration) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateNodeRegistration) ProtoMessage()    {}
func (*MsgUpdateNodeRegistration) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{26}
}
func (m *MsgUpdateNodeRegistration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateNodeRegistration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateNodeRegistration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateNodeRegistration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateNodeRegistration.Merge(m, src)
}
func (m *MsgUpdateNodeRegistration) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateNodeRegistration) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateNodeRegistration.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateNodeRegistration proto.InternalMessageInfo

func (m *MsgUpdateNodeRegistration) GetNodeAddress() string {
	if m != nil {
		return m.NodeAddress
	}
	return ""
}

func (m *MsgUpdateNodeRegistration) GetResources() *ResourceSpec {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *MsgUpdateNodeRegistration) GetRoles() []NodeType {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *MsgUpdateNodeRegistration) GetRoleAllocations() []*RoleAllocation {
	if m != nil {
		return m.RoleAllocations
	}
	return nil
}

func (m *MsgUpdateNodeRegistration) GetResourceProofIpfsHash() string {
	if m != nil {
		return m.ResourceProofIpfsHash
	}
	return ""
}

// MsgUpdateNodeRegistrationResponse defines the response structure for UpdateNodeRegistration
type MsgUpdateNodeRegistrationResponse struct {
}

func (m *MsgUpdateNodeRegistrationResponse) Reset()         { *m = MsgUpdateNodeRegistrationResponse{} }
func (m *MsgUpdateNodeRegistrationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateNodeRegistrationResponse) ProtoMessage()    {}
func (*MsgUpdateNodeRegistrationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{27}
}
func (m *MsgUpdateNodeRegistrationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateNodeRegistrationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateNodeRegistrationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateNodeRegistrationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateNodeRegistrationResponse.Merge(m, src)
}
func (m *MsgUpdateNodeRegistrationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateNodeRegistrationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateNodeRegistrationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateNodeRegistrationResponse proto.InternalMessageInfo

// MsgSubmitResourceUsage submits resource usage proof for validation
type MsgSubmitResourceUsage struct {
	// node_address is the address of the node
	NodeAddress string `protobuf:"bytes,1,opt,name=node_address,json=nodeAddress,proto3" json:"node_address,omitempty"`
	// role is the role for which resource usage is being reported
	Role NodeType `protobuf:"varint,2,opt,name=role,proto3,enum=remes.remes.v1.NodeType" json:"role,omitempty"`
	// resource_usage is the actual resource usage
	ResourceUsage ResourceSpec `protobuf:"bytes,3,opt,name=resource_usage,json=resourceUsage,proto3" json:"resource_usage"`
	// proof_ipfs_hash is the IPFS hash of the resource usage proof
	ProofIpfsHash string `protobuf:"bytes,4,opt,name=proof_ipfs_hash,json=proofIpfsHash,proto3" json:"proof_ipfs_hash,omitempty"`
}

func (m *MsgSubmitResourceUsage) Reset()         { *m = MsgSubmitResourceUsage{} }
func (m *MsgSubmitResourceUsage) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitResourceUsage) ProtoMessage()    {}
func (*MsgSubmitResourceUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{28}
}
func (m *MsgSubmitResourceUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitResourceUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitResourceUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitResourceUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitResourceUsage.Merge(m, src)
}
func (m *MsgSubmitResourceUsage) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitResourceUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitResourceUsage.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitResourceUsage proto.InternalMessageInfo

func (m *MsgSubmitResourceUsage) GetNodeAddress() string {
	if m != nil {
		return m.NodeAddress
	}
	return ""
}

func (m *MsgSubmitResourceUsage) GetRole() NodeType {
	if m != nil {
		return m.Role
	}
	return NODE_TYPE_UNSPECIFIED
}

func (m *MsgSubmitResourceUsage) GetResourceUsage() ResourceSpec {
	if m != nil {
		return m.ResourceUsage
	}
	return ResourceSpec{}
}

func (m *MsgSubmitResourceUsage) GetProofIpfsHash() string {
	if m != nil {
		return m.ProofIpfsHash
	}
	return ""
}

// MsgSubmitResourceUsageResponse defines the response structure for SubmitResourceUsage
type MsgSubmitResourceUsageResponse struct {
	// is_valid indicates if the resource usage is valid
	IsValid bool `protobuf:"varint,1,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`
	// violation_detected indicates if a violation was detected
	ViolationDetected bool `protobuf:"varint,2,opt,name=violation_detected,json=violationDetected,proto3" json:"violation_detected,omitempty"`
}

func (m *MsgSubmitResourceUsageResponse) Reset()         { *m = MsgSubmitResourceUsageResponse{} }
func (m *MsgSubmitResourceUsageResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitResourceUsageResponse) ProtoMessage()    {}
func (*MsgSubmitResourceUsageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{29}
}
func (m *MsgSubmitResourceUsageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitResourceUsageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitResourceUsageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitResourceUsageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitResourceUsageResponse.Merge(m, src)
}
func (m *MsgSubmitResourceUsageResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitResourceUsageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitResourceUsageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitResourceUsageResponse proto.InternalMessageInfo

func (m *MsgSubmitResourceUsageResponse) GetIsValid() bool {
	if m != nil {
		return m.IsValid
	}
	return false
}

func (m *MsgSubmitResourceUsageResponse) GetViolationDetected() bool {
	if m != nil {
		return m.ViolationDetected
	}
	return false
}

// MsgCommitPinning commits to pin IPFS content with stake
type MsgCommitPinning struct {
	// node_address is the address of the node committing to pinning
	NodeAddress string `protobuf:"bytes,1,opt,name=node_address,json=nodeAddress,proto3" json:"node_address,omitempty"`
	// ipfs_hash is the IPFS hash of the content to pin
	IpfsHash string `protobuf:"bytes,2,opt,name=ipfs_hash,json=ipfsHash,proto3" json:"ipfs_hash,omitempty"`
	// stake is the staked amount for pinning commitment
	Stake string `protobuf:"bytes,3,opt,name=stake,proto3" json:"stake,omitempty"`
	// commitment_duration_blocks is the duration of commitment in blocks (0 = indefinite)
	CommitmentDurationBlocks uint64 `protobuf:"varint,4,opt,name=commitment_duration_blocks,json=commitmentDurationBlocks,proto3" json:"commitment_duration_blocks,omitempty"`
}

func (m *MsgCommitPinning) Reset()         { *m = MsgCommitPinning{} }
func (m *MsgCommitPinning) String() string { return proto.CompactTextString(m) }
func (*MsgCommitPinning) ProtoMessage()    {}
func (*MsgCommitPinning) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{30}
}
func (m *MsgCommitPinning) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCommitPinning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCommitPinning.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCommitPinning) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCommitPinning.Merge(m, src)
}
func (m *MsgCommitPinning) XXX_Size() int {
	return m.Size()
}
func (m *MsgCommitPinning) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCommitPinning.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCommitPinning proto.InternalMessageInfo

func (m *MsgCommitPinning) GetNodeAddress() string {
	if m != nil {
		return m.NodeAddress
	}
	return ""
}

func (m *MsgCommitPinning) GetIpfsHash() string {
	if m != nil {
		return m.IpfsHash
	}
	return ""
}

func (m *MsgCommitPinning) GetStake() string {
	if m != nil {
		return m.Stake
	}
	return ""
}

func (m *MsgCommitPinning) GetCommitmentDurationBlocks() uint64 {
	if m != nil {
		return m.CommitmentDurationBlocks
	}
	return 0
}

// MsgCommitPinningResponse defines the response structure for CommitPinning
type MsgCommitPinningResponse struct {
	// pinning_id is the unique identifier for the pinning commitment
	PinningId string `protobuf:"bytes,1,opt,name=pinning_id,json=pinningId,proto3" json:"pinning_id,omitempty"`
}

func (m *MsgCommitPinningResponse) Reset()         { *m = MsgCommitPinningResponse{} }
func (m *MsgCommitPinningResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCommitPinningResponse) ProtoMessage()    {}
func (*MsgCommitPinningResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{31}
}
func (m *MsgCommitPinningResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCommitPinningResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCommitPinningResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCommitPinningResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCommitPinningResponse.Merge(m, src)
}
func (m *MsgCommitPinningResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCommitPinningResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCommitPinningResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCommitPinningResponse proto.InternalMessageInfo

func (m *MsgCommitPinningResponse) GetPinningId() string {
	if m != nil {
		return m.PinningId
	}
	return ""
}

// MsgChallengePinning challenges a pinning commitment for data availability verification
type MsgChallengePinning struct {
	// challenger is the address of the challenger
	Challenger string `protobuf:"bytes,1,opt,name=challenger,proto3" json:"challenger,omitempty"`
	// node_address is the address of the node being challenged
	NodeAddress string `protobuf:"bytes,2,opt,name=node_address,json=nodeAddress,proto3" json:"node_address,omitempty"`
	// ipfs_hash is the IPFS hash being challenged
	IpfsHash string `protobuf:"bytes,3,opt,name=ipfs_hash,json=ipfsHash,proto3" json:"ipfs_hash,omitempty"`
}

func (m *MsgChallengePinning) Reset()         { *m = MsgChallengePinning{} }
func (m *MsgChallengePinning) String() string { return proto.CompactTextString(m) }
func (*MsgChallengePinning) ProtoMessage()    {}
func (*MsgChallengePinning) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{32}
}
func (m *MsgChallengePinning) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgChallengePinning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgChallengePinning.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgChallengePinning) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgChallengePinning.Merge(m, src)
}
func (m *MsgChallengePinning) XXX_Size() int {
	return m.Size()
}
func (m *MsgChallengePinning) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgChallengePinning.DiscardUnknown(m)
}

var xxx_messageInfo_MsgChallengePinning proto.InternalMessageInfo

func (m *MsgChallengePinning) GetChallenger() string {
	if m != nil {
		return m.Challenger
	}
	return ""
}

func (m *MsgChallengePinning) GetNodeAddress() string {
	if m != nil {
		return m.NodeAddress
	}
	return ""
}

func (m *MsgChallengePinning) GetIpfsHash() string {
	if m != nil {
		return m.IpfsHash
	}
	return ""
}

// MsgChallengePinningResponse defines the response structure for ChallengePinning
type MsgChallengePinningResponse struct {
	// challenge_id is the unique identifier for the challenge
	ChallengeId uint64 `protobuf:"varint,1,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id,omitempty"`
}

func (m *MsgChallengePinningResponse) Reset()         { *m = MsgChallengePinningResponse{} }
func (m *MsgChallengePinningResponse) String() string { return proto.CompactTextString(m) }
func (*MsgChallengePinningResponse) ProtoMessage()    {}
func (*MsgChallengePinningResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{33}
}
func (m *MsgChallengePinningResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgChallengePinningResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgChallengePinningResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgChallengePinningResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgChallengePinningResponse.Merge(m, src)
}
func (m *MsgChallengePinningResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgChallengePinningResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgChallengePinningResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgChallengePinningResponse proto.InternalMessageInfo

func (m *MsgChallengePinningResponse) GetChallengeId() uint64 {
	if m != nil {
		return m.ChallengeId
	}
	return 0
}

// MsgRespondToChallenge responds to a data availability challenge
type MsgRespondToChallenge struct {
	// node_address is the address of the node responding
	NodeAddress string `protobuf:"bytes,1,opt,name=node_address,json=nodeAddress,proto3" json:"node_address,omitempty"`
	// challenge_id is the ID of the challenge being responded to
	ChallengeId uint64 `protobuf:"varint,2,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id,omitempty"`
	// proof_ipfs_hash is the IPFS hash of the proof data (content retrieval proof)
	ProofIpfsHash string `protobuf:"bytes,3,opt,name=proof_ipfs_hash,json=proofIpfsHash,proto3" json:"proof_ipfs_hash,omitempty"`
}

func (m *MsgRespondToChallenge) Reset()         { *m = MsgRespondToChallenge{} }
func (m *MsgRespondToChallenge) String() string { return proto.CompactTextString(m) }
func (*MsgRespondToChallenge) ProtoMessage()    {}
func (*MsgRespondToChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{34}
}
func (m *MsgRespondToChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRespondToChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRespondToChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRespondToChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRespondToChallenge.Merge(m, src)
}
func (m *MsgRespondToChallenge) XXX_Size() int {
	return m.Size()
}
func (m *MsgRespondToChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRespondToChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRespondToChallenge proto.InternalMessageInfo

func (m *MsgRespondToChallenge) GetNodeAddress() string {
	if m != nil {
		return m.NodeAddress
	}
	return ""
}

func (m *MsgRespondToChallenge) GetChallengeId() uint64 {
	if m != nil {
		return m.ChallengeId
	}
	return 0
}

func (m *MsgRespondToChallenge) GetProofIpfsHash() string {
	if m != nil {
		return m.ProofIpfsHash
	}
	return ""
}

// MsgRespondToChallengeResponse defines the response structure for RespondToChallenge
type MsgRespondToChallengeResponse struct {
	// is_valid indicates if the response proof is valid
	IsValid bool `protobuf:"varint,1,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`
}

func (m *MsgRespondToChallengeResponse) Reset()         { *m = MsgRespondToChallengeResponse{} }
func (m *MsgRespondToChallengeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRespondToChallengeResponse) ProtoMessage()    {}
func (*MsgRespondToChallengeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{35}
}
func (m *MsgRespondToChallengeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRespondToChallengeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRespondToChallengeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRespondToChallengeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRespondToChallengeResponse.Merge(m, src)
}
func (m *MsgRespondToChallengeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRespondToChallengeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRespondToChallengeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRespondToChallengeResponse proto.InternalMessageInfo

func (m *MsgRespondToChallengeResponse) GetIsValid() bool {
	if m != nil {
		return m.IsValid
	}
	return false
}

// MsgResolveChallenge resolves an aggregation challenge with CPU verification results
type MsgResolveChallenge struct {
	// resolver is the address resolving the challenge (must be module authority or validator)
	Resolver string `protobuf:"bytes,1,opt,name=resolver,proto3" json:"resolver,omitempty"`
	// challenge_id is the ID of the challenge to resolve
	ChallengeId uint64 `protobuf:"varint,2,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id,omitempty"`
	// fraud_detected indicates if fraud was detected
	FraudDetected bool `protobuf:"varint,3,opt,name=fraud_detected,json=fraudDetected,proto3" json:"fraud_detected,omitempty"`
	// resolution_reason is the reason for the resolution
	ResolutionReason string `protobuf:"bytes,4,opt,name=resolution_reason,json=resolutionReason,proto3" json:"resolution_reason,omitempty"`
}

func (m *MsgResolveChallenge) Reset()         { *m = MsgResolveChallenge{} }
func (m *MsgResolveChallenge) String() string { return proto.CompactTextString(m) }
func (*MsgResolveChallenge) ProtoMessage()    {}
func (*MsgResolveChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{36}
}
func (m *MsgResolveChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResolveChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResolveChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResolveChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResolveChallenge.Merge(m, src)
}
func (m *MsgResolveChallenge) XXX_Size() int {
	return m.Size()
}
func (m *MsgResolveChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResolveChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResolveChallenge proto.InternalMessageInfo

func (m *MsgResolveChallenge) GetResolver() string {
	if m != nil {
		return m.Resolver
	}
	return ""
}

func (m *MsgResolveChallenge) GetChallengeId() uint64 {
	if m != nil {
		return m.ChallengeId
	}
	return 0
}

func (m *MsgResolveChallenge) GetFraudDetected() bool {
	if m != nil {
		return m.FraudDetected
	}
	return false
}

func (m *MsgResolveChallenge) GetResolutionReason() string {
	if m != nil {
		return m.ResolutionReason
	}
	return ""
}

// MsgResolveChallengeResponse defines the response structure for ResolveChallenge
type MsgResolveChallengeResponse struct {
	// resolved indicates if the challenge was successfully resolved
	Resolved bool `protobuf:"varint,1,opt,name=resolved,proto3" json:"resolved,omitempty"`
}

func (m *MsgResolveChallengeResponse) Reset()         { *m = MsgResolveChallengeResponse{} }
func (m *MsgResolveChallengeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgResolveChallengeResponse) ProtoMessage()    {}
func (*MsgResolveChallengeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{37}
}
func (m *MsgResolveChallengeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResolveChallengeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResolveChallengeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResolveChallengeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResolveChallengeResponse.Merge(m, src)
}
func (m *MsgResolveChallengeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgResolveChallengeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResolveChallengeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResolveChallengeResponse proto.InternalMessageInfo

func (m *MsgResolveChallengeResponse) GetResolved() bool {
	if m != nil {
		return m.Resolved
	}
	return false
}

// MsgSubmitCPUVerification submits CPU verification result for a challenge
type MsgSubmitCPUVerification struct {
	// validator is the address of the validator submitting verification
	Validator string `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator,omitempty"`
	// challenge_id is the ID of the challenge being verified
	ChallengeId uint64 `protobuf:"varint,2,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id,omitempty"`
	// is_valid indicates if the gradient is valid
	IsValid bool `protobuf:"varint,3,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`
	// computed_hash is the hash computed by the validator
	ComputedHash string `protobuf:"bytes,4,opt,name=computed_hash,json=computedHash,proto3" json:"computed_hash,omitempty"`
	// expected_hash is the expected hash from the aggregation
	ExpectedHash string `protobuf:"bytes,5,opt,name=expected_hash,json=expectedHash,proto3" json:"expected_hash,omitempty"`
}

func (m *MsgSubmitCPUVerification) Reset()         { *m = MsgSubmitCPUVerification{} }
func (m *MsgSubmitCPUVerification) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitCPUVerification) ProtoMessage()    {}
func (*MsgSubmitCPUVerification) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{38}
}
func (m *MsgSubmitCPUVerification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitCPUVerification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitCPUVerification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitCPUVerification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitCPUVerification.Merge(m, src)
}
func (m *MsgSubmitCPUVerification) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitCPUVerification) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitCPUVerification.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitCPUVerification proto.InternalMessageInfo

func (m *MsgSubmitCPUVerification) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *MsgSubmitCPUVerification) GetChallengeId() uint64 {
	if m != nil {
		return m.ChallengeId
	}
	return 0
}

func (m *MsgSubmitCPUVerification) GetIsValid() bool {
	if m != nil {
		return m.IsValid
	}
	return false
}

func (m *MsgSubmitCPUVerification) GetComputedHash() string {
	if m != nil {
		return m.ComputedHash
	}
	return ""
}

func (m *MsgSubmitCPUVerification) GetExpectedHash() string {
	if m != nil {
		return m.ExpectedHash
	}
	return ""
}

// MsgSubmitCPUVerificationResponse defines the response structure for SubmitCPUVerification
type MsgSubmitCPUVerificationResponse struct {
	// accepted indicates if the verification was accepted
	Accepted bool `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"`
}

func (m *MsgSubmitCPUVerificationResponse) Reset()         { *m = MsgSubmitCPUVerificationResponse{} }
func (m *MsgSubmitCPUVerificationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitCPUVerificationResponse) ProtoMessage()    {}
func (*MsgSubmitCPUVerificationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{39}
}
func (m *MsgSubmitCPUVerificationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitCPUVerificationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitCPUVerificationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitCPUVerificationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitCPUVerificationResponse.Merge(m, src)
}
func (m *MsgSubmitCPUVerificationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitCPUVerificationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitCPUVerificationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitCPUVerificationResponse proto.InternalMessageInfo

func (m *MsgSubmitCPUVerificationResponse) GetAccepted() bool {
	if m != nil {
		return m.Accepted
	}
	return false
}

// MsgSubmitRandomVerifierResult submits random GPU verifier result for Layer 2 challenge
type MsgSubmitRandomVerifierResult struct {
	// verifier is the address of the random GPU verifier
	Verifier string `protobuf:"bytes,1,opt,name=verifier,proto3" json:"verifier,omitempty"`
	// challenge_id is the ID of the challenge being verified
	ChallengeId uint64 `protobuf:"varint,2,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id,omitempty"`
	// result is the verification result ("valid", "invalid", "pending")
	Result string `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
	// gradient_hash is the computed gradient hash from verifier's re-computation
	GradientHash string `protobuf:"bytes,4,opt,name=gradient_hash,json=gradientHash,proto3" json:"gradient_hash,omitempty"`
	// evidence_ipfs_hash is the IPFS hash of verification evidence (optional)
	EvidenceIpfsHash string `protobuf:"bytes,5,opt,name=evidence_ipfs_hash,json=evidenceIpfsHash,proto3" json:"evidence_ipfs_hash,omitempty"`
	// verifier_loss is the loss calculated by verifier through forward pass (BitNet integer format)
	// Used for Loss-Based Spot Checking - only set if loss verification was performed
	VerifierLoss string `protobuf:"bytes,6,opt,name=verifier_loss,json=verifierLoss,proto3" json:"verifier_loss,omitempty"`
	// loss_match indicates if miner's claimed loss matches verifier's calculated loss (within tolerance)
	// Used for Loss-Based Spot Checking - only set if loss verification was performed
	LossMatch bool `protobuf:"varint,7,opt,name=loss_match,json=lossMatch,proto3" json:"loss_match,omitempty"`
	// data_batch_seed is the VRF seed used for deterministic batch selection
	// Used for Loss-Based Spot Checking - only set if loss verification was performed
	DataBatchSeed uint64 `protobuf:"varint,8,opt,name=data_batch_seed,json=dataBatchSeed,proto3" json:"data_batch_seed,omitempty"`
}

func (m *MsgSubmitRandomVerifierResult) Reset()         { *m = MsgSubmitRandomVerifierResult{} }
func (m *MsgSubmitRandomVerifierResult) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitRandomVerifierResult) ProtoMessage()    {}
func (*MsgSubmitRandomVerifierResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{40}
}
func (m *MsgSubmitRandomVerifierResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitRandomVerifierResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitRandomVerifierResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitRandomVerifierResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitRandomVerifierResult.Merge(m, src)
}
func (m *MsgSubmitRandomVerifierResult) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitRandomVerifierResult) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitRandomVerifierResult.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitRandomVerifierResult proto.InternalMessageInfo

func (m *MsgSubmitRandomVerifierResult) GetVerifier() string {
	if m != nil {
		return m.Verifier
	}
	return ""
}

func (m *MsgSubmitRandomVerifierResult) GetChallengeId() uint64 {
	if m != nil {
		return m.ChallengeId
	}
	return 0
}

func (m *MsgSubmitRandomVerifierResult) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *MsgSubmitRandomVerifierResult) GetGradientHash() string {
	if m != nil {
		return m.GradientHash
	}
	return ""
}

func (m *MsgSubmitRandomVerifierResult) GetEvidenceIpfsHash() string {
	if m != nil {
		return m.EvidenceIpfsHash
	}
	return ""
}

func (m *MsgSubmitRandomVerifierResult) GetVerifierLoss() string {
	if m != nil {
		return m.VerifierLoss
	}
	return ""
}

func (m *MsgSubmitRandomVerifierResult) GetLossMatch() bool {
	if m != nil {
		return m.LossMatch
	}
	return false
}

func (m *MsgSubmitRandomVerifierResult) GetDataBatchSeed() uint64 {
	if m != nil {
		return m.DataBatchSeed
	}
	return 0
}

// MsgSubmitRandomVerifierResultResponse defines the response structure for SubmitRandomVerifierResult
type MsgSubmitRandomVerifierResultResponse struct {
	// accepted indicates whether the result was accepted
	Accepted bool `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"`
	// layer_3_triggered indicates whether Layer 3 CPU verification was triggered
	Layer_3Triggered bool `protobuf:"varint,2,opt,name=layer_3_triggered,json=layer3Triggered,proto3" json:"layer_3_triggered,omitempty"`
}

func (m *MsgSubmitRandomVerifierResultResponse) Reset()         { *m = MsgSubmitRandomVerifierResultResponse{} }
func (m *MsgSubmitRandomVerifierResultResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitRandomVerifierResultResponse) ProtoMessage()    {}
func (*MsgSubmitRandomVerifierResultResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{41}
}
func (m *MsgSubmitRandomVerifierResultResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitRandomVerifierResultResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitRandomVerifierResultResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitRandomVerifierResultResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitRandomVerifierResultResponse.Merge(m, src)
}
func (m *MsgSubmitRandomVerifierResultResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitRandomVerifierResultResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitRandomVerifierResultResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitRandomVerifierResultResponse proto.InternalMessageInfo

func (m *MsgSubmitRandomVerifierResultResponse) GetAccepted() bool {
	if m != nil {
		return m.Accepted
	}
	return false
}

func (m *MsgSubmitRandomVerifierResultResponse) GetLayer_3Triggered() bool {
	if m != nil {
		return m.Layer_3Triggered
	}
	return false
}

// MsgRequestInference requests AI model inference from a serving node
type MsgRequestInference struct {
	// requester is the address of the requester
	Requester string `protobuf:"bytes,1,opt,name=requester,proto3" json:"requester,omitempty"`
	// serving_node is the address of the serving node
	ServingNode string `protobuf:"bytes,2,opt,name=serving_node,json=servingNode,proto3" json:"serving_node,omitempty"`
	// model_version is the version of the model to use
	ModelVersion string `protobuf:"bytes,3,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
	// input_data_ipfs_hash is the IPFS hash of the input data
	InputDataIpfsHash string `protobuf:"bytes,4,opt,name=input_data_ipfs_hash,json=inputDataIpfsHash,proto3" json:"input_data_ipfs_hash,omitempty"`
	// fee is the fee paid for the inference (in R3MES tokens)
	Fee string `protobuf:"bytes,5,opt,name=fee,proto3" json:"fee,omitempty"`
}

func (m *MsgRequestInference) Reset()         { *m = MsgRequestInference{} }
func (m *MsgRequestInference) String() string { return proto.CompactTextString(m) }
func (*MsgRequestInference) ProtoMessage()    {}
func (*MsgRequestInference) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{42}
}
func (m *MsgRequestInference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestInference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestInference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestInference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestInference.Merge(m, src)
}
func (m *MsgRequestInference) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestInference) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestInference.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestInference proto.InternalMessageInfo

func (m *MsgRequestInference) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

func (m *MsgRequestInference) GetServingNode() string {
	if m != nil {
		return m.ServingNode
	}
	return ""
}

func (m *MsgRequestInference) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

func (m *MsgRequestInference) GetInputDataIpfsHash() string {
	if m != nil {
		return m.InputDataIpfsHash
	}
	return ""
}

func (m *MsgRequestInference) GetFee() string {
	if m != nil {
		return m.Fee
	}
	return ""
}

// MsgRequestInferenceResponse defines the response structure for RequestInference
type MsgRequestInferenceResponse struct {
	// request_id is the unique identifier for this request
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
}

func (m *MsgRequestInferenceResponse) Reset()         { *m = MsgRequestInferenceResponse{} }
func (m *MsgRequestInferenceResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRequestInferenceResponse) ProtoMessage()    {}
func (*MsgRequestInferenceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{43}
}
func (m *MsgRequestInferenceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestInferenceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestInferenceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestInferenceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestInferenceResponse.Merge(m, src)
}
func (m *MsgRequestInferenceResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestInferenceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestInferenceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestInferenceResponse proto.InternalMessageInfo

func (m *MsgRequestInferenceResponse) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

// MsgSubmitInferenceResult submits inference result from a serving node
type MsgSubmitInferenceResult struct {
	// serving_node is the address of the serving node
	ServingNode string `protobuf:"bytes,1,opt,name=serving_node,json=servingNode,proto3" json:"serving_node,omitempty"`
	// request_id is the ID of the inference request
	RequestId string `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// result_ipfs_hash is the IPFS hash of the inference result
	ResultIpfsHash string `protobuf:"bytes,3,opt,name=result_ipfs_hash,json=resultIpfsHash,proto3" json:"result_ipfs_hash,omitempty"`
	// latency_ms is the inference latency in milliseconds
	LatencyMs uint64 `protobuf:"varint,4,opt,name=latency_ms,json=latencyMs,proto3" json:"latency_ms,omitempty"`
}

func (m *MsgSubmitInferenceResult) Reset()         { *m = MsgSubmitInferenceResult{} }
func (m *MsgSubmitInferenceResult) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitInferenceResult) ProtoMessage()    {}
func (*MsgSubmitInferenceResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{44}
}
func (m *MsgSubmitInferenceResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitInferenceResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitInferenceResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitInferenceResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitInferenceResult.Merge(m, src)
}
func (m *MsgSubmitInferenceResult) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitInferenceResult) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitInferenceResult.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitInferenceResult proto.InternalMessageInfo

func (m *MsgSubmitInferenceResult) GetServingNode() string {
	if m != nil {
		return m.ServingNode
	}
	return ""
}

func (m *MsgSubmitInferenceResult) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *MsgSubmitInferenceResult) GetResultIpfsHash() string {
	if m != nil {
		return m.ResultIpfsHash
	}
	return ""
}

func (m *MsgSubmitInferenceResult) GetLatencyMs() uint64 {
	if m != nil {
		return m.LatencyMs
	}
	return 0
}

// MsgSubmitInferenceResultResponse defines the response structure for SubmitInferenceResult
type MsgSubmitInferenceResultResponse struct {
	// accepted indicates if the result was accepted
	Accepted bool `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"`
}

func (m *MsgSubmitInferenceResultResponse) Reset()         { *m = MsgSubmitInferenceResultResponse{} }
func (m *MsgSubmitInferenceResultResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitInferenceResultResponse) ProtoMessage()    {}
func (*MsgSubmitInferenceResultResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{45}
}
func (m *MsgSubmitInferenceResultResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitInferenceResultResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitInferenceResultResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitInferenceResultResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitInferenceResultResponse.Merge(m, src)
}
func (m *MsgSubmitInferenceResultResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitInferenceResultResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitInferenceResultResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitInferenceResultResponse proto.InternalMessageInfo

func (m *MsgSubmitInferenceResultResponse) GetAccepted() bool {
	if m != nil {
		return m.Accepted
	}
	return false
}

// MsgUpdateServingNodeStatus updates serving node status and model version
type MsgUpdateServingNodeStatus struct {
	// serving_node is the address of the serving node
	ServingNode string `protobuf:"bytes,1,opt,name=serving_node,json=servingNode,proto3" json:"serving_node,omitempty"`
	// model_version is the current model version loaded
	ModelVersion string `protobuf:"bytes,2,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
	// model_ipfs_hash is the IPFS hash of the loaded model
	ModelIpfsHash string `protobuf:"bytes,3,opt,name=model_ipfs_hash,json=modelIpfsHash,proto3" json:"model_ipfs_hash,omitempty"`
	// is_available indicates if the node is available for requests
	IsAvailable bool `protobuf:"varint,4,opt,name=is_available,json=isAvailable,proto3" json:"is_available,omitempty"`
}

func (m *MsgUpdateServingNodeStatus) Reset()         { *m = MsgUpdateServingNodeStatus{} }
func (m *MsgUpdateServingNodeStatus) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateServingNodeStatus) ProtoMessage()    {}
func (*MsgUpdateServingNodeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{46}
}
func (m *MsgUpdateServingNodeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateServingNodeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateServingNodeStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateServingNodeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateServingNodeStatus.Merge(m, src)
}
func (m *MsgUpdateServingNodeStatus) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateServingNodeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateServingNodeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateServingNodeStatus proto.InternalMessageInfo

func (m *MsgUpdateServingNodeStatus) GetServingNode() string {
	if m != nil {
		return m.ServingNode
	}
	return ""
}

func (m *MsgUpdateServingNodeStatus) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

func (m *MsgUpdateServingNodeStatus) GetModelIpfsHash() string {
	if m != nil {
		return m.ModelIpfsHash
	}
	return ""
}

func (m *MsgUpdateServingNodeStatus) GetIsAvailable() bool {
	if m != nil {
		return m.IsAvailable
	}
	return false
}

// MsgUpdateServingNodeStatusResponse defines the response structure for UpdateServingNodeStatus
type MsgUpdateServingNodeStatusResponse struct {
	// updated indicates if the status was updated
	Updated bool `protobuf:"varint,1,opt,name=updated,proto3" json:"updated,omitempty"`
}

func (m *MsgUpdateServingNodeStatusResponse) Reset()         { *m = MsgUpdateServingNodeStatusResponse{} }
func (m *MsgUpdateServingNodeStatusResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateServingNodeStatusResponse) ProtoMessage()    {}
func (*MsgUpdateServingNodeStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{47}
}
func (m *MsgUpdateServingNodeStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateServingNodeStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateServingNodeStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateServingNodeStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateServingNodeStatusResponse.Merge(m, src)
}
func (m *MsgUpdateServingNodeStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateServingNodeStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateServingNodeStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateServingNodeStatusResponse proto.InternalMessageInfo

func (m *MsgUpdateServingNodeStatusResponse) GetUpdated() bool {
	if m != nil {
		return m.Updated
	}
	return false
}

// MsgCreateTrapJob creates a trap job for lazy mining detection
type MsgCreateTrapJob struct {
	// creator is the address creating the trap job (must be module authority or validator)
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// target_miner is the address of the miner being tested
	TargetMiner string `protobuf:"bytes,2,opt,name=target_miner,json=targetMiner,proto3" json:"target_miner,omitempty"`
	// dataset_ipfs_hash is the IPFS hash of the trap dataset
	DatasetIpfsHash string `protobuf:"bytes,3,opt,name=dataset_ipfs_hash,json=datasetIpfsHash,proto3" json:"dataset_ipfs_hash,omitempty"`
	// expected_gradient_hash is the known correct gradient hash (from Protocol Oracle)
	ExpectedGradientHash string `protobuf:"bytes,4,opt,name=expected_gradient_hash,json=expectedGradientHash,proto3" json:"expected_gradient_hash,omitempty"`
	// deadline_blocks is the number of blocks until trap job expires
	DeadlineBlocks uint64 `protobuf:"varint,5,opt,name=deadline_blocks,json=deadlineBlocks,proto3" json:"deadline_blocks,omitempty"`
	// obfuscate_with_dummy_data indicates if trap job should be obfuscated
	ObfuscateWithDummyData bool `protobuf:"varint,6,opt,name=obfuscate_with_dummy_data,json=obfuscateWithDummyData,proto3" json:"obfuscate_with_dummy_data,omitempty"`
	// federated_signatures are the signatures from top 3 validators (multi-sig, 2/3 threshold)
	// Required for federated trap job creation (replaces single Protocol Oracle)
	FederatedSignatures [][]byte `protobuf:"bytes,7,rep,name=federated_signatures,json=federatedSignatures,proto3" json:"federated_signatures,omitempty"`
}

func (m *MsgCreateTrapJob) Reset()         { *m = MsgCreateTrapJob{} }
func (m *MsgCreateTrapJob) String() string { return proto.CompactTextString(m) }
func (*MsgCreateTrapJob) ProtoMessage()    {}
func (*MsgCreateTrapJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{48}
}
func (m *MsgCreateTrapJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateTrapJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateTrapJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateTrapJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateTrapJob.Merge(m, src)
}
func (m *MsgCreateTrapJob) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateTrapJob) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateTrapJob.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateTrapJob proto.InternalMessageInfo

func (m *MsgCreateTrapJob) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateTrapJob) GetTargetMiner() string {
	if m != nil {
		return m.TargetMiner
	}
	return ""
}

func (m *MsgCreateTrapJob) GetDatasetIpfsHash() string {
	if m != nil {
		return m.DatasetIpfsHash
	}
	return ""
}

func (m *MsgCreateTrapJob) GetExpectedGradientHash() string {
	if m != nil {
		return m.ExpectedGradientHash
	}
	return ""
}

func (m *MsgCreateTrapJob) GetDeadlineBlocks() uint64 {
	if m != nil {
		return m.DeadlineBlocks
	}
	return 0
}

func (m *MsgCreateTrapJob) GetObfuscateWithDummyData() bool {
	if m != nil {
		return m.ObfuscateWithDummyData
	}
	return false
}

func (m *MsgCreateTrapJob) GetFederatedSignatures() [][]byte {
	if m != nil {
		return m.FederatedSignatures
	}
	return nil
}

// MsgCreateTrapJobResponse defines the response structure for CreateTrapJob
type MsgCreateTrapJobResponse struct {
	// trap_job_id is the unique identifier for the created trap job
	TrapJobId string `protobuf:"bytes,1,opt,name=trap_job_id,json=trapJobId,proto3" json:"trap_job_id,omitempty"`
}

func (m *MsgCreateTrapJobResponse) Reset()         { *m = MsgCreateTrapJobResponse{} }
func (m *MsgCreateTrapJobResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateTrapJobResponse) ProtoMessage()    {}
func (*MsgCreateTrapJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{49}
}
func (m *MsgCreateTrapJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateTrapJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateTrapJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateTrapJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateTrapJobResponse.Merge(m, src)
}
func (m *MsgCreateTrapJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateTrapJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateTrapJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateTrapJobResponse proto.InternalMessageInfo

func (m *MsgCreateTrapJobResponse) GetTrapJobId() string {
	if m != nil {
		return m.TrapJobId
	}
	return ""
}

// MsgSubmitTrapJobResult submits result for a trap job
type MsgSubmitTrapJobResult struct {
	// miner is the address of the miner submitting the result
	Miner string `protobuf:"bytes,1,opt,name=miner,proto3" json:"miner,omitempty"`
	// trap_job_id is the ID of the trap job
	TrapJobId string `protobuf:"bytes,2,opt,name=trap_job_id,json=trapJobId,proto3" json:"trap_job_id,omitempty"`
	// gradient_ipfs_hash is the IPFS hash of the computed gradient
	GradientIpfsHash string `protobuf:"bytes,3,opt,name=gradient_ipfs_hash,json=gradientIpfsHash,proto3" json:"gradient_ipfs_hash,omitempty"`
	// gradient_hash is the hash of the computed gradient
	GradientHash string `protobuf:"bytes,4,opt,name=gradient_hash,json=gradientHash,proto3" json:"gradient_hash,omitempty"`
}

func (m *MsgSubmitTrapJobResult) Reset()         { *m = MsgSubmitTrapJobResult{} }
func (m *MsgSubmitTrapJobResult) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitTrapJobResult) ProtoMessage()    {}
func (*MsgSubmitTrapJobResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{50}
}
func (m *MsgSubmitTrapJobResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitTrapJobResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitTrapJobResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitTrapJobResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitTrapJobResult.Merge(m, src)
}
func (m *MsgSubmitTrapJobResult) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitTrapJobResult) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitTrapJobResult.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitTrapJobResult proto.InternalMessageInfo

func (m *MsgSubmitTrapJobResult) GetMiner() string {
	if m != nil {
		return m.Miner
	}
	return ""
}

func (m *MsgSubmitTrapJobResult) GetTrapJobId() string {
	if m != nil {
		return m.TrapJobId
	}
	return ""
}

func (m *MsgSubmitTrapJobResult) GetGradientIpfsHash() string {
	if m != nil {
		return m.GradientIpfsHash
	}
	return ""
}

func (m *MsgSubmitTrapJobResult) GetGradientHash() string {
	if m != nil {
		return m.GradientHash
	}
	return ""
}

// MsgSubmitTrapJobResultResponse defines the response structure for SubmitTrapJobResult
type MsgSubmitTrapJobResultResponse struct {
	// verified indicates if the result was verified
	Verified bool `protobuf:"varint,1,opt,name=verified,proto3" json:"verified,omitempty"`
}

func (m *MsgSubmitTrapJobResultResponse) Reset()         { *m = MsgSubmitTrapJobResultResponse{} }
func (m *MsgSubmitTrapJobResultResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitTrapJobResultResponse) ProtoMessage()    {}
func (*MsgSubmitTrapJobResultResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{51}
}
func (m *MsgSubmitTrapJobResultResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitTrapJobResultResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitTrapJobResultResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitTrapJobResultResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitTrapJobResultResponse.Merge(m, src)
}
func (m *MsgSubmitTrapJobResultResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitTrapJobResultResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitTrapJobResultResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitTrapJobResultResponse proto.InternalMessageInfo

func (m *MsgSubmitTrapJobResultResponse) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

// MsgAppealTrapJobSlashing appeals a trap job slashing decision
type MsgAppealTrapJobSlashing struct {
	// appellant is the address of the miner appealing
	Appellant string `protobuf:"bytes,1,opt,name=appellant,proto3" json:"appellant,omitempty"`
	// trap_job_id is the ID of the trap job being appealed
	TrapJobId string `protobuf:"bytes,2,opt,name=trap_job_id,json=trapJobId,proto3" json:"trap_job_id,omitempty"`
	// reason is the reason for the appeal
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// evidence_ipfs_hash is the IPFS hash of evidence supporting the appeal
	EvidenceIpfsHash string `protobuf:"bytes,4,opt,name=evidence_ipfs_hash,json=evidenceIpfsHash,proto3" json:"evidence_ipfs_hash,omitempty"`
}

func (m *MsgAppealTrapJobSlashing) Reset()         { *m = MsgAppealTrapJobSlashing{} }
func (m *MsgAppealTrapJobSlashing) String() string { return proto.CompactTextString(m) }
func (*MsgAppealTrapJobSlashing) ProtoMessage()    {}
func (*MsgAppealTrapJobSlashing) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{52}
}
func (m *MsgAppealTrapJobSlashing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAppealTrapJobSlashing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAppealTrapJobSlashing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAppealTrapJobSlashing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAppealTrapJobSlashing.Merge(m, src)
}
func (m *MsgAppealTrapJobSlashing) XXX_Size() int {
	return m.Size()
}
func (m *MsgAppealTrapJobSlashing) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAppealTrapJobSlashing.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAppealTrapJobSlashing proto.InternalMessageInfo

func (m *MsgAppealTrapJobSlashing) GetAppellant() string {
	if m != nil {
		return m.Appellant
	}
	return ""
}

func (m *MsgAppealTrapJobSlashing) GetTrapJobId() string {
	if m != nil {
		return m.TrapJobId
	}
	return ""
}

func (m *MsgAppealTrapJobSlashing) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *MsgAppealTrapJobSlashing) GetEvidenceIpfsHash() string {
	if m != nil {
		return m.EvidenceIpfsHash
	}
	return ""
}

// MsgAppealTrapJobSlashingResponse defines the response structure for AppealTrapJobSlashing
type MsgAppealTrapJobSlashingResponse struct {
	// appeal_id is the unique identifier for the appeal
	AppealId string `protobuf:"bytes,1,opt,name=appeal_id,json=appealId,proto3" json:"appeal_id,omitempty"`
}

func (m *MsgAppealTrapJobSlashingResponse) Reset()         { *m = MsgAppealTrapJobSlashingResponse{} }
func (m *MsgAppealTrapJobSlashingResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAppealTrapJobSlashingResponse) ProtoMessage()    {}
func (*MsgAppealTrapJobSlashingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{53}
}
func (m *MsgAppealTrapJobSlashingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAppealTrapJobSlashingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAppealTrapJobSlashingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAppealTrapJobSlashingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAppealTrapJobSlashingResponse.Merge(m, src)
}
func (m *MsgAppealTrapJobSlashingResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAppealTrapJobSlashingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAppealTrapJobSlashingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAppealTrapJobSlashingResponse proto.InternalMessageInfo

func (m *MsgAppealTrapJobSlashingResponse) GetAppealId() string {
	if m != nil {
		return m.AppealId
	}
	return ""
}

// MsgReportLazyValidation reports lazy validation by a validator
type MsgReportLazyValidation struct {
	// reporter is the address reporting the lazy validation
	Reporter string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
	// validator_address is the address of the lazy validator
	ValidatorAddress string `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	// evidence_ipfs_hash is the IPFS hash of evidence
	EvidenceIpfsHash string `protobuf:"bytes,3,opt,name=evidence_ipfs_hash,json=evidenceIpfsHash,proto3" json:"evidence_ipfs_hash,omitempty"`
}

func (m *MsgReportLazyValidation) Reset()         { *m = MsgReportLazyValidation{} }
func (m *MsgReportLazyValidation) String() string { return proto.CompactTextString(m) }
func (*MsgReportLazyValidation) ProtoMessage()    {}
func (*MsgReportLazyValidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{54}
}
func (m *MsgReportLazyValidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReportLazyValidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReportLazyValidation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReportLazyValidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReportLazyValidation.Merge(m, src)
}
func (m *MsgReportLazyValidation) XXX_Size() int {
	return m.Size()
}
func (m *MsgReportLazyValidation) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReportLazyValidation.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReportLazyValidation proto.InternalMessageInfo

func (m *MsgReportLazyValidation) GetReporter() string {
	if m != nil {
		return m.Reporter
	}
	return ""
}

func (m *MsgReportLazyValidation) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *MsgReportLazyValidation) GetEvidenceIpfsHash() string {
	if m != nil {
		return m.EvidenceIpfsHash
	}
	return ""
}

// MsgReportLazyValidationResponse defines the response structure for ReportLazyValidation
type MsgReportLazyValidationResponse struct {
	// reported indicates if the report was accepted
	Reported bool `protobuf:"varint,1,opt,name=reported,proto3" json:"reported,omitempty"`
}

func (m *MsgReportLazyValidationResponse) Reset()         { *m = MsgReportLazyValidationResponse{} }
func (m *MsgReportLazyValidationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgReportLazyValidationResponse) ProtoMessage()    {}
func (*MsgReportLazyValidationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{55}
}
func (m *MsgReportLazyValidationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReportLazyValidationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReportLazyValidationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReportLazyValidationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReportLazyValidationResponse.Merge(m, src)
}
func (m *MsgReportLazyValidationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgReportLazyValidationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReportLazyValidationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReportLazyValidationResponse proto.InternalMessageInfo

func (m *MsgReportLazyValidationResponse) GetReported() bool {
	if m != nil {
		return m.Reported
	}
	return false
}

// MsgReportFalseVerdict reports false verdict by a validator
type MsgReportFalseVerdict struct {
	// reporter is the address reporting the false verdict
	Reporter string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
	// validator_address is the address of the validator with false verdict
	ValidatorAddress string `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	// challenge_id is the ID of the challenge where false verdict occurred
	ChallengeId uint64 `protobuf:"varint,3,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id,omitempty"`
	// evidence_ipfs_hash is the IPFS hash of evidence
	EvidenceIpfsHash string `protobuf:"bytes,4,opt,name=evidence_ipfs_hash,json=evidenceIpfsHash,proto3" json:"evidence_ipfs_hash,omitempty"`
}

func (m *MsgReportFalseVerdict) Reset()         { *m = MsgReportFalseVerdict{} }
func (m *MsgReportFalseVerdict) String() string { return proto.CompactTextString(m) }
func (*MsgReportFalseVerdict) ProtoMessage()    {}
func (*MsgReportFalseVerdict) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{56}
}
func (m *MsgReportFalseVerdict) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReportFalseVerdict) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReportFalseVerdict.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReportFalseVerdict) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReportFalseVerdict.Merge(m, src)
}
func (m *MsgReportFalseVerdict) XXX_Size() int {
	return m.Size()
}
func (m *MsgReportFalseVerdict) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReportFalseVerdict.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReportFalseVerdict proto.InternalMessageInfo

func (m *MsgReportFalseVerdict) GetReporter() string {
	if m != nil {
		return m.Reporter
	}
	return ""
}

func (m *MsgReportFalseVerdict) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *MsgReportFalseVerdict) GetChallengeId() uint64 {
	if m != nil {
		return m.ChallengeId
	}
	return 0
}

func (m *MsgReportFalseVerdict) GetEvidenceIpfsHash() string {
	if m != nil {
		return m.EvidenceIpfsHash
	}
	return ""
}

// MsgReportFalseVerdictResponse defines the response structure for ReportFalseVerdict
type MsgReportFalseVerdictResponse struct {
	// reported indicates if the report was accepted
	Reported bool `protobuf:"varint,1,opt,name=reported,proto3" json:"reported,omitempty"`
}

func (m *MsgReportFalseVerdictResponse) Reset()         { *m = MsgReportFalseVerdictResponse{} }
func (m *MsgReportFalseVerdictResponse) String() string { return proto.CompactTextString(m) }
func (*MsgReportFalseVerdictResponse) ProtoMessage()    {}
func (*MsgReportFalseVerdictResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{57}
}
func (m *MsgReportFalseVerdictResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReportFalseVerdictResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReportFalseVerdictResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReportFalseVerdictResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReportFalseVerdictResponse.Merge(m, src)
}
func (m *MsgReportFalseVerdictResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgReportFalseVerdictResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReportFalseVerdictResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReportFalseVerdictResponse proto.InternalMessageInfo

func (m *MsgReportFalseVerdictResponse) GetReported() bool {
	if m != nil {
		return m.Reported
	}
	return false
}

// MsgReportProposerCensorship reports censorship by a proposer
type MsgReportProposerCensorship struct {
	// reporter is the address reporting the censorship
	Reporter string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
	// proposer_address is the address of the censoring proposer
	ProposerAddress string `protobuf:"bytes,2,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
	// aggregation_id is the ID of the aggregation where censorship occurred
	AggregationId uint64 `protobuf:"varint,3,opt,name=aggregation_id,json=aggregationId,proto3" json:"aggregation_id,omitempty"`
	// excluded_gradient_ids are the IDs of valid gradients that were excluded
	ExcludedGradientIds []uint64 `protobuf:"varint,4,rep,packed,name=excluded_gradient_ids,json=excludedGradientIds,proto3" json:"excluded_gradient_ids,omitempty"`
	// evidence_ipfs_hash is the IPFS hash of evidence
	EvidenceIpfsHash string `protobuf:"bytes,5,opt,name=evidence_ipfs_hash,json=evidenceIpfsHash,proto3" json:"evidence_ipfs_hash,omitempty"`
}

func (m *MsgReportProposerCensorship) Reset()         { *m = MsgReportProposerCensorship{} }
func (m *MsgReportProposerCensorship) String() string { return proto.CompactTextString(m) }
func (*MsgReportProposerCensorship) ProtoMessage()    {}
func (*MsgReportProposerCensorship) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{58}
}
func (m *MsgReportProposerCensorship) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReportProposerCensorship) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReportProposerCensorship.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReportProposerCensorship) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReportProposerCensorship.Merge(m, src)
}
func (m *MsgReportProposerCensorship) XXX_Size() int {
	return m.Size()
}
func (m *MsgReportProposerCensorship) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReportProposerCensorship.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReportProposerCensorship proto.InternalMessageInfo

func (m *MsgReportProposerCensorship) GetReporter() string {
	if m != nil {
		return m.Reporter
	}
	return ""
}

func (m *MsgReportProposerCensorship) GetProposerAddress() string {
	if m != nil {
		return m.ProposerAddress
	}
	return ""
}

func (m *MsgReportProposerCensorship) GetAggregationId() uint64 {
	if m != nil {
		return m.AggregationId
	}
	return 0
}

func (m *MsgReportProposerCensorship) GetExcludedGradientIds() []uint64 {
	if m != nil {
		return m.ExcludedGradientIds
	}
	return nil
}

func (m *MsgReportProposerCensorship) GetEvidenceIpfsHash() string {
	if m != nil {
		return m.EvidenceIpfsHash
	}
	return ""
}

// MsgReportProposerCensorshipResponse defines the response structure for ReportProposerCensorship
type MsgReportProposerCensorshipResponse struct {
	// reported indicates if the report was accepted
	Reported bool `protobuf:"varint,1,opt,name=reported,proto3" json:"reported,omitempty"`
}

func (m *MsgReportProposerCensorshipResponse) Reset()         { *m = MsgReportProposerCensorshipResponse{} }
func (m *MsgReportProposerCensorshipResponse) String() string { return proto.CompactTextString(m) }
func (*MsgReportProposerCensorshipResponse) ProtoMessage()    {}
func (*MsgReportProposerCensorshipResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{59}
}
func (m *MsgReportProposerCensorshipResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReportProposerCensorshipResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReportProposerCensorshipResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReportProposerCensorshipResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReportProposerCensorshipResponse.Merge(m, src)
}
func (m *MsgReportProposerCensorshipResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgReportProposerCensorshipResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReportProposerCensorshipResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReportProposerCensorshipResponse proto.InternalMessageInfo

func (m *MsgReportProposerCensorshipResponse) GetReported() bool {
	if m != nil {
		return m.Reported
	}
	return false
}

// MsgAppealSlashing appeals a slashing decision
type MsgAppealSlashing struct {
	// appellant is the address of the slashed node appealing
	Appellant string `protobuf:"bytes,1,opt,name=appellant,proto3" json:"appellant,omitempty"`
	// slashing_reason is the original reason for slashing
	SlashingReason string `protobuf:"bytes,2,opt,name=slashing_reason,json=slashingReason,proto3" json:"slashing_reason,omitempty"`
	// appeal_reason is the reason for the appeal
	AppealReason string `protobuf:"bytes,3,opt,name=appeal_reason,json=appealReason,proto3" json:"appeal_reason,omitempty"`
	// evidence_ipfs_hash is the IPFS hash of evidence supporting the appeal
	EvidenceIpfsHash string `protobuf:"bytes,4,opt,name=evidence_ipfs_hash,json=evidenceIpfsHash,proto3" json:"evidence_ipfs_hash,omitempty"`
}

func (m *MsgAppealSlashing) Reset()         { *m = MsgAppealSlashing{} }
func (m *MsgAppealSlashing) String() string { return proto.CompactTextString(m) }
func (*MsgAppealSlashing) ProtoMessage()    {}
func (*MsgAppealSlashing) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{60}
}
func (m *MsgAppealSlashing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAppealSlashing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAppealSlashing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAppealSlashing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAppealSlashing.Merge(m, src)
}
func (m *MsgAppealSlashing) XXX_Size() int {
	return m.Size()
}
func (m *MsgAppealSlashing) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAppealSlashing.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAppealSlashing proto.InternalMessageInfo

func (m *MsgAppealSlashing) GetAppellant() string {
	if m != nil {
		return m.Appellant
	}
	return ""
}

func (m *MsgAppealSlashing) GetSlashingReason() string {
	if m != nil {
		return m.SlashingReason
	}
	return ""
}

func (m *MsgAppealSlashing) GetAppealReason() string {
	if m != nil {
		return m.AppealReason
	}
	return ""
}

func (m *MsgAppealSlashing) GetEvidenceIpfsHash() string {
	if m != nil {
		return m.EvidenceIpfsHash
	}
	return ""
}

// MsgAppealSlashingResponse defines the response structure for AppealSlashing
type MsgAppealSlashingResponse struct {
	// appeal_id is the unique identifier for the appeal
	AppealId string `protobuf:"bytes,1,opt,name=appeal_id,json=appealId,proto3" json:"appeal_id,omitempty"`
}

func (m *MsgAppealSlashingResponse) Reset()         { *m = MsgAppealSlashingResponse{} }
func (m *MsgAppealSlashingResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAppealSlashingResponse) ProtoMessage()    {}
func (*MsgAppealSlashingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{61}
}
func (m *MsgAppealSlashingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAppealSlashingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAppealSlashingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAppealSlashingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAppealSlashingResponse.Merge(m, src)
}
func (m *MsgAppealSlashingResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAppealSlashingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAppealSlashingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAppealSlashingResponse proto.InternalMessageInfo

func (m *MsgAppealSlashingResponse) GetAppealId() string {
	if m != nil {
		return m.AppealId
	}
	return ""
}

// MsgRegisterMentorRelationship registers a mentor-mentee relationship
type MsgRegisterMentorRelationship struct {
	// mentor is the address of the mentor
	Mentor string `protobuf:"bytes,1,opt,name=mentor,proto3" json:"mentor,omitempty"`
	// mentee is the address of the mentee (new miner)
	Mentee string `protobuf:"bytes,2,opt,name=mentee,proto3" json:"mentee,omitempty"`
	// reduced_stake_percentage is the reduced stake requirement (e.g., "0.5" for 50%)
	ReducedStakePercentage string `protobuf:"bytes,3,opt,name=reduced_stake_percentage,json=reducedStakePercentage,proto3" json:"reduced_stake_percentage,omitempty"`
}

func (m *MsgRegisterMentorRelationship) Reset()         { *m = MsgRegisterMentorRelationship{} }
func (m *MsgRegisterMentorRelationship) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterMentorRelationship) ProtoMessage()    {}
func (*MsgRegisterMentorRelationship) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{62}
}
func (m *MsgRegisterMentorRelationship) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterMentorRelationship) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterMentorRelationship.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterMentorRelationship) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterMentorRelationship.Merge(m, src)
}
func (m *MsgRegisterMentorRelationship) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterMentorRelationship) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterMentorRelationship.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterMentorRelationship proto.InternalMessageInfo

func (m *MsgRegisterMentorRelationship) GetMentor() string {
	if m != nil {
		return m.Mentor
	}
	return ""
}

func (m *MsgRegisterMentorRelationship) GetMentee() string {
	if m != nil {
		return m.Mentee
	}
	return ""
}

func (m *MsgRegisterMentorRelationship) GetReducedStakePercentage() string {
	if m != nil {
		return m.ReducedStakePercentage
	}
	return ""
}

// MsgRegisterMentorRelationshipResponse defines the response structure for RegisterMentorRelationship
type MsgRegisterMentorRelationshipResponse struct {
	// registered indicates if the relationship was registered
	Registered bool `protobuf:"varint,1,opt,name=registered,proto3" json:"registered,omitempty"`
}

func (m *MsgRegisterMentorRelationshipResponse) Reset()         { *m = MsgRegisterMentorRelationshipResponse{} }
func (m *MsgRegisterMentorRelationshipResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterMentorRelationshipResponse) ProtoMessage()    {}
func (*MsgRegisterMentorRelationshipResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{63}
}
func (m *MsgRegisterMentorRelationshipResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterMentorRelationshipResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterMentorRelationshipResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterMentorRelationshipResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterMentorRelationshipResponse.Merge(m, src)
}
func (m *MsgRegisterMentorRelationshipResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterMentorRelationshipResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterMentorRelationshipResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterMentorRelationshipResponse proto.InternalMessageInfo

func (m *MsgRegisterMentorRelationshipResponse) GetRegistered() bool {
	if m != nil {
		return m.Registered
	}
	return false
}

// MsgProposeExecutionEnvironment proposes a new execution environment for governance approval
type MsgProposeExecutionEnvironment struct {
	// proposer is the address of the proposer
	Proposer string `protobuf:"bytes,1,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// environment is the execution environment specification
	Environment ExecutionEnvironment `protobuf:"bytes,2,opt,name=environment,proto3" json:"environment"`
	// deposit is the proposal deposit (required for governance)
	Deposit string `protobuf:"bytes,3,opt,name=deposit,proto3" json:"deposit,omitempty"`
}

func (m *MsgProposeExecutionEnvironment) Reset()         { *m = MsgProposeExecutionEnvironment{} }
func (m *MsgProposeExecutionEnvironment) String() string { return proto.CompactTextString(m) }
func (*MsgProposeExecutionEnvironment) ProtoMessage()    {}
func (*MsgProposeExecutionEnvironment) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{64}
}
func (m *MsgProposeExecutionEnvironment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposeExecutionEnvironment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposeExecutionEnvironment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposeExecutionEnvironment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposeExecutionEnvironment.Merge(m, src)
}
func (m *MsgProposeExecutionEnvironment) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposeExecutionEnvironment) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposeExecutionEnvironment.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposeExecutionEnvironment proto.InternalMessageInfo

func (m *MsgProposeExecutionEnvironment) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *MsgProposeExecutionEnvironment) GetEnvironment() ExecutionEnvironment {
	if m != nil {
		return m.Environment
	}
	return ExecutionEnvironment{}
}

func (m *MsgProposeExecutionEnvironment) GetDeposit() string {
	if m != nil {
		return m.Deposit
	}
	return ""
}

// MsgProposeExecutionEnvironmentResponse defines the response structure for ProposeExecutionEnvironment
type MsgProposeExecutionEnvironmentResponse struct {
	// proposal_id is the unique identifier for the proposal
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
}

func (m *MsgProposeExecutionEnvironmentResponse) Reset() {
	*m = MsgProposeExecutionEnvironmentResponse{}
}
func (m *MsgProposeExecutionEnvironmentResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProposeExecutionEnvironmentResponse) ProtoMessage()    {}
func (*MsgProposeExecutionEnvironmentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{65}
}
func (m *MsgProposeExecutionEnvironmentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposeExecutionEnvironmentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposeExecutionEnvironmentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposeExecutionEnvironmentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposeExecutionEnvironmentResponse.Merge(m, src)
}
func (m *MsgProposeExecutionEnvironmentResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposeExecutionEnvironmentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposeExecutionEnvironmentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposeExecutionEnvironmentResponse proto.InternalMessageInfo

func (m *MsgProposeExecutionEnvironmentResponse) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

// MsgVoteExecutionEnvironment votes on an execution environment proposal
type MsgVoteExecutionEnvironment struct {
	// voter is the address of the voter
	Voter string `protobuf:"bytes,1,opt,name=voter,proto3" json:"voter,omitempty"`
	// proposal_id is the ID of the proposal being voted on
	ProposalId uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// vote_option is the vote option (yes, no, abstain)
	VoteOption string `protobuf:"bytes,3,opt,name=vote_option,json=voteOption,proto3" json:"vote_option,omitempty"`
}

func (m *MsgVoteExecutionEnvironment) Reset()         { *m = MsgVoteExecutionEnvironment{} }
func (m *MsgVoteExecutionEnvironment) String() string { return proto.CompactTextString(m) }
func (*MsgVoteExecutionEnvironment) ProtoMessage()    {}
func (*MsgVoteExecutionEnvironment) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{66}
}
func (m *MsgVoteExecutionEnvironment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgVoteExecutionEnvironment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgVoteExecutionEnvironment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgVoteExecutionEnvironment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgVoteExecutionEnvironment.Merge(m, src)
}
func (m *MsgVoteExecutionEnvironment) XXX_Size() int {
	return m.Size()
}
func (m *MsgVoteExecutionEnvironment) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgVoteExecutionEnvironment.DiscardUnknown(m)
}

var xxx_messageInfo_MsgVoteExecutionEnvironment proto.InternalMessageInfo

func (m *MsgVoteExecutionEnvironment) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

func (m *MsgVoteExecutionEnvironment) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *MsgVoteExecutionEnvironment) GetVoteOption() string {
	if m != nil {
		return m.VoteOption
	}
	return ""
}

// MsgVoteExecutionEnvironmentResponse defines the response structure for VoteExecutionEnvironment
type MsgVoteExecutionEnvironmentResponse struct {
	// vote_id is the unique identifier for the vote
	VoteId uint64 `protobuf:"varint,1,opt,name=vote_id,json=voteId,proto3" json:"vote_id,omitempty"`
}

func (m *MsgVoteExecutionEnvironmentResponse) Reset()         { *m = MsgVoteExecutionEnvironmentResponse{} }
func (m *MsgVoteExecutionEnvironmentResponse) String() string { return proto.CompactTextString(m) }
func (*MsgVoteExecutionEnvironmentResponse) ProtoMessage()    {}
func (*MsgVoteExecutionEnvironmentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{67}
}
func (m *MsgVoteExecutionEnvironmentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgVoteExecutionEnvironmentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgVoteExecutionEnvironmentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgVoteExecutionEnvironmentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgVoteExecutionEnvironmentResponse.Merge(m, src)
}
func (m *MsgVoteExecutionEnvironmentResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgVoteExecutionEnvironmentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgVoteExecutionEnvironmentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgVoteExecutionEnvironmentResponse proto.InternalMessageInfo

func (m *MsgVoteExecutionEnvironmentResponse) GetVoteId() uint64 {
	if m != nil {
		return m.VoteId
	}
	return 0
}

// MsgActivateExecutionEnvironment activates an approved execution environment
type MsgActivateExecutionEnvironment struct {
	// authority is the address that controls the module (defaults to x/gov)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// environment_id is the ID of the approved execution environment
	EnvironmentId string `protobuf:"bytes,2,opt,name=environment_id,json=environmentId,proto3" json:"environment_id,omitempty"`
}

func (m *MsgActivateExecutionEnvironment) Reset()         { *m = MsgActivateExecutionEnvironment{} }
func (m *MsgActivateExecutionEnvironment) String() string { return proto.CompactTextString(m) }
func (*MsgActivateExecutionEnvironment) ProtoMessage()    {}
func (*MsgActivateExecutionEnvironment) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{68}
}
func (m *MsgActivateExecutionEnvironment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateExecutionEnvironment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateExecutionEnvironment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateExecutionEnvironment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateExecutionEnvironment.Merge(m, src)
}
func (m *MsgActivateExecutionEnvironment) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateExecutionEnvironment) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateExecutionEnvironment.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateExecutionEnvironment proto.InternalMessageInfo

func (m *MsgActivateExecutionEnvironment) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgActivateExecutionEnvironment) GetEnvironmentId() string {
	if m != nil {
		return m.EnvironmentId
	}
	return ""
}

// MsgActivateExecutionEnvironmentResponse defines the response structure for ActivateExecutionEnvironment
type MsgActivateExecutionEnvironmentResponse struct {
}

func (m *MsgActivateExecutionEnvironmentResponse) Reset() {
	*m = MsgActivateExecutionEnvironmentResponse{}
}
func (m *MsgActivateExecutionEnvironmentResponse) String() string { return proto.CompactTextString(m) }
func (*MsgActivateExecutionEnvironmentResponse) ProtoMessage()    {}
func (*MsgActivateExecutionEnvironmentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{69}
}
func (m *MsgActivateExecutionEnvironmentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateExecutionEnvironmentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateExecutionEnvironmentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateExecutionEnvironmentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateExecutionEnvironmentResponse.Merge(m, src)
}
func (m *MsgActivateExecutionEnvironmentResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateExecutionEnvironmentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateExecutionEnvironmentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateExecutionEnvironmentResponse proto.InternalMessageInfo

// MsgProposeModelUpgrade proposes a new model version upgrade
type MsgProposeModelUpgrade struct {
	// proposer is the address proposing the upgrade
	Proposer string `protobuf:"bytes,1,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// new_model_version is the proposed version number
	NewModelVersion uint64 `protobuf:"varint,2,opt,name=new_model_version,json=newModelVersion,proto3" json:"new_model_version,omitempty"`
	// new_model_hash is the IPFS hash of the new model
	NewModelHash string `protobuf:"bytes,3,opt,name=new_model_hash,json=newModelHash,proto3" json:"new_model_hash,omitempty"`
	// new_model_id is the ModelRegistry ID for the new model
	NewModelId uint64 `protobuf:"varint,4,opt,name=new_model_id,json=newModelId,proto3" json:"new_model_id,omitempty"`
	// ipfs_path is the versioned IPFS path (e.g., "v2/")
	IpfsPath string `protobuf:"bytes,5,opt,name=ipfs_path,json=ipfsPath,proto3" json:"ipfs_path,omitempty"`
	// architecture is the model architecture string
	Architecture string `protobuf:"bytes,6,opt,name=architecture,proto3" json:"architecture,omitempty"`
	// compatibility_info is JSON-encoded compatibility information
	CompatibilityInfo string `protobuf:"bytes,7,opt,name=compatibility_info,json=compatibilityInfo,proto3" json:"compatibility_info,omitempty"`
	// migration_window is the transition period in blocks (e.g., 1000)
	MigrationWindow int64 `protobuf:"varint,8,opt,name=migration_window,json=migrationWindow,proto3" json:"migration_window,omitempty"`
	// deposit is the proposal deposit amount
	Deposit []types.Coin `protobuf:"bytes,9,rep,name=deposit,proto3" json:"deposit"`
}

func (m *MsgProposeModelUpgrade) Reset()         { *m = MsgProposeModelUpgrade{} }
func (m *MsgProposeModelUpgrade) String() string { return proto.CompactTextString(m) }
func (*MsgProposeModelUpgrade) ProtoMessage()    {}
func (*MsgProposeModelUpgrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{70}
}
func (m *MsgProposeModelUpgrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposeModelUpgrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposeModelUpgrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposeModelUpgrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposeModelUpgrade.Merge(m, src)
}
func (m *MsgProposeModelUpgrade) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposeModelUpgrade) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposeModelUpgrade.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposeModelUpgrade proto.InternalMessageInfo

func (m *MsgProposeModelUpgrade) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *MsgProposeModelUpgrade) GetNewModelVersion() uint64 {
	if m != nil {
		return m.NewModelVersion
	}
	return 0
}

func (m *MsgProposeModelUpgrade) GetNewModelHash() string {
	if m != nil {
		return m.NewModelHash
	}
	return ""
}

func (m *MsgProposeModelUpgrade) GetNewModelId() uint64 {
	if m != nil {
		return m.NewModelId
	}
	return 0
}

func (m *MsgProposeModelUpgrade) GetIpfsPath() string {
	if m != nil {
		return m.IpfsPath
	}
	return ""
}

func (m *MsgProposeModelUpgrade) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

func (m *MsgProposeModelUpgrade) GetCompatibilityInfo() string {
	if m != nil {
		return m.CompatibilityInfo
	}
	return ""
}

func (m *MsgProposeModelUpgrade) GetMigrationWindow() int64 {
	if m != nil {
		return m.MigrationWindow
	}
	return 0
}

func (m *MsgProposeModelUpgrade) GetDeposit() []types.Coin {
	if m != nil {
		return m.Deposit
	}
	return nil
}

// MsgProposeModelUpgradeResponse defines the response structure
type MsgProposeModelUpgradeResponse struct {
	// proposal_id is the unique proposal identifier
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
}

func (m *MsgProposeModelUpgradeResponse) Reset()         { *m = MsgProposeModelUpgradeResponse{} }
func (m *MsgProposeModelUpgradeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProposeModelUpgradeResponse) ProtoMessage()    {}
func (*MsgProposeModelUpgradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{71}
}
func (m *MsgProposeModelUpgradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposeModelUpgradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposeModelUpgradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposeModelUpgradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposeModelUpgradeResponse.Merge(m, src)
}
func (m *MsgProposeModelUpgradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposeModelUpgradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposeModelUpgradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposeModelUpgradeResponse proto.InternalMessageInfo

func (m *MsgProposeModelUpgradeResponse) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

// MsgVoteModelUpgrade votes on a model upgrade proposal
type MsgVoteModelUpgrade struct {
	// voter is the address voting
	Voter string `protobuf:"bytes,1,opt,name=voter,proto3" json:"voter,omitempty"`
	// proposal_id is the proposal to vote on
	ProposalId uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// vote is the vote choice: "yes", "no", "abstain"
	Vote string `protobuf:"bytes,3,opt,name=vote,proto3" json:"vote,omitempty"`
}

func (m *MsgVoteModelUpgrade) Reset()         { *m = MsgVoteModelUpgrade{} }
func (m *MsgVoteModelUpgrade) String() string { return proto.CompactTextString(m) }
func (*MsgVoteModelUpgrade) ProtoMessage()    {}
func (*MsgVoteModelUpgrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{72}
}
func (m *MsgVoteModelUpgrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgVoteModelUpgrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgVoteModelUpgrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgVoteModelUpgrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgVoteModelUpgrade.Merge(m, src)
}
func (m *MsgVoteModelUpgrade) XXX_Size() int {
	return m.Size()
}
func (m *MsgVoteModelUpgrade) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgVoteModelUpgrade.DiscardUnknown(m)
}

var xxx_messageInfo_MsgVoteModelUpgrade proto.InternalMessageInfo

func (m *MsgVoteModelUpgrade) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

func (m *MsgVoteModelUpgrade) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *MsgVoteModelUpgrade) GetVote() string {
	if m != nil {
		return m.Vote
	}
	return ""
}

// MsgVoteModelUpgradeResponse defines the response structure
type MsgVoteModelUpgradeResponse struct {
}

func (m *MsgVoteModelUpgradeResponse) Reset()         { *m = MsgVoteModelUpgradeResponse{} }
func (m *MsgVoteModelUpgradeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgVoteModelUpgradeResponse) ProtoMessage()    {}
func (*MsgVoteModelUpgradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{73}
}
func (m *MsgVoteModelUpgradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgVoteModelUpgradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgVoteModelUpgradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgVoteModelUpgradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgVoteModelUpgradeResponse.Merge(m, src)
}
func (m *MsgVoteModelUpgradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgVoteModelUpgradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgVoteModelUpgradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgVoteModelUpgradeResponse proto.InternalMessageInfo

// MsgActivateModelUpgrade activates an approved model upgrade
type MsgActivateModelUpgrade struct {
	// authority is the module authority (governance)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// proposal_id is the approved proposal to activate
	ProposalId uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
}

func (m *MsgActivateModelUpgrade) Reset()         { *m = MsgActivateModelUpgrade{} }
func (m *MsgActivateModelUpgrade) String() string { return proto.CompactTextString(m) }
func (*MsgActivateModelUpgrade) ProtoMessage()    {}
func (*MsgActivateModelUpgrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{74}
}
func (m *MsgActivateModelUpgrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateModelUpgrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateModelUpgrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateModelUpgrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateModelUpgrade.Merge(m, src)
}
func (m *MsgActivateModelUpgrade) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateModelUpgrade) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateModelUpgrade.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateModelUpgrade proto.InternalMessageInfo

func (m *MsgActivateModelUpgrade) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgActivateModelUpgrade) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

// MsgActivateModelUpgradeResponse defines the response structure
type MsgActivateModelUpgradeResponse struct {
	// version_number is the activated version number
	VersionNumber uint64 `protobuf:"varint,1,opt,name=version_number,json=versionNumber,proto3" json:"version_number,omitempty"`
}

func (m *MsgActivateModelUpgradeResponse) Reset()         { *m = MsgActivateModelUpgradeResponse{} }
func (m *MsgActivateModelUpgradeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgActivateModelUpgradeResponse) ProtoMessage()    {}
func (*MsgActivateModelUpgradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{75}
}
func (m *MsgActivateModelUpgradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateModelUpgradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateModelUpgradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateModelUpgradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateModelUpgradeResponse.Merge(m, src)
}
func (m *MsgActivateModelUpgradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateModelUpgradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateModelUpgradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateModelUpgradeResponse proto.InternalMessageInfo

func (m *MsgActivateModelUpgradeResponse) GetVersionNumber() uint64 {
	if m != nil {
		return m.VersionNumber
	}
	return 0
}

// MsgRollbackModelUpgrade rolls back a failed model upgrade
type MsgRollbackModelUpgrade struct {
	// authority is the module authority (governance)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// version_number is the version to rollback
	VersionNumber uint64 `protobuf:"varint,2,opt,name=version_number,json=versionNumber,proto3" json:"version_number,omitempty"`
	// reason is the reason for rollback
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgRollbackModelUpgrade) Reset()         { *m = MsgRollbackModelUpgrade{} }
func (m *MsgRollbackModelUpgrade) String() string { return proto.CompactTextString(m) }
func (*MsgRollbackModelUpgrade) ProtoMessage()    {}
func (*MsgRollbackModelUpgrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{76}
}
func (m *MsgRollbackModelUpgrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRollbackModelUpgrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRollbackModelUpgrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRollbackModelUpgrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRollbackModelUpgrade.Merge(m, src)
}
func (m *MsgRollbackModelUpgrade) XXX_Size() int {
	return m.Size()
}
func (m *MsgRollbackModelUpgrade) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRollbackModelUpgrade.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRollbackModelUpgrade proto.InternalMessageInfo

func (m *MsgRollbackModelUpgrade) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgRollbackModelUpgrade) GetVersionNumber() uint64 {
	if m != nil {
		return m.VersionNumber
	}
	return 0
}

func (m *MsgRollbackModelUpgrade) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// MsgRollbackModelUpgradeResponse defines the response structure
type MsgRollbackModelUpgradeResponse struct {
}

func (m *MsgRollbackModelUpgradeResponse) Reset()         { *m = MsgRollbackModelUpgradeResponse{} }
func (m *MsgRollbackModelUpgradeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRollbackModelUpgradeResponse) ProtoMessage()    {}
func (*MsgRollbackModelUpgradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{77}
}
func (m *MsgRollbackModelUpgradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRollbackModelUpgradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRollbackModelUpgradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRollbackModelUpgradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRollbackModelUpgradeResponse.Merge(m, src)
}
func (m *MsgRollbackModelUpgradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRollbackModelUpgradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRollbackModelUpgradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRollbackModelUpgradeResponse proto.InternalMessageInfo

// MsgCreateSubnet creates a new subnet for layer-based sharding
type MsgCreateSubnet struct {
	// authority is the module authority (governance)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// subnet_id is the unique identifier for this subnet
	SubnetId uint64 `protobuf:"varint,2,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// layer_range defines which layers this subnet trains
	LayerRange LayerRange `protobuf:"bytes,3,opt,name=layer_range,json=layerRange,proto3" json:"layer_range"`
	// next_subnet_id is the subnet ID that receives activations from this subnet
	NextSubnetId uint64 `protobuf:"varint,4,opt,name=next_subnet_id,json=nextSubnetId,proto3" json:"next_subnet_id,omitempty"`
	// window_id is the training window this subnet belongs to
	WindowId uint64 `protobuf:"varint,5,opt,name=window_id,json=windowId,proto3" json:"window_id,omitempty"`
}

func (m *MsgCreateSubnet) Reset()         { *m = MsgCreateSubnet{} }
func (m *MsgCreateSubnet) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSubnet) ProtoMessage()    {}
func (*MsgCreateSubnet) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{78}
}
func (m *MsgCreateSubnet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSubnet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSubnet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSubnet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSubnet.Merge(m, src)
}
func (m *MsgCreateSubnet) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSubnet) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSubnet.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSubnet proto.InternalMessageInfo

func (m *MsgCreateSubnet) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgCreateSubnet) GetSubnetId() uint64 {
	if m != nil {
		return m.SubnetId
	}
	return 0
}

func (m *MsgCreateSubnet) GetLayerRange() LayerRange {
	if m != nil {
		return m.LayerRange
	}
	return LayerRange{}
}

func (m *MsgCreateSubnet) GetNextSubnetId() uint64 {
	if m != nil {
		return m.NextSubnetId
	}
	return 0
}

func (m *MsgCreateSubnet) GetWindowId() uint64 {
	if m != nil {
		return m.WindowId
	}
	return 0
}

// MsgCreateSubnetResponse defines the response structure
type MsgCreateSubnetResponse struct {
	// subnet_id is the created subnet ID
	SubnetId uint64 `protobuf:"varint,1,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
}

func (m *MsgCreateSubnetResponse) Reset()         { *m = MsgCreateSubnetResponse{} }
func (m *MsgCreateSubnetResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSubnetResponse) ProtoMessage()    {}
func (*MsgCreateSubnetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{79}
}
func (m *MsgCreateSubnetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSubnetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSubnetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSubnetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSubnetResponse.Merge(m, src)
}
func (m *MsgCreateSubnetResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSubnetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSubnetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSubnetResponse proto.InternalMessageInfo

func (m *MsgCreateSubnetResponse) GetSubnetId() uint64 {
	if m != nil {
		return m.SubnetId
	}
	return 0
}

// MsgSubmitSubnetActivation submits activation data from a subnet
type MsgSubmitSubnetActivation struct {
	// proposer is the subnet proposer submitting activations
	Proposer string `protobuf:"bytes,1,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// subnet_id is the subnet ID that produced the activations
	SubnetId uint64 `protobuf:"varint,2,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// activation_hash is the IPFS hash of layer activations
	ActivationHash string `protobuf:"bytes,3,opt,name=activation_hash,json=activationHash,proto3" json:"activation_hash,omitempty"`
	// next_subnet_id is the subnet ID that will receive these activations
	NextSubnetId uint64 `protobuf:"varint,4,opt,name=next_subnet_id,json=nextSubnetId,proto3" json:"next_subnet_id,omitempty"`
	// signature is the subnet proposer signature for verification
	Signature []byte `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *MsgSubmitSubnetActivation) Reset()         { *m = MsgSubmitSubnetActivation{} }
func (m *MsgSubmitSubnetActivation) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitSubnetActivation) ProtoMessage()    {}
func (*MsgSubmitSubnetActivation) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{80}
}
func (m *MsgSubmitSubnetActivation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitSubnetActivation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitSubnetActivation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitSubnetActivation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitSubnetActivation.Merge(m, src)
}
func (m *MsgSubmitSubnetActivation) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitSubnetActivation) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitSubnetActivation.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitSubnetActivation proto.InternalMessageInfo

func (m *MsgSubmitSubnetActivation) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *MsgSubmitSubnetActivation) GetSubnetId() uint64 {
	if m != nil {
		return m.SubnetId
	}
	return 0
}

func (m *MsgSubmitSubnetActivation) GetActivationHash() string {
	if m != nil {
		return m.ActivationHash
	}
	return ""
}

func (m *MsgSubmitSubnetActivation) GetNextSubnetId() uint64 {
	if m != nil {
		return m.NextSubnetId
	}
	return 0
}

func (m *MsgSubmitSubnetActivation) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// MsgSubmitSubnetActivationResponse defines the response structure
type MsgSubmitSubnetActivationResponse struct {
	// transmission_id is the unique identifier for this activation transmission
	TransmissionId uint64 `protobuf:"varint,1,opt,name=transmission_id,json=transmissionId,proto3" json:"transmission_id,omitempty"`
}

func (m *MsgSubmitSubnetActivationResponse) Reset()         { *m = MsgSubmitSubnetActivationResponse{} }
func (m *MsgSubmitSubnetActivationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitSubnetActivationResponse) ProtoMessage()    {}
func (*MsgSubmitSubnetActivationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{81}
}
func (m *MsgSubmitSubnetActivationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitSubnetActivationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitSubnetActivationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitSubnetActivationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitSubnetActivationResponse.Merge(m, src)
}
func (m *MsgSubmitSubnetActivationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitSubnetActivationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitSubnetActivationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitSubnetActivationResponse proto.InternalMessageInfo

func (m *MsgSubmitSubnetActivationResponse) GetTransmissionId() uint64 {
	if m != nil {
		return m.TransmissionId
	}
	return 0
}

// MsgAssignMinerToSubnet assigns a miner to a subnet
type MsgAssignMinerToSubnet struct {
	// miner is the miner address being assigned
	Miner string `protobuf:"bytes,1,opt,name=miner,proto3" json:"miner,omitempty"`
	// subnet_id is the subnet ID to assign the miner to
	SubnetId uint64 `protobuf:"varint,2,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// window_id is the training window for this assignment
	WindowId uint64 `protobuf:"varint,3,opt,name=window_id,json=windowId,proto3" json:"window_id,omitempty"`
}

func (m *MsgAssignMinerToSubnet) Reset()         { *m = MsgAssignMinerToSubnet{} }
func (m *MsgAssignMinerToSubnet) String() string { return proto.CompactTextString(m) }
func (*MsgAssignMinerToSubnet) ProtoMessage()    {}
func (*MsgAssignMinerToSubnet) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{82}
}
func (m *MsgAssignMinerToSubnet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAssignMinerToSubnet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAssignMinerToSubnet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAssignMinerToSubnet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAssignMinerToSubnet.Merge(m, src)
}
func (m *MsgAssignMinerToSubnet) XXX_Size() int {
	return m.Size()
}
func (m *MsgAssignMinerToSubnet) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAssignMinerToSubnet.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAssignMinerToSubnet proto.InternalMessageInfo

func (m *MsgAssignMinerToSubnet) GetMiner() string {
	if m != nil {
		return m.Miner
	}
	return ""
}

func (m *MsgAssignMinerToSubnet) GetSubnetId() uint64 {
	if m != nil {
		return m.SubnetId
	}
	return 0
}

func (m *MsgAssignMinerToSubnet) GetWindowId() uint64 {
	if m != nil {
		return m.WindowId
	}
	return 0
}

// MsgAssignMinerToSubnetResponse defines the response structure
type MsgAssignMinerToSubnetResponse struct {
	// subnet_id is the assigned subnet ID
	SubnetId uint64 `protobuf:"varint,1,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// layer_range is the layer range assigned to this miner
	LayerRange LayerRange `protobuf:"bytes,2,opt,name=layer_range,json=layerRange,proto3" json:"layer_range"`
}

func (m *MsgAssignMinerToSubnetResponse) Reset()         { *m = MsgAssignMinerToSubnetResponse{} }
func (m *MsgAssignMinerToSubnetResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAssignMinerToSubnetResponse) ProtoMessage()    {}
func (*MsgAssignMinerToSubnetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{83}
}
func (m *MsgAssignMinerToSubnetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAssignMinerToSubnetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAssignMinerToSubnetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAssignMinerToSubnetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAssignMinerToSubnetResponse.Merge(m, src)
}
func (m *MsgAssignMinerToSubnetResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAssignMinerToSubnetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAssignMinerToSubnetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAssignMinerToSubnetResponse proto.InternalMessageInfo

func (m *MsgAssignMinerToSubnetResponse) GetSubnetId() uint64 {
	if m != nil {
		return m.SubnetId
	}
	return 0
}

func (m *MsgAssignMinerToSubnetResponse) GetLayerRange() LayerRange {
	if m != nil {
		return m.LayerRange
	}
	return LayerRange{}
}

// MsgCreateTrainingWindow creates a new training window
type MsgCreateTrainingWindow struct {
	// authority is the module authority (governance)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// window_id is the unique identifier for this window
	WindowId uint64 `protobuf:"varint,2,opt,name=window_id,json=windowId,proto3" json:"window_id,omitempty"`
	// start_height is the block height when the window starts
	StartHeight int64 `protobuf:"varint,3,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// aggregator_node is the proposer address assigned to aggregate
	AggregatorNode string `protobuf:"bytes,4,opt,name=aggregator_node,json=aggregatorNode,proto3" json:"aggregator_node,omitempty"`
}

func (m *MsgCreateTrainingWindow) Reset()         { *m = MsgCreateTrainingWindow{} }
func (m *MsgCreateTrainingWindow) String() string { return proto.CompactTextString(m) }
func (*MsgCreateTrainingWindow) ProtoMessage()    {}
func (*MsgCreateTrainingWindow) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{84}
}
func (m *MsgCreateTrainingWindow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateTrainingWindow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateTrainingWindow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateTrainingWindow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateTrainingWindow.Merge(m, src)
}
func (m *MsgCreateTrainingWindow) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateTrainingWindow) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateTrainingWindow.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateTrainingWindow proto.InternalMessageInfo

func (m *MsgCreateTrainingWindow) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgCreateTrainingWindow) GetWindowId() uint64 {
	if m != nil {
		return m.WindowId
	}
	return 0
}

func (m *MsgCreateTrainingWindow) GetStartHeight() int64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *MsgCreateTrainingWindow) GetAggregatorNode() string {
	if m != nil {
		return m.AggregatorNode
	}
	return ""
}

// MsgCreateTrainingWindowResponse defines the response structure
type MsgCreateTrainingWindowResponse struct {
	// window_id is the created window ID
	WindowId uint64 `protobuf:"varint,1,opt,name=window_id,json=windowId,proto3" json:"window_id,omitempty"`
}

func (m *MsgCreateTrainingWindowResponse) Reset()         { *m = MsgCreateTrainingWindowResponse{} }
func (m *MsgCreateTrainingWindowResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateTrainingWindowResponse) ProtoMessage()    {}
func (*MsgCreateTrainingWindowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{85}
}
func (m *MsgCreateTrainingWindowResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateTrainingWindowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateTrainingWindowResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateTrainingWindowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateTrainingWindowResponse.Merge(m, src)
}
func (m *MsgCreateTrainingWindowResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateTrainingWindowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateTrainingWindowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateTrainingWindowResponse proto.InternalMessageInfo

func (m *MsgCreateTrainingWindowResponse) GetWindowId() uint64 {
	if m != nil {
		return m.WindowId
	}
	return 0
}

// MsgSubmitAsyncGradient submits an asynchronous gradient (non-blocking)
type MsgSubmitAsyncGradient struct {
	// miner is the miner address submitting the gradient
	Miner string `protobuf:"bytes,1,opt,name=miner,proto3" json:"miner,omitempty"`
	// window_id is the training window this submission belongs to
	WindowId uint64 `protobuf:"varint,2,opt,name=window_id,json=windowId,proto3" json:"window_id,omitempty"`
	// gradient_hash is the IPFS hash of the gradient
	GradientHash string `protobuf:"bytes,3,opt,name=gradient_hash,json=gradientHash,proto3" json:"gradient_hash,omitempty"`
	// subnet_id is the subnet ID this gradient belongs to
	SubnetId uint64 `protobuf:"varint,4,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// layer_range is the layer range that was trained
	LayerRange LayerRange `protobuf:"bytes,5,opt,name=layer_range,json=layerRange,proto3" json:"layer_range"`
}

func (m *MsgSubmitAsyncGradient) Reset()         { *m = MsgSubmitAsyncGradient{} }
func (m *MsgSubmitAsyncGradient) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitAsyncGradient) ProtoMessage()    {}
func (*MsgSubmitAsyncGradient) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{86}
}
func (m *MsgSubmitAsyncGradient) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitAsyncGradient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitAsyncGradient.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitAsyncGradient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitAsyncGradient.Merge(m, src)
}
func (m *MsgSubmitAsyncGradient) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitAsyncGradient) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitAsyncGradient.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitAsyncGradient proto.InternalMessageInfo

func (m *MsgSubmitAsyncGradient) GetMiner() string {
	if m != nil {
		return m.Miner
	}
	return ""
}

func (m *MsgSubmitAsyncGradient) GetWindowId() uint64 {
	if m != nil {
		return m.WindowId
	}
	return 0
}

func (m *MsgSubmitAsyncGradient) GetGradientHash() string {
	if m != nil {
		return m.GradientHash
	}
	return ""
}

func (m *MsgSubmitAsyncGradient) GetSubnetId() uint64 {
	if m != nil {
		return m.SubnetId
	}
	return 0
}

func (m *MsgSubmitAsyncGradient) GetLayerRange() LayerRange {
	if m != nil {
		return m.LayerRange
	}
	return LayerRange{}
}

// MsgSubmitAsyncGradientResponse defines the response structure
type MsgSubmitAsyncGradientResponse struct {
	// submission_id is the unique identifier for this submission
	SubmissionId uint64 `protobuf:"varint,1,opt,name=submission_id,json=submissionId,proto3" json:"submission_id,omitempty"`
}

func (m *MsgSubmitAsyncGradientResponse) Reset()         { *m = MsgSubmitAsyncGradientResponse{} }
func (m *MsgSubmitAsyncGradientResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitAsyncGradientResponse) ProtoMessage()    {}
func (*MsgSubmitAsyncGradientResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{87}
}
func (m *MsgSubmitAsyncGradientResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitAsyncGradientResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitAsyncGradientResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitAsyncGradientResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitAsyncGradientResponse.Merge(m, src)
}
func (m *MsgSubmitAsyncGradientResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitAsyncGradientResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitAsyncGradientResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitAsyncGradientResponse proto.InternalMessageInfo

func (m *MsgSubmitAsyncGradientResponse) GetSubmissionId() uint64 {
	if m != nil {
		return m.SubmissionId
	}
	return 0
}

// MsgSubmitLazyAggregation submits lazy aggregation at window boundary
type MsgSubmitLazyAggregation struct {
	// aggregator is the aggregator node submitting the aggregation
	Aggregator string `protobuf:"bytes,1,opt,name=aggregator,proto3" json:"aggregator,omitempty"`
	// window_id is the training window this aggregation belongs to
	WindowId uint64 `protobuf:"varint,2,opt,name=window_id,json=windowId,proto3" json:"window_id,omitempty"`
	// collected_gradients is the list of gradient hashes collected
	CollectedGradients []string `protobuf:"bytes,3,rep,name=collected_gradients,json=collectedGradients,proto3" json:"collected_gradients,omitempty"`
	// aggregation_method is the method used
	AggregationMethod string `protobuf:"bytes,4,opt,name=aggregation_method,json=aggregationMethod,proto3" json:"aggregation_method,omitempty"`
	// result_hash is the IPFS hash of the aggregated result
	ResultHash string `protobuf:"bytes,5,opt,name=result_hash,json=resultHash,proto3" json:"result_hash,omitempty"`
	// merkle_root is the Merkle root for verification
	MerkleRoot []byte `protobuf:"bytes,6,opt,name=merkle_root,json=merkleRoot,proto3" json:"merkle_root,omitempty"`
}

func (m *MsgSubmitLazyAggregation) Reset()         { *m = MsgSubmitLazyAggregation{} }
func (m *MsgSubmitLazyAggregation) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitLazyAggregation) ProtoMessage()    {}
func (*MsgSubmitLazyAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{88}
}
func (m *MsgSubmitLazyAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitLazyAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitLazyAggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitLazyAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitLazyAggregation.Merge(m, src)
}
func (m *MsgSubmitLazyAggregation) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitLazyAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitLazyAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitLazyAggregation proto.InternalMessageInfo

func (m *MsgSubmitLazyAggregation) GetAggregator() string {
	if m != nil {
		return m.Aggregator
	}
	return ""
}

func (m *MsgSubmitLazyAggregation) GetWindowId() uint64 {
	if m != nil {
		return m.WindowId
	}
	return 0
}

func (m *MsgSubmitLazyAggregation) GetCollectedGradients() []string {
	if m != nil {
		return m.CollectedGradients
	}
	return nil
}

func (m *MsgSubmitLazyAggregation) GetAggregationMethod() string {
	if m != nil {
		return m.AggregationMethod
	}
	return ""
}

func (m *MsgSubmitLazyAggregation) GetResultHash() string {
	if m != nil {
		return m.ResultHash
	}
	return ""
}

func (m *MsgSubmitLazyAggregation) GetMerkleRoot() []byte {
	if m != nil {
		return m.MerkleRoot
	}
	return nil
}

// MsgSubmitLazyAggregationResponse defines the response structure
type MsgSubmitLazyAggregationResponse struct {
	// aggregation_id is the unique identifier for this aggregation
	AggregationId uint64 `protobuf:"varint,1,opt,name=aggregation_id,json=aggregationId,proto3" json:"aggregation_id,omitempty"`
}

func (m *MsgSubmitLazyAggregationResponse) Reset()         { *m = MsgSubmitLazyAggregationResponse{} }
func (m *MsgSubmitLazyAggregationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitLazyAggregationResponse) ProtoMessage()    {}
func (*MsgSubmitLazyAggregationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c13a783cd5e883ea, []int{89}
}
func (m *MsgSubmitLazyAggregationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitLazyAggregationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitLazyAggregationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitLazyAggregationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitLazyAggregationResponse.Merge(m, src)
}
func (m *MsgSubmitLazyAggregationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitLazyAggregationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitLazyAggregationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitLazyAggregationResponse proto.InternalMessageInfo

func (m *MsgSubmitLazyAggregationResponse) GetAggregationId() uint64 {
	if m != nil {
		return m.AggregationId
	}
	return 0
}

func init() {
	proto.RegisterType((*MsgUpdateParams)(nil), "remes.remes.v1.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "remes.remes.v1.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgRegisterModel)(nil), "remes.remes.v1.MsgRegisterModel")
	proto.RegisterType((*MsgRegisterModelResponse)(nil), "remes.remes.v1.MsgRegisterModelResponse")
	proto.RegisterType((*MsgActivateModel)(nil), "remes.remes.v1.MsgActivateModel")
	proto.RegisterType((*MsgActivateModelResponse)(nil), "remes.remes.v1.MsgActivateModelResponse")
	proto.RegisterType((*MsgSubmitGradient)(nil), "remes.remes.v1.MsgSubmitGradient")
	proto.RegisterType((*MsgSubmitGradientResponse)(nil), "remes.remes.v1.MsgSubmitGradientResponse")
	proto.RegisterType((*MsgSubmitAggregation)(nil), "remes.remes.v1.MsgSubmitAggregation")
	proto.RegisterType((*MsgSubmitAggregationResponse)(nil), "remes.remes.v1.MsgSubmitAggregationResponse")
	proto.RegisterType((*MsgCommitAggregation)(nil), "remes.remes.v1.MsgCommitAggregation")
	proto.RegisterType((*MsgCommitAggregationResponse)(nil), "remes.remes.v1.MsgCommitAggregationResponse")
	proto.RegisterType((*MsgRevealAggregation)(nil), "remes.remes.v1.MsgRevealAggregation")
	proto.RegisterType((*MsgRevealAggregationResponse)(nil), "remes.remes.v1.MsgRevealAggregationResponse")
	proto.RegisterType((*MsgChallengeAggregation)(nil), "remes.remes.v1.MsgChallengeAggregation")
	proto.RegisterType((*MsgChallengeAggregationResponse)(nil), "remes.remes.v1.MsgChallengeAggregationResponse")
	proto.RegisterType((*MsgProposeDataset)(nil), "remes.remes.v1.MsgProposeDataset")
	proto.RegisterType((*MsgProposeDatasetResponse)(nil), "remes.remes.v1.MsgProposeDatasetResponse")
	proto.RegisterType((*MsgVoteDataset)(nil), "remes.remes.v1.MsgVoteDataset")
	proto.RegisterType((*MsgVoteDatasetResponse)(nil), "remes.remes.v1.MsgVoteDatasetResponse")
	proto.RegisterType((*MsgMarkDatasetAsOfficial)(nil), "remes.remes.v1.MsgMarkDatasetAsOfficial")
	proto.RegisterType((*MsgMarkDatasetAsOfficialResponse)(nil), "remes.remes.v1.MsgMarkDatasetAsOfficialResponse")
	proto.RegisterType((*MsgRemoveDataset)(nil), "remes.remes.v1.MsgRemoveDataset")
	proto.RegisterType((*MsgRemoveDatasetResponse)(nil), "remes.remes.v1.MsgRemoveDatasetResponse")
	proto.RegisterType((*MsgRegisterNode)(nil), "remes.remes.v1.MsgRegisterNode")
	proto.RegisterType((*MsgRegisterNodeResponse)(nil), "remes.remes.v1.MsgRegisterNodeResponse")
	proto.RegisterType((*MsgUpdateNodeRegistration)(nil), "remes.remes.v1.MsgUpdateNodeRegistration")
	proto.RegisterType((*MsgUpdateNodeRegistrationResponse)(nil), "remes.remes.v1.MsgUpdateNodeRegistrationResponse")
	proto.RegisterType((*MsgSubmitResourceUsage)(nil), "remes.remes.v1.MsgSubmitResourceUsage")
	proto.RegisterType((*MsgSubmitResourceUsageResponse)(nil), "remes.remes.v1.MsgSubmitResourceUsageResponse")
	proto.RegisterType((*MsgCommitPinning)(nil), "remes.remes.v1.MsgCommitPinning")
	proto.RegisterType((*MsgCommitPinningResponse)(nil), "remes.remes.v1.MsgCommitPinningResponse")
	proto.RegisterType((*MsgChallengePinning)(nil), "remes.remes.v1.MsgChallengePinning")
	proto.RegisterType((*MsgChallengePinningResponse)(nil), "remes.remes.v1.MsgChallengePinningResponse")
	proto.RegisterType((*MsgRespondToChallenge)(nil), "remes.remes.v1.MsgRespondToChallenge")
	proto.RegisterType((*MsgRespondToChallengeResponse)(nil), "remes.remes.v1.MsgRespondToChallengeResponse")
	proto.RegisterType((*MsgResolveChallenge)(nil), "remes.remes.v1.MsgResolveChallenge")
	proto.RegisterType((*MsgResolveChallengeResponse)(nil), "remes.remes.v1.MsgResolveChallengeResponse")
	proto.RegisterType((*MsgSubmitCPUVerification)(nil), "remes.remes.v1.MsgSubmitCPUVerification")
	proto.RegisterType((*MsgSubmitCPUVerificationResponse)(nil), "remes.remes.v1.MsgSubmitCPUVerificationResponse")
	proto.RegisterType((*MsgSubmitRandomVerifierResult)(nil), "remes.remes.v1.MsgSubmitRandomVerifierResult")
	proto.RegisterType((*MsgSubmitRandomVerifierResultResponse)(nil), "remes.remes.v1.MsgSubmitRandomVerifierResultResponse")
	proto.RegisterType((*MsgRequestInference)(nil), "remes.remes.v1.MsgRequestInference")
	proto.RegisterType((*MsgRequestInferenceResponse)(nil), "remes.remes.v1.MsgRequestInferenceResponse")
	proto.RegisterType((*MsgSubmitInferenceResult)(nil), "remes.remes.v1.MsgSubmitInferenceResult")
	proto.RegisterType((*MsgSubmitInferenceResultResponse)(nil), "remes.remes.v1.MsgSubmitInferenceResultResponse")
	proto.RegisterType((*MsgUpdateServingNodeStatus)(nil), "remes.remes.v1.MsgUpdateServingNodeStatus")
	proto.RegisterType((*MsgUpdateServingNodeStatusResponse)(nil), "remes.remes.v1.MsgUpdateServingNodeStatusResponse")
	proto.RegisterType((*MsgCreateTrapJob)(nil), "remes.remes.v1.MsgCreateTrapJob")
	proto.RegisterType((*MsgCreateTrapJobResponse)(nil), "remes.remes.v1.MsgCreateTrapJobResponse")
	proto.RegisterType((*MsgSubmitTrapJobResult)(nil), "remes.remes.v1.MsgSubmitTrapJobResult")
	proto.RegisterType((*MsgSubmitTrapJobResultResponse)(nil), "remes.remes.v1.MsgSubmitTrapJobResultResponse")
	proto.RegisterType((*MsgAppealTrapJobSlashing)(nil), "remes.remes.v1.MsgAppealTrapJobSlashing")
	proto.RegisterType((*MsgAppealTrapJobSlashingResponse)(nil), "remes.remes.v1.MsgAppealTrapJobSlashingResponse")
	proto.RegisterType((*MsgReportLazyValidation)(nil), "remes.remes.v1.MsgReportLazyValidation")
	proto.RegisterType((*MsgReportLazyValidationResponse)(nil), "remes.remes.v1.MsgReportLazyValidationResponse")
	proto.RegisterType((*MsgReportFalseVerdict)(nil), "remes.remes.v1.MsgReportFalseVerdict")
	proto.RegisterType((*MsgReportFalseVerdictResponse)(nil), "remes.remes.v1.MsgReportFalseVerdictResponse")
	proto.RegisterType((*MsgReportProposerCensorship)(nil), "remes.remes.v1.MsgReportProposerCensorship")
	proto.RegisterType((*MsgReportProposerCensorshipResponse)(nil), "remes.remes.v1.MsgReportProposerCensorshipResponse")
	proto.RegisterType((*MsgAppealSlashing)(nil), "remes.remes.v1.MsgAppealSlashing")
	proto.RegisterType((*MsgAppealSlashingResponse)(nil), "remes.remes.v1.MsgAppealSlashingResponse")
	proto.RegisterType((*MsgRegisterMentorRelationship)(nil), "remes.remes.v1.MsgRegisterMentorRelationship")
	proto.RegisterType((*MsgRegisterMentorRelationshipResponse)(nil), "remes.remes.v1.MsgRegisterMentorRelationshipResponse")
	proto.RegisterType((*MsgProposeExecutionEnvironment)(nil), "remes.remes.v1.MsgProposeExecutionEnvironment")
	proto.RegisterType((*MsgProposeExecutionEnvironmentResponse)(nil), "remes.remes.v1.MsgProposeExecutionEnvironmentResponse")
	proto.RegisterType((*MsgVoteExecutionEnvironment)(nil), "remes.remes.v1.MsgVoteExecutionEnvironment")
	proto.RegisterType((*MsgVoteExecutionEnvironmentResponse)(nil), "remes.remes.v1.MsgVoteExecutionEnvironmentResponse")
	proto.RegisterType((*MsgActivateExecutionEnvironment)(nil), "remes.remes.v1.MsgActivateExecutionEnvironment")
	proto.RegisterType((*MsgActivateExecutionEnvironmentResponse)(nil), "remes.remes.v1.MsgActivateExecutionEnvironmentResponse")
	proto.RegisterType((*MsgProposeModelUpgrade)(nil), "remes.remes.v1.MsgProposeModelUpgrade")
	proto.RegisterType((*MsgProposeModelUpgradeResponse)(nil), "remes.remes.v1.MsgProposeModelUpgradeResponse")
	proto.RegisterType((*MsgVoteModelUpgrade)(nil), "remes.remes.v1.MsgVoteModelUpgrade")
	proto.RegisterType((*MsgVoteModelUpgradeResponse)(nil), "remes.remes.v1.MsgVoteModelUpgradeResponse")
	proto.RegisterType((*MsgActivateModelUpgrade)(nil), "remes.remes.v1.MsgActivateModelUpgrade")
	proto.RegisterType((*MsgActivateModelUpgradeResponse)(nil), "remes.remes.v1.MsgActivateModelUpgradeResponse")
	proto.RegisterType((*MsgRollbackModelUpgrade)(nil), "remes.remes.v1.MsgRollbackModelUpgrade")
	proto.RegisterType((*MsgRollbackModelUpgradeResponse)(nil), "remes.remes.v1.MsgRollbackModelUpgradeResponse")
	proto.RegisterType((*MsgCreateSubnet)(nil), "remes.remes.v1.MsgCreateSubnet")
	proto.RegisterType((*MsgCreateSubnetResponse)(nil), "remes.remes.v1.MsgCreateSubnetResponse")
	proto.RegisterType((*MsgSubmitSubnetActivation)(nil), "remes.remes.v1.MsgSubmitSubnetActivation")
	proto.RegisterType((*MsgSubmitSubnetActivationResponse)(nil), "remes.remes.v1.MsgSubmitSubnetActivationResponse")
	proto.RegisterType((*MsgAssignMinerToSubnet)(nil), "remes.remes.v1.MsgAssignMinerToSubnet")
	proto.RegisterType((*MsgAssignMinerToSubnetResponse)(nil), "remes.remes.v1.MsgAssignMinerToSubnetResponse")
	proto.RegisterType((*MsgCreateTrainingWindow)(nil), "remes.remes.v1.MsgCreateTrainingWindow")
	proto.RegisterType((*MsgCreateTrainingWindowResponse)(nil), "remes.remes.v1.MsgCreateTrainingWindowResponse")
	proto.RegisterType((*MsgSubmitAsyncGradient)(nil), "remes.remes.v1.MsgSubmitAsyncGradient")
	proto.RegisterType((*MsgSubmitAsyncGradientResponse)(nil), "remes.remes.v1.MsgSubmitAsyncGradientResponse")
	proto.RegisterType((*MsgSubmitLazyAggregation)(nil), "remes.remes.v1.MsgSubmitLazyAggregation")
	proto.RegisterType((*MsgSubmitLazyAggregationResponse)(nil), "remes.remes.v1.MsgSubmitLazyAggregationResponse")
}

func init() { proto.RegisterFile("remes/remes/v1/tx.proto", fileDescriptor_c13a783cd5e883ea) }

var fileDescriptor_c13a783cd5e883ea = []byte{
	// 4832 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x7c, 0x4d, 0x8c, 0x1c, 0x49,
	0x56, 0xf0, 0x54, 0x55, 0xff, 0x55, 0x74, 0xf5, 0x5f, 0xba, 0xdd, 0x2e, 0x97, 0xed, 0xee, 0x76,
	0xb6, 0xdb, 0x6e, 0xdb, 0xe3, 0xee, 0x71, 0xdb, 0x9e, 0xb5, 0x7b, 0xbc, 0xfe, 0xa6, 0xfd, 0xf3,
	0xcd, 0x14, 0x72, 0xcf, 0x58, 0xd5, 0xb6, 0x67, 0x05, 0x12, 0xa9, 0xec, 0xca, 0xe8, 0xea, 0x1c,
	0x67, 0x65, 0xe4, 0x66, 0x64, 0x95, 0xdd, 0x2b, 0x0e, 0xab, 0x95, 0x10, 0x82, 0x03, 0x82, 0x03,
	0x88, 0x03, 0x82, 0x1b, 0x5a, 0xa1, 0x45, 0x1a, 0xa1, 0x15, 0x9c, 0xb8, 0x70, 0x40, 0x0b, 0x17,
	0x46, 0x9c, 0x80, 0xc3, 0x6a, 0x35, 0x73, 0x98, 0x2b, 0x88, 0x05, 0x24, 0x10, 0x08, 0xc5, 0x4f,
	0x46, 0x46, 0x64, 0x46, 0x56, 0x65, 0x77, 0x1b, 0x71, 0x69, 0x55, 0xbe, 0xf7, 0x32, 0x23, 0xde,
	0x6f, 0xc4, 0x8b, 0xf7, 0xa2, 0xc1, 0x99, 0x10, 0x76, 0x21, 0xde, 0x60, 0x7f, 0xfb, 0x37, 0x37,
	0xa2, 0x37, 0xeb, 0x41, 0x88, 0x22, 0x64, 0x4c, 0x53, 0xd0, 0x3a, 0xfb, 0xdb, 0xbf, 0xd9, 0x98,
	0xb3, 0xbb, 0xae, 0x8f, 0x36, 0xe8, 0x5f, 0x46, 0xd2, 0x38, 0xd3, 0x46, 0xb8, 0x8b, 0xf0, 0x46,
	0x17, 0x77, 0xc8, 0xab, 0x5d, 0xdc, 0xe1, 0x88, 0xb3, 0x0c, 0x61, 0xd1, 0xa7, 0x0d, 0xf6, 0xc0,
	0x51, 0xf3, 0x1d, 0xd4, 0x41, 0x0c, 0x4e, 0x7e, 0x71, 0xe8, 0xb9, 0xd4, 0x2c, 0x02, 0x3b, 0xb4,
	0xbb, 0xf1, 0x2b, 0x8d, 0x14, 0xb2, 0x8b, 0x1c, 0xe8, 0x71, 0xdc, 0xa5, 0x14, 0x0e, 0x47, 0x28,
	0x84, 0x8e, 0xd5, 0x09, 0x6d, 0xc7, 0x85, 0x7e, 0xc4, 0xa9, 0xce, 0xa7, 0xa8, 0x1c, 0x3b, 0xb2,
	0x31, 0x8c, 0xb1, 0x67, 0x53, 0x58, 0x1f, 0x39, 0x30, 0xe7, 0xc5, 0xc0, 0xf5, 0x7d, 0xd7, 0xef,
	0xe4, 0x60, 0x31, 0x0c, 0xfb, 0x09, 0xf6, 0x42, 0x5a, 0xb2, 0xa1, 0x1d, 0x58, 0x9f, 0xa3, 0xbd,
	0x1c, 0x34, 0xf6, 0x6c, 0x7c, 0x90, 0xbc, 0x7d, 0x2d, 0x85, 0x86, 0x6f, 0x60, 0xbb, 0x17, 0xb9,
	0xc8, 0xb7, 0xa0, 0xdf, 0x77, 0x43, 0xe4, 0x77, 0x13, 0xf6, 0x4c, 0x9d, 0x80, 0xac, 0x3e, 0x0c,
	0xb1, 0x8b, 0xfc, 0x1c, 0x09, 0xe3, 0xde, 0x9e, 0x2f, 0x24, 0x70, 0x29, 0x3b, 0x55, 0x97, 0xf0,
	0x69, 0xbd, 0x76, 0x7d, 0x07, 0xbd, 0xe6, 0x54, 0x8b, 0x5c, 0xdd, 0x7b, 0x36, 0x86, 0x1b, 0xfd,
	0x9b, 0x7b, 0x30, 0xb2, 0x6f, 0x6e, 0xb4, 0x91, 0xcb, 0x87, 0x30, 0xff, 0xac, 0x04, 0x66, 0x76,
	0x70, 0xe7, 0x45, 0xe0, 0xd8, 0x11, 0x7c, 0x46, 0x35, 0x68, 0xbc, 0x0f, 0xaa, 0x76, 0x2f, 0x3a,
	0x40, 0xa1, 0x1b, 0x1d, 0xd6, 0x4b, 0xcb, 0xa5, 0xb5, 0xea, 0xc3, 0xfa, 0xdf, 0xfd, 0xf8, 0xc6,
	0x3c, 0xb7, 0x89, 0x6d, 0xc7, 0x09, 0x21, 0xc6, 0xbb, 0x51, 0xe8, 0xfa, 0x9d, 0x56, 0x42, 0x6a,
	0xdc, 0x03, 0x63, 0xcc, 0x06, 0xea, 0xe5, 0xe5, 0xd2, 0xda, 0xe4, 0xe6, 0xc2, 0xba, 0x6a, 0x8e,
	0xeb, 0xec, 0xfb, 0x0f, 0xab, 0x3f, 0xf9, 0xe9, 0xd2, 0x3b, 0x3f, 0xfc, 0xe6, 0x8b, 0x6b, 0xa5,
	0x16, 0x7f, 0x61, 0xeb, 0xbd, 0x1f, 0x7c, 0xf3, 0xc5, 0xb5, 0xe4, 0x53, 0xbf, 0xf1, 0xcd, 0x17,
	0xd7, 0xb8, 0xac, 0xdf, 0x70, 0x0e, 0x53, 0x93, 0x34, 0xcf, 0x82, 0x33, 0x29, 0x50, 0x0b, 0xe2,
	0x00, 0xf9, 0x18, 0x9a, 0xff, 0x50, 0x02, 0xb3, 0x3b, 0xb8, 0xd3, 0x82, 0x1d, 0x17, 0x47, 0x30,
	0xdc, 0x21, 0x92, 0x3d, 0x09, 0x53, 0x6d, 0xe4, 0xef, 0xbb, 0x1d, 0xce, 0xd4, 0xb9, 0x34, 0x53,
	0xf4, 0xf3, 0x8f, 0x28, 0xc9, 0xc3, 0x11, 0xc2, 0x59, 0x8b, 0xbf, 0x60, 0x2c, 0x81, 0xc9, 0x20,
	0x44, 0x01, 0xc2, 0xb6, 0x67, 0xb9, 0x4e, 0xbd, 0xb2, 0x5c, 0x5a, 0x1b, 0x69, 0x81, 0x18, 0xd4,
	0x74, 0xb6, 0x6e, 0x66, 0xb9, 0x5e, 0xcc, 0x70, 0xad, 0xb0, 0x61, 0xde, 0x01, 0xf5, 0x34, 0x2c,
	0xe6, 0xdb, 0x38, 0x0b, 0x26, 0x98, 0x15, 0xb9, 0x0e, 0xe5, 0x70, 0xa4, 0x35, 0x4e, 0x9f, 0x9b,
	0x8e, 0xf9, 0x7b, 0x4c, 0x24, 0xdb, 0xed, 0xc8, 0xed, 0xdb, 0x11, 0x3c, 0x99, 0x48, 0xe4, 0x71,
	0xca, 0xca, 0x38, 0xc5, 0x38, 0x52, 0x66, 0x61, 0x36, 0x28, 0x47, 0x0a, 0x4c, 0x68, 0xf2, 0x8f,
	0x46, 0xc1, 0xdc, 0x0e, 0xee, 0xec, 0xf6, 0xf6, 0xba, 0x6e, 0xf4, 0x11, 0x8f, 0x0f, 0xc6, 0x3a,
	0x18, 0xed, 0xba, 0x3e, 0x0c, 0x87, 0xce, 0x99, 0x91, 0x19, 0xe7, 0x40, 0xd5, 0x0d, 0xf6, 0xb1,
	0x75, 0x60, 0xe3, 0x03, 0x3a, 0xe1, 0x6a, 0x6b, 0x82, 0x00, 0x3e, 0xb6, 0xf1, 0x81, 0xb1, 0x02,
	0xa6, 0x14, 0xd7, 0xa3, 0x6a, 0xaa, 0xb6, 0x6a, 0x14, 0xf8, 0x92, 0xc1, 0x8c, 0x6b, 0x60, 0x4e,
	0xb8, 0x57, 0x88, 0x7a, 0xbe, 0x43, 0x58, 0x1f, 0xa1, 0xac, 0xcf, 0xc4, 0x88, 0x16, 0x81, 0x37,
	0x1d, 0x22, 0x1d, 0x7c, 0x60, 0x87, 0x94, 0x64, 0x94, 0x49, 0x87, 0x3e, 0x37, 0x1d, 0x32, 0x56,
	0x1c, 0xe4, 0xd8, 0x64, 0xc6, 0xd8, 0x58, 0x31, 0x90, 0x4e, 0xe8, 0x2a, 0x98, 0xed, 0x04, 0x3d,
	0xcb, 0x0e, 0xdb, 0x07, 0x6e, 0x04, 0xdb, 0x51, 0x2f, 0x84, 0xf5, 0x71, 0x4a, 0x37, 0xd3, 0x09,
	0x7a, 0xdb, 0x12, 0xd8, 0x98, 0x07, 0xa3, 0x3e, 0xf2, 0xdb, 0xb0, 0x3e, 0x41, 0xc7, 0x61, 0x0f,
	0xc6, 0x79, 0x50, 0xc5, 0x6e, 0xc7, 0xb7, 0xe9, 0x9b, 0xd5, 0xe5, 0xd2, 0x5a, 0xad, 0x95, 0x00,
	0x8c, 0x1b, 0xe0, 0x54, 0x10, 0x22, 0xb4, 0x6f, 0xa1, 0x7d, 0xeb, 0x35, 0x0a, 0x5f, 0x59, 0xec,
	0x0b, 0x80, 0x7e, 0x61, 0x96, 0xa2, 0x3e, 0xdd, 0xff, 0x0c, 0x85, 0xaf, 0x3e, 0xa1, 0x1f, 0xbb,
	0x0c, 0x66, 0x98, 0x78, 0x98, 0x4d, 0x13, 0xa6, 0x26, 0x29, 0x29, 0x93, 0x1a, 0xb3, 0xfb, 0xa6,
	0x63, 0xac, 0x82, 0xe9, 0x36, 0xf2, 0x23, 0x9b, 0x08, 0x9c, 0xf1, 0x56, 0xa3, 0x73, 0x9e, 0x12,
	0x50, 0xca, 0xdc, 0x06, 0x38, 0x95, 0x90, 0x25, 0xb3, 0x9c, 0xa2, 0xb3, 0x34, 0x04, 0x6a, 0x57,
	0x4c, 0x77, 0x09, 0x4c, 0x76, 0x3c, 0xb4, 0x67, 0x7b, 0x16, 0x86, 0xd0, 0xa9, 0x4f, 0x33, 0x1f,
	0x62, 0xa0, 0x5d, 0x08, 0x1d, 0xe3, 0x22, 0xa8, 0xb5, 0x3d, 0xdb, 0xed, 0x42, 0xc7, 0xf2, 0x10,
	0xc6, 0xf5, 0x19, 0x3a, 0xec, 0x24, 0x87, 0x3d, 0x45, 0x18, 0x1b, 0x37, 0xc1, 0xe9, 0x00, 0x85,
	0x30, 0xb0, 0x18, 0xe3, 0x89, 0x2d, 0xcc, 0x52, 0x5a, 0x83, 0x22, 0x9f, 0x11, 0x5c, 0x93, 0x5b,
	0xc5, 0xd6, 0x3a, 0xb1, 0x63, 0x66, 0x3e, 0xc4, 0x86, 0x97, 0x32, 0x36, 0xac, 0x9a, 0xa4, 0xb9,
	0x07, 0xce, 0x66, 0x80, 0xc2, 0x2f, 0xdf, 0x05, 0x46, 0x6a, 0x89, 0x4b, 0x3c, 0x74, 0x96, 0x61,
	0xe2, 0x77, 0x9a, 0x8e, 0x71, 0x06, 0x8c, 0x47, 0x6f, 0x64, 0x5b, 0x1d, 0x8b, 0xde, 0x90, 0x39,
	0x99, 0xff, 0x5c, 0x06, 0xf3, 0x62, 0x90, 0xed, 0x4e, 0x27, 0x84, 0x1d, 0x9b, 0x2c, 0x2e, 0xc6,
	0x6d, 0x30, 0xc1, 0x82, 0x4a, 0x01, 0x97, 0x10, 0x94, 0xc6, 0x36, 0xb8, 0x60, 0xf3, 0x8f, 0x28,
	0x33, 0x4b, 0x79, 0x4a, 0x23, 0x21, 0x12, 0x93, 0x8c, 0x7d, 0x67, 0x09, 0x4c, 0x76, 0x61, 0xf8,
	0xca, 0x83, 0x56, 0x88, 0x50, 0xc4, 0x3d, 0x07, 0x30, 0x50, 0x0b, 0xa1, 0xc8, 0xb8, 0x0b, 0xea,
	0x81, 0x1d, 0x46, 0x6e, 0xdb, 0x0d, 0x6c, 0x3f, 0x92, 0xd9, 0xc7, 0xf5, 0x91, 0xe5, 0xca, 0xda,
	0x48, 0x6b, 0x41, 0xc2, 0x27, 0x42, 0xc0, 0x7a, 0x8f, 0x1b, 0xd5, 0x7b, 0x5c, 0xc6, 0x85, 0xc7,
	0xb2, 0x2e, 0xbc, 0x75, 0x9b, 0x68, 0x54, 0x70, 0x4f, 0x94, 0x6a, 0xe6, 0x28, 0x55, 0x12, 0xad,
	0xf9, 0x04, 0x9c, 0xd7, 0xc1, 0x85, 0x6a, 0x57, 0xc1, 0xb4, 0x9d, 0x80, 0x13, 0xb5, 0x4e, 0x49,
	0xd0, 0xa6, 0x63, 0xfe, 0x36, 0x53, 0xdd, 0x23, 0xd4, 0x7d, 0x2b, 0xaa, 0xbb, 0x02, 0x66, 0xda,
	0xf4, 0x53, 0x5d, 0x11, 0x49, 0x98, 0xb2, 0xa6, 0x13, 0x30, 0x55, 0x90, 0x56, 0x8a, 0x15, 0xbd,
	0x14, 0x8f, 0xad, 0xab, 0x42, 0xa2, 0xcd, 0xb0, 0x6e, 0x1e, 0x52, 0xd1, 0x66, 0xe0, 0x42, 0xb4,
	0x2b, 0x60, 0x4a, 0x62, 0x52, 0x48, 0xb6, 0x96, 0x00, 0x9b, 0x8e, 0x71, 0x1b, 0x2c, 0x84, 0xb0,
	0x0f, 0x6d, 0xcf, 0x72, 0xa0, 0xed, 0x78, 0xae, 0x0f, 0xad, 0x03, 0xe8, 0x76, 0x0e, 0x22, 0x2a,
	0x90, 0x4a, 0x6b, 0x9e, 0x61, 0x1f, 0x73, 0xe4, 0xc7, 0x14, 0x67, 0xfe, 0x71, 0x85, 0xaa, 0xa3,
	0x45, 0x71, 0x27, 0x57, 0x47, 0x66, 0xa6, 0x65, 0xcd, 0x4c, 0x87, 0xba, 0x5b, 0xe5, 0xa8, 0xee,
	0x36, 0x72, 0x24, 0x77, 0x1b, 0x3d, 0xba, 0xbb, 0x8d, 0x15, 0x74, 0xb7, 0x71, 0xcd, 0x8a, 0x69,
	0x80, 0x11, 0x6c, 0x7b, 0x11, 0x5d, 0x99, 0xaa, 0x2d, 0xfa, 0xbb, 0x90, 0x9d, 0x64, 0x74, 0x62,
	0xf6, 0xa9, 0x9d, 0x64, 0xe0, 0x47, 0x74, 0x41, 0xb6, 0xf2, 0x08, 0x25, 0xf5, 0x61, 0xe8, 0xee,
	0xbb, 0x90, 0xa9, 0x6a, 0x82, 0xac, 0x3c, 0x31, 0xea, 0x25, 0xc7, 0x98, 0x7f, 0x51, 0xa6, 0x3b,
	0xcc, 0x47, 0x07, 0xb6, 0xe7, 0x41, 0xbf, 0x03, 0x65, 0x3b, 0xb9, 0x0b, 0x40, 0x3b, 0x86, 0x0f,
	0xb7, 0x14, 0x89, 0x56, 0x33, 0xdb, 0xb2, 0x6e, 0xb6, 0x0b, 0x60, 0x2c, 0x84, 0x36, 0x16, 0xdb,
	0x11, 0xfe, 0x44, 0x96, 0x12, 0xd8, 0x77, 0x1d, 0xe8, 0xb7, 0xa1, 0x64, 0x3a, 0xcc, 0x12, 0x66,
	0x63, 0x8c, 0x30, 0x98, 0x0f, 0xc1, 0xe4, 0x1e, 0xf2, 0x1d, 0xcb, 0xee, 0xa2, 0x9e, 0x1f, 0x51,
	0x13, 0x98, 0xdc, 0x3c, 0xbb, 0xce, 0x27, 0x49, 0x52, 0x82, 0x75, 0x9e, 0x12, 0xac, 0x3f, 0x42,
	0xae, 0xcf, 0xb7, 0xaf, 0x80, 0xbc, 0xb3, 0x4d, 0x5f, 0xd9, 0xba, 0x47, 0x54, 0x26, 0xcd, 0x9f,
	0x28, 0x6d, 0x35, 0xeb, 0xdc, 0x1a, 0x19, 0x99, 0x8f, 0xc1, 0x52, 0x0e, 0x4a, 0xa8, 0x8e, 0xac,
	0xdd, 0x31, 0x3e, 0x51, 0xdc, 0xa4, 0x80, 0x35, 0x1d, 0xf3, 0x57, 0xcb, 0x74, 0x07, 0xf8, 0x8c,
	0x19, 0xcd, 0x63, 0x96, 0x03, 0x1e, 0xd3, 0x4f, 0xaf, 0x81, 0x39, 0x9e, 0x44, 0x66, 0x56, 0xb9,
	0x19, 0x8e, 0x10, 0xa2, 0xdb, 0x06, 0x13, 0x5d, 0x18, 0xd9, 0x04, 0x4c, 0x55, 0x30, 0xb9, 0xb9,
	0x94, 0xde, 0xf8, 0xf3, 0xc9, 0xec, 0x70, 0x32, 0x2e, 0x3d, 0xf1, 0x9a, 0x51, 0x07, 0xe3, 0x0e,
	0x0c, 0x10, 0x76, 0x63, 0x57, 0x8d, 0x1f, 0xd9, 0x2e, 0x59, 0x71, 0x84, 0xec, 0x06, 0x43, 0xe5,
	0xd8, 0xbc, 0x4f, 0x37, 0x18, 0x2a, 0x50, 0xc8, 0x31, 0x95, 0x68, 0x94, 0xd2, 0x89, 0x86, 0xf9,
	0xf3, 0x12, 0x98, 0xde, 0xc1, 0x9d, 0x97, 0x28, 0x12, 0x22, 0x5c, 0x07, 0xa3, 0x7d, 0x14, 0x15,
	0xd9, 0x44, 0x53, 0xb2, 0xf4, 0x18, 0xe5, 0xf4, 0x18, 0xc4, 0x64, 0x51, 0x10, 0x25, 0x3b, 0x68,
	0xfe, 0x44, 0xc2, 0xc5, 0x77, 0x7b, 0xb6, 0xe7, 0x46, 0x87, 0x16, 0x6e, 0xa3, 0x10, 0x52, 0x61,
	0x4c, 0xb5, 0x6a, 0x1c, 0xb8, 0x4b, 0x60, 0x64, 0x45, 0x0b, 0xa1, 0x07, 0xfb, 0x36, 0x31, 0x6c,
	0x46, 0x36, 0x4a, 0xc9, 0xa6, 0x05, 0x98, 0x12, 0x6e, 0x5d, 0xa7, 0x1b, 0x33, 0x3a, 0x25, 0x22,
	0xb7, 0xf3, 0x19, 0xb9, 0x49, 0x3c, 0x9a, 0x37, 0xc1, 0x82, 0x0a, 0x11, 0x12, 0x3b, 0x03, 0xc6,
	0xc9, 0x37, 0x12, 0x69, 0x8d, 0x91, 0xc7, 0xa6, 0x63, 0xfe, 0xa8, 0x44, 0xd3, 0x91, 0x1d, 0x3b,
	0x7c, 0xc5, 0xdf, 0xd9, 0xc6, 0x9f, 0xee, 0xef, 0xbb, 0x6d, 0xd7, 0x3e, 0x7e, 0xc2, 0x74, 0x01,
	0x00, 0x61, 0x78, 0xb1, 0xe8, 0xaa, 0xb1, 0xc5, 0x39, 0xcc, 0xc9, 0xd4, 0xa4, 0xe9, 0x72, 0x86,
	0x2f, 0xed, 0x8c, 0x4c, 0x13, 0x2c, 0xe7, 0xe1, 0x44, 0x12, 0xf5, 0xe3, 0x38, 0x1d, 0xee, 0xa2,
	0xbe, 0x50, 0xff, 0xff, 0x0e, 0x2b, 0x79, 0x71, 0xab, 0x68, 0xa6, 0x2b, 0xcd, 0x90, 0xe7, 0x85,
	0x0a, 0x4c, 0xb0, 0xf4, 0x57, 0x15, 0x7a, 0x6a, 0x11, 0xa7, 0xc1, 0x9f, 0x20, 0x07, 0x1a, 0x1f,
	0x80, 0x9a, 0x8f, 0x1c, 0x68, 0xd9, 0x6c, 0xea, 0x43, 0x99, 0x9a, 0x24, 0xd4, 0x1c, 0x64, 0xdc,
	0x01, 0x55, 0xfa, 0x72, 0x74, 0x18, 0x40, 0xca, 0xd5, 0xf4, 0x66, 0x3d, 0xed, 0xef, 0x64, 0x94,
	0xe7, 0x87, 0x01, 0x6c, 0x4d, 0xf8, 0xfc, 0x97, 0xf1, 0x21, 0xa8, 0x86, 0x10, 0xa3, 0x5e, 0xd8,
	0x86, 0x98, 0x87, 0x89, 0xf3, 0xe9, 0xd7, 0x5a, 0x9c, 0x60, 0x37, 0x80, 0x6d, 0x1e, 0x23, 0x92,
	0x97, 0x48, 0x0a, 0x87, 0x23, 0xfb, 0x15, 0xe4, 0x21, 0x82, 0x3d, 0x10, 0xe7, 0x0c, 0x91, 0x07,
	0xd9, 0xaa, 0x3d, 0x68, 0x2a, 0x8c, 0xcc, 0x68, 0x82, 0x59, 0xf2, 0xc3, 0xb2, 0x3d, 0x0f, 0xb5,
	0x69, 0x8c, 0xc5, 0xf5, 0x31, 0x1a, 0xed, 0x17, 0x33, 0xd3, 0x41, 0x1e, 0xdc, 0x16, 0x64, 0xad,
	0x99, 0x50, 0x79, 0xc6, 0xc6, 0xb7, 0x40, 0x3d, 0x9e, 0x5d, 0x26, 0x5f, 0x62, 0x0b, 0xfd, 0xe9,
	0x18, 0xaf, 0xa6, 0x4c, 0xb7, 0x88, 0x8a, 0x15, 0x15, 0xe8, 0x4f, 0x71, 0x64, 0xa5, 0x99, 0x0f,
	0xe9, 0x1a, 0x2b, 0x83, 0x84, 0x8b, 0xd2, 0x90, 0x40, 0xe0, 0x61, 0x6a, 0x61, 0x9f, 0x96, 0xc1,
	0x4d, 0xc7, 0xfc, 0xb5, 0x0a, 0x8d, 0x8d, 0xec, 0x28, 0x88, 0x7d, 0x22, 0xc1, 0x9f, 0xcc, 0x2c,
	0xb6, 0x64, 0xfd, 0x96, 0x87, 0xeb, 0x57, 0xd6, 0xac, 0xd0, 0x61, 0xe5, 0xf8, 0x3a, 0x1c, 0x79,
	0xfb, 0x3a, 0x1c, 0x1d, 0xa4, 0xc3, 0x6f, 0x6b, 0x75, 0x78, 0x25, 0xe7, 0x24, 0x2e, 0x2d, 0x6b,
	0x73, 0x05, 0x5c, 0xcc, 0x45, 0x0a, 0xdf, 0xfd, 0xd3, 0x32, 0x8d, 0xca, 0x2c, 0xa7, 0x8a, 0x85,
	0xf7, 0x02, 0xdb, 0x9d, 0x13, 0xba, 0xf0, 0xbb, 0x60, 0x84, 0xc8, 0x61, 0xa8, 0xf7, 0x52, 0x2a,
	0xa3, 0x09, 0xa6, 0x85, 0x88, 0x7a, 0x64, 0xf0, 0x23, 0xb8, 0xef, 0x54, 0xa8, 0xcc, 0xfa, 0x32,
	0x98, 0x49, 0x0b, 0x99, 0x39, 0xf3, 0x54, 0xa0, 0x08, 0x77, 0x4b, 0x2b, 0xdc, 0x4b, 0x39, 0x59,
	0xa8, 0x22, 0x19, 0xf3, 0x73, 0xb0, 0xa8, 0xc7, 0xc8, 0x87, 0x7f, 0x2e, 0xb6, 0xfa, 0xb6, 0xc7,
	0xfd, 0x64, 0xa2, 0x35, 0xee, 0xe2, 0x97, 0xe4, 0xd1, 0xb8, 0x01, 0x8c, 0xbe, 0x8b, 0x3c, 0xe6,
	0x46, 0x0e, 0x8c, 0x60, 0x3b, 0x12, 0x3b, 0xdf, 0x39, 0x81, 0x79, 0xcc, 0x11, 0xe6, 0xbf, 0xb1,
	0xf5, 0x82, 0x65, 0x66, 0xcf, 0xd8, 0xe1, 0xf9, 0xc9, 0x54, 0x33, 0xf0, 0x00, 0x4e, 0x44, 0xc0,
	0x8a, 0x1c, 0x01, 0xef, 0x83, 0x86, 0xb4, 0x5d, 0x77, 0x7a, 0x3c, 0x08, 0xec, 0x79, 0xa8, 0xfd,
	0x0a, 0xf3, 0xa3, 0xb7, 0x7a, 0x42, 0xf1, 0x98, 0x13, 0x3c, 0xa4, 0x78, 0x96, 0x69, 0x64, 0x44,
	0xbd, 0x98, 0x93, 0x95, 0x72, 0x1e, 0xcd, 0x7b, 0x74, 0xc5, 0x51, 0x60, 0x42, 0xbc, 0x17, 0x00,
	0xe0, 0x75, 0x84, 0x38, 0x10, 0x55, 0x5b, 0x55, 0x0e, 0x69, 0x3a, 0xe6, 0xcf, 0x4a, 0xe0, 0x94,
	0xbc, 0xdb, 0x8d, 0xc5, 0x76, 0xfc, 0x44, 0x21, 0x2d, 0xf0, 0xf2, 0xb1, 0x05, 0x5e, 0x51, 0x05,
	0xbe, 0x75, 0x47, 0xb3, 0xa7, 0xbf, 0x98, 0xbf, 0xa7, 0x8f, 0xa5, 0xf3, 0x21, 0x38, 0xa7, 0x01,
	0x1f, 0x65, 0x2f, 0xff, 0x8f, 0x25, 0x70, 0x9a, 0x46, 0x7b, 0xf2, 0x8a, 0xf3, 0x1c, 0x89, 0x6f,
	0x9d, 0xcc, 0xba, 0xd2, 0x23, 0x97, 0x33, 0x23, 0xeb, 0x5c, 0xb4, 0xa2, 0x73, 0xd1, 0x7b, 0x5a,
	0xbb, 0x59, 0xd1, 0xac, 0x61, 0x69, 0x16, 0xcc, 0x2d, 0x70, 0x41, 0x8b, 0x28, 0xe0, 0xa0, 0xe6,
	0xbf, 0x33, 0xeb, 0x21, 0x8e, 0xed, 0xf5, 0x61, 0x22, 0x96, 0xdb, 0x60, 0x22, 0x64, 0xb0, 0x02,
	0x69, 0x4e, 0x4c, 0x59, 0x44, 0x1e, 0xab, 0x60, 0x7a, 0x3f, 0xb4, 0x7b, 0x4e, 0x12, 0x0d, 0x2a,
	0x74, 0x46, 0x53, 0x14, 0x1a, 0x47, 0x02, 0xe3, 0x3a, 0x98, 0xa3, 0x5f, 0x65, 0x35, 0x2c, 0xbe,
	0xb1, 0xe3, 0xc9, 0x66, 0x82, 0x68, 0xb1, 0x2d, 0x1e, 0x5d, 0xff, 0xc5, 0x2c, 0xf4, 0x46, 0x95,
	0xe6, 0xd0, 0xbc, 0x47, 0x8d, 0x2a, 0x0d, 0x16, 0x32, 0x6b, 0x08, 0x01, 0xc4, 0x32, 0x13, 0xcf,
	0xe6, 0xef, 0x94, 0xa9, 0xbb, 0xb2, 0x98, 0xf8, 0xe8, 0xd9, 0x0b, 0x96, 0xb8, 0xb3, 0x25, 0x90,
	0x6c, 0x6f, 0xa9, 0xa4, 0xed, 0x08, 0x0d, 0x17, 0x5d, 0x42, 0x5a, 0x44, 0x76, 0xb2, 0x1e, 0x2b,
	0x6a, 0xa0, 0x65, 0x07, 0x41, 0x41, 0x2f, 0x82, 0x8e, 0xbc, 0x0e, 0xd4, 0x62, 0x60, 0x5c, 0x70,
	0x80, 0x6f, 0x02, 0x2a, 0x60, 0x79, 0x45, 0xae, 0xc5, 0xc0, 0xc4, 0x10, 0x93, 0x79, 0xe9, 0x53,
	0x02, 0x2d, 0xeb, 0xe6, 0x03, 0x9a, 0x12, 0x68, 0x71, 0xb2, 0x5c, 0xed, 0x76, 0x1b, 0x06, 0x51,
	0x22, 0xd7, 0xf8, 0xd9, 0xfc, 0xcd, 0x0a, 0xb5, 0x64, 0xbe, 0xd6, 0xd8, 0xbe, 0x83, 0xba, 0xfc,
	0x4c, 0x24, 0x6c, 0x41, 0xdc, 0xf3, 0x68, 0xf6, 0xcd, 0xcf, 0x4f, 0x0a, 0x98, 0x65, 0x4c, 0x59,
	0x44, 0xb4, 0x34, 0x7b, 0x20, 0x43, 0x24, 0xd9, 0x03, 0x1d, 0x30, 0x53, 0x37, 0x19, 0xd1, 0xd4,
	0x4d, 0xf4, 0x47, 0x23, 0xa3, 0x39, 0x47, 0x23, 0x2b, 0x60, 0x2a, 0x9e, 0x19, 0xab, 0x1b, 0xf0,
	0x33, 0xe3, 0x18, 0x48, 0x0b, 0x07, 0x17, 0x00, 0x20, 0x38, 0xab, 0x6b, 0x47, 0x6d, 0xb6, 0xfb,
	0x9d, 0x68, 0x55, 0x09, 0x64, 0x87, 0x00, 0x48, 0x54, 0x21, 0x99, 0x8f, 0xb5, 0x47, 0x9e, 0x58,
	0x7d, 0x82, 0x15, 0x62, 0xa6, 0xe8, 0x79, 0x00, 0x81, 0xee, 0x42, 0xe8, 0xb0, 0x5d, 0x95, 0x10,
	0x04, 0xd1, 0xe5, 0xf5, 0xbc, 0x45, 0x5f, 0x23, 0x6e, 0x13, 0x81, 0xd5, 0x81, 0x04, 0x45, 0xb4,
	0x6a, 0x5c, 0x03, 0x73, 0x9e, 0x7d, 0x08, 0x43, 0xeb, 0x96, 0x15, 0x85, 0x6e, 0xa7, 0x03, 0x43,
	0xb1, 0x05, 0x98, 0xa1, 0x88, 0x5b, 0xcf, 0x63, 0xb0, 0xf9, 0xc3, 0x32, 0x0f, 0x47, 0xdf, 0xed,
	0x41, 0x1c, 0x35, 0xfd, 0x7d, 0x18, 0x12, 0xd9, 0x11, 0xa7, 0x0a, 0x19, 0xac, 0x80, 0xe2, 0x13,
	0x52, 0x12, 0xdd, 0x79, 0x95, 0xdd, 0x22, 0xa1, 0x75, 0xf8, 0x52, 0xc6, 0xa9, 0x69, 0x5a, 0x57,
	0xa8, 0x3e, 0xb7, 0x01, 0xe6, 0x5d, 0x3f, 0xe8, 0x45, 0x16, 0xd5, 0x47, 0x7a, 0x1f, 0x36, 0x47,
	0x71, 0x24, 0x87, 0x14, 0xea, 0x9f, 0x05, 0x95, 0x7d, 0x08, 0xb9, 0x75, 0x90, 0x9f, 0x6c, 0xcb,
	0x90, 0x4c, 0x3a, 0x2f, 0x7e, 0xa9, 0x22, 0x31, 0xef, 0xf3, 0xf8, 0xa5, 0x82, 0xe5, 0x5d, 0x03,
	0xff, 0xa2, 0xb4, 0x6b, 0xe0, 0x90, 0xa6, 0x63, 0xfe, 0x57, 0x49, 0x0a, 0x61, 0xf2, 0xdb, 0xc4,
	0xe8, 0xd3, 0x52, 0x2b, 0x1d, 0x45, 0x6a, 0xea, 0xc0, 0xe5, 0xd4, 0xc0, 0xc6, 0x1a, 0x98, 0x65,
	0xae, 0x95, 0x59, 0x10, 0xa7, 0x19, 0x5c, 0x08, 0x8a, 0xb8, 0x80, 0x1d, 0x41, 0xbf, 0x7d, 0x68,
	0x75, 0xe3, 0x7d, 0x57, 0x95, 0x43, 0x76, 0xf0, 0xd6, 0x7d, 0xba, 0x60, 0xca, 0xf3, 0x1c, 0x14,
	0xaa, 0x52, 0x2c, 0x2a, 0xa1, 0x2a, 0x85, 0x2b, 0x14, 0xaa, 0x7e, 0xbd, 0x0c, 0x1a, 0x22, 0xe1,
	0xd8, 0x4d, 0xd8, 0xdf, 0x8d, 0xec, 0xa8, 0x87, 0x4f, 0x26, 0xc1, 0x8c, 0xdd, 0x95, 0x35, 0x76,
	0x27, 0xaa, 0xa3, 0x99, 0x7d, 0x05, 0x2b, 0x88, 0xc7, 0x52, 0xbc, 0x08, 0x6a, 0x2e, 0xb6, 0xec,
	0xbe, 0xed, 0x7a, 0xf6, 0x9e, 0xc7, 0x92, 0xfd, 0x89, 0xd6, 0xa4, 0x8b, 0xb7, 0x63, 0xd0, 0xd6,
	0x03, 0xad, 0x24, 0xd7, 0x72, 0x52, 0xaf, 0x0c, 0xb3, 0xe6, 0x03, 0x60, 0xe6, 0x63, 0x85, 0x34,
	0xeb, 0x60, 0xbc, 0x47, 0x49, 0xc4, 0x1e, 0x84, 0x3f, 0x9a, 0x7f, 0x52, 0x61, 0xbb, 0xfe, 0x10,
	0xda, 0x11, 0x7c, 0x1e, 0xda, 0xc1, 0x2f, 0xa0, 0x3d, 0x63, 0x13, 0x8c, 0xb7, 0x09, 0xa0, 0xc0,
	0x22, 0x1a, 0x13, 0x12, 0xa9, 0x47, 0x76, 0xd8, 0x81, 0x91, 0xc5, 0x8a, 0xf4, 0x43, 0xbd, 0x9d,
	0x51, 0xef, 0xd0, 0x52, 0xbd, 0xf6, 0x88, 0xb6, 0xa2, 0x3f, 0xa2, 0xbd, 0x0d, 0x16, 0xc4, 0x42,
	0xaa, 0x5b, 0x1e, 0xe6, 0x63, 0xec, 0x47, 0xf2, 0x32, 0x71, 0x05, 0xcc, 0x88, 0x52, 0x11, 0xcf,
	0x26, 0x58, 0x59, 0x71, 0x3a, 0x06, 0xb3, 0x1c, 0xc2, 0xb8, 0x07, 0xce, 0xa2, 0xbd, 0xfd, 0x1e,
	0x6e, 0xdb, 0x11, 0xb4, 0x5e, 0xbb, 0xd1, 0x81, 0xe5, 0xf4, 0xba, 0xdd, 0x43, 0x1a, 0x62, 0xe8,
	0x6a, 0x31, 0xd1, 0x5a, 0x10, 0x04, 0x9f, 0xb9, 0xd1, 0xc1, 0x63, 0x82, 0x26, 0x51, 0xc6, 0xb8,
	0x09, 0xe6, 0xf7, 0xa1, 0x03, 0x43, 0x5a, 0xea, 0x11, 0x55, 0x6e, 0x5c, 0x1f, 0x5f, 0xae, 0xac,
	0xd5, 0x5a, 0xa7, 0x04, 0x4e, 0x94, 0xb9, 0xf1, 0xd6, 0x06, 0x51, 0x7f, 0x2c, 0xc3, 0x9c, 0x64,
	0x45, 0x56, 0x8d, 0xb9, 0xc5, 0x92, 0x15, 0x19, 0x26, 0xb4, 0xbc, 0x08, 0x26, 0xe3, 0xc6, 0x25,
	0x29, 0xee, 0x44, 0x8c, 0xaa, 0xe9, 0x98, 0xff, 0x54, 0x92, 0x52, 0xf0, 0xe4, 0x65, 0x12, 0x75,
	0x8e, 0xda, 0x5b, 0x91, 0x1a, 0xaa, 0x9c, 0x1a, 0x8a, 0xac, 0xca, 0xb9, 0xb5, 0xae, 0xd9, 0x4e,
	0xba, 0xc2, 0x55, 0x64, 0xa1, 0x67, 0x1b, 0xcd, 0xa4, 0x36, 0x9f, 0x97, 0x40, 0x2b, 0x7c, 0x99,
	0xf7, 0xa5, 0x04, 0x5a, 0xc1, 0xc8, 0x81, 0x46, 0x54, 0x85, 0x78, 0xa0, 0x89, 0x9f, 0xcd, 0x7f,
	0x61, 0x81, 0x7a, 0x3b, 0x08, 0xa0, 0xed, 0xf1, 0xd7, 0x77, 0x79, 0xef, 0x17, 0x3d, 0x4a, 0x0d,
	0x02, 0xe8, 0x79, 0xb6, 0x1f, 0x15, 0x38, 0x4a, 0x8d, 0x49, 0x87, 0x8a, 0xee, 0xad, 0xd4, 0x80,
	0xe2, 0xc3, 0xe5, 0x78, 0x54, 0x7d, 0x78, 0xd6, 0x32, 0x66, 0xfe, 0x3f, 0x1a, 0x9e, 0xb5, 0x38,
	0x21, 0xb5, 0x73, 0x8c, 0xf9, 0xa4, 0xf0, 0x50, 0x6d, 0x4d, 0x30, 0x00, 0x5b, 0xdf, 0xd8, 0xf1,
	0x5e, 0x80, 0xc2, 0xe8, 0xa9, 0xfd, 0xbd, 0xc3, 0x97, 0x6c, 0x43, 0xcb, 0x4b, 0xad, 0x21, 0x85,
	0x17, 0xcb, 0x6d, 0x18, 0xa5, 0xf1, 0x04, 0xcc, 0x89, 0x4d, 0x71, 0xe1, 0xd4, 0x78, 0x56, 0xbc,
	0x92, 0x9c, 0x15, 0xe9, 0x44, 0x58, 0xc9, 0x11, 0xe1, 0xb7, 0x78, 0x66, 0xc3, 0xe6, 0xa0, 0x2f,
	0x81, 0xe9, 0x78, 0x34, 0xbf, 0x4d, 0x4b, 0x60, 0x3a, 0x94, 0x9a, 0xe1, 0xd0, 0x0f, 0x4b, 0x19,
	0x0e, 0x7b, 0x36, 0x7f, 0xbf, 0xcc, 0xf3, 0x65, 0xf2, 0xfc, 0xff, 0x6d, 0x0f, 0xc3, 0x97, 0x30,
	0x74, 0xdc, 0x76, 0xf4, 0x7f, 0x2b, 0xbc, 0xf4, 0x46, 0xbe, 0x92, 0xdd, 0xc8, 0x1f, 0xcd, 0x44,
	0xef, 0x64, 0xe4, 0xbb, 0x92, 0x23, 0x5f, 0x59, 0x08, 0xe6, 0x07, 0x3c, 0xe3, 0x4e, 0x23, 0x0a,
	0xc9, 0xf6, 0xa7, 0x65, 0xbe, 0x73, 0x23, 0xcf, 0xbc, 0xac, 0x16, 0x3e, 0x82, 0x3e, 0x46, 0x21,
	0x3e, 0x70, 0x83, 0x63, 0x4a, 0xf8, 0x11, 0x98, 0x8d, 0xab, 0x7a, 0x85, 0x05, 0x3c, 0x13, 0xbf,
	0x11, 0xcb, 0x37, 0x5b, 0x22, 0xae, 0xe8, 0x4a, 0xc4, 0x9b, 0xe0, 0x34, 0x7c, 0xd3, 0xf6, 0x7a,
	0x8e, 0xda, 0x57, 0x14, 0x37, 0x6b, 0x9c, 0x8a, 0x91, 0x72, 0x99, 0xff, 0x48, 0x39, 0xd2, 0xd6,
	0x07, 0x19, 0xbd, 0x5c, 0xcd, 0xd1, 0x4b, 0x56, 0x80, 0xe6, 0x36, 0x58, 0x19, 0x80, 0x2e, 0xa4,
	0xa3, 0xff, 0x2c, 0xd1, 0xda, 0x2f, 0x0b, 0x40, 0x27, 0x0e, 0xb7, 0x57, 0xc0, 0x4c, 0xdc, 0xae,
	0x1b, 0x1f, 0x65, 0xf0, 0xa6, 0x19, 0x2c, 0x82, 0x1a, 0x8d, 0xaf, 0x2b, 0x60, 0x8a, 0x87, 0x34,
	0x25, 0xfc, 0xd6, 0x18, 0xb0, 0x75, 0x9c, 0x20, 0xbc, 0x99, 0x0d, 0xc2, 0x4b, 0x39, 0x41, 0x58,
	0x44, 0xdf, 0xbb, 0xb4, 0xaa, 0xa1, 0x02, 0x8b, 0x85, 0xdd, 0xff, 0x28, 0x71, 0xcf, 0xe0, 0x4d,
	0xa2, 0xd0, 0x8f, 0x50, 0xd8, 0x82, 0xec, 0x98, 0x97, 0x5a, 0xf7, 0x7b, 0x60, 0xac, 0x4b, 0xa1,
	0x43, 0x05, 0xc8, 0xe9, 0xe2, 0x37, 0xe0, 0xf0, 0xec, 0x8d, 0xd3, 0x19, 0x77, 0x41, 0x3d, 0x84,
	0x4e, 0xaf, 0x4d, 0xb6, 0x40, 0x91, 0xfd, 0x0a, 0x5a, 0x01, 0x0c, 0xdb, 0xd0, 0x8f, 0xe2, 0xb3,
	0xf6, 0x6a, 0x6b, 0x81, 0xe3, 0x77, 0x09, 0xfa, 0x99, 0xc0, 0x32, 0xbb, 0xe3, 0x03, 0xeb, 0xb3,
	0xe5, 0x7c, 0xd6, 0xcc, 0x8f, 0x68, 0xb6, 0x9c, 0x4f, 0x20, 0x6d, 0x92, 0x40, 0xc8, 0xa9, 0x84,
	0xed, 0x49, 0x10, 0xf3, 0xbf, 0x4b, 0x74, 0xcb, 0xc0, 0x6d, 0xf7, 0x49, 0xdc, 0xca, 0xfd, 0x24,
	0xe9, 0xe4, 0x3e, 0x66, 0x1b, 0xc2, 0x53, 0x30, 0x29, 0xb5, 0x83, 0xf3, 0xb2, 0xd2, 0xa5, 0x74,
	0xdd, 0x41, 0x37, 0x20, 0xaf, 0x3f, 0xc8, 0xaf, 0xcb, 0x5d, 0x06, 0x15, 0xb5, 0xcb, 0xe0, 0x41,
	0xa6, 0xcb, 0xe0, 0xdd, 0xbc, 0x2e, 0x03, 0xdd, 0x60, 0x66, 0x13, 0x5c, 0x1e, 0x4c, 0x51, 0xbc,
	0xff, 0xe0, 0xaf, 0x4b, 0x34, 0xda, 0xbe, 0x44, 0x91, 0x5e, 0x90, 0x6f, 0xbd, 0x19, 0x61, 0x09,
	0x4c, 0xd2, 0xfa, 0xbe, 0xd2, 0x91, 0x00, 0x08, 0xe8, 0x53, 0x0a, 0xd9, 0xba, 0xab, 0xf6, 0x11,
	0x5c, 0xd5, 0xf6, 0x11, 0x68, 0xc5, 0xf2, 0x80, 0x06, 0xb6, 0x3c, 0xf4, 0xf0, 0x0e, 0x83, 0xbf,
	0x2c, 0xd1, 0x5d, 0x41, 0xdc, 0xf0, 0xac, 0x95, 0xc7, 0x71, 0xab, 0xf3, 0xab, 0x60, 0x5a, 0xb2,
	0x8d, 0x64, 0x57, 0x39, 0x25, 0x41, 0x9b, 0xce, 0xd6, 0x87, 0xd9, 0x6a, 0xfc, 0x8d, 0xdc, 0x2e,
	0x6d, 0xad, 0x10, 0xae, 0x82, 0x2b, 0x43, 0x48, 0x44, 0xbd, 0xef, 0xcb, 0x0a, 0x4d, 0x36, 0xb8,
	0x1d, 0xd1, 0xfe, 0xee, 0x17, 0x01, 0x59, 0xb0, 0xe0, 0xf1, 0xdb, 0x78, 0x7c, 0xf8, 0xda, 0xca,
	0x66, 0xe7, 0x23, 0xad, 0x19, 0x1f, 0xbe, 0xde, 0x91, 0x13, 0xf4, 0x4b, 0x60, 0x3a, 0xa1, 0x95,
	0x36, 0x79, 0xb5, 0x98, 0x90, 0xa6, 0x1d, 0xcb, 0xa0, 0x96, 0x50, 0x89, 0xce, 0x6e, 0x10, 0xd3,
	0x34, 0x1d, 0x51, 0x50, 0x09, 0xec, 0x28, 0x5e, 0x2f, 0x69, 0x41, 0xe5, 0x99, 0x1d, 0x1d, 0x18,
	0x26, 0xa8, 0x29, 0xdd, 0xda, 0xfc, 0x28, 0x51, 0x86, 0x19, 0x37, 0x80, 0xd1, 0x46, 0xdd, 0xc0,
	0x8e, 0xdc, 0x3d, 0x97, 0xf6, 0xc2, 0xb8, 0xfe, 0x3e, 0xe2, 0x05, 0xf5, 0x39, 0x05, 0xd3, 0xf4,
	0xf7, 0x91, 0x71, 0x15, 0xcc, 0x76, 0xdd, 0x0e, 0x2f, 0x7a, 0xb1, 0x0b, 0x1d, 0xf4, 0x6c, 0xb1,
	0xd2, 0x9a, 0x11, 0xf0, 0xcf, 0x28, 0xd8, 0xb8, 0x97, 0x04, 0x80, 0x6a, 0xb1, 0x06, 0x2f, 0x11,
	0x21, 0xde, 0xcf, 0x44, 0x88, 0x4b, 0x79, 0x11, 0x42, 0xd6, 0x9b, 0xb9, 0x2d, 0x47, 0x46, 0x19,
	0x53, 0x3c, 0x22, 0xfc, 0x88, 0x95, 0x3c, 0x88, 0x1b, 0x29, 0x26, 0xf1, 0xd6, 0x23, 0x81, 0x01,
	0x46, 0x08, 0x25, 0xd7, 0x3b, 0xfd, 0xcd, 0x6e, 0x9b, 0x24, 0xce, 0x7f, 0x51, 0xeb, 0xfc, 0x0a,
	0xc7, 0x17, 0x44, 0xfc, 0xd2, 0xb1, 0x4b, 0xb8, 0x39, 0x93, 0xbe, 0xc4, 0x10, 0x73, 0x74, 0x5c,
	0x5f, 0x1e, 0xc6, 0x19, 0x0b, 0x61, 0xaa, 0x17, 0xaf, 0x0e, 0xbe, 0x6b, 0x11, 0x73, 0xf3, 0xb1,
	0x12, 0x81, 0xb4, 0x0a, 0x5c, 0x05, 0xd3, 0xdc, 0xb5, 0x2c, 0xbf, 0xd7, 0xdd, 0xe3, 0x0a, 0x19,
	0x69, 0x4d, 0x71, 0xe8, 0x27, 0x14, 0x68, 0xfe, 0x0d, 0xcf, 0xf0, 0x90, 0xe7, 0xed, 0xd9, 0xed,
	0x57, 0x6f, 0x85, 0xf1, 0xec, 0xd0, 0x65, 0xcd, 0xd0, 0xb9, 0xad, 0x46, 0x85, 0xc4, 0xa2, 0x9b,
	0xb0, 0x79, 0x91, 0xa5, 0x6b, 0x1a, 0x94, 0x50, 0xf4, 0x1f, 0x94, 0x69, 0xe3, 0x11, 0x3b, 0x76,
	0xd9, 0xa5, 0xd7, 0xb1, 0x8e, 0xcd, 0xe7, 0x39, 0x50, 0x65, 0x17, 0xba, 0x12, 0xf5, 0x4e, 0x30,
	0x00, 0x6d, 0x17, 0x9e, 0x64, 0xe7, 0xf5, 0xa1, 0xed, 0x8b, 0xe6, 0x84, 0x46, 0x7a, 0x93, 0xf0,
	0x94, 0x90, 0xb4, 0x08, 0x45, 0xdc, 0xbb, 0xe9, 0x09, 0x08, 0x8b, 0x7d, 0x6f, 0x22, 0x2b, 0x19,
	0x84, 0xc5, 0xb5, 0x1a, 0x81, 0xee, 0xc6, 0x03, 0x9d, 0x03, 0x55, 0x16, 0x5f, 0x92, 0x06, 0xfb,
	0x09, 0x06, 0x68, 0x3a, 0xc5, 0xae, 0x65, 0xc9, 0xc2, 0x30, 0xdf, 0x67, 0x4d, 0xb3, 0x12, 0x48,
	0xde, 0xb3, 0x26, 0x53, 0x29, 0xa9, 0xfc, 0x9a, 0xbf, 0x5b, 0x96, 0x6e, 0x50, 0xb0, 0x17, 0xb9,
	0x7d, 0x1e, 0xbf, 0x2f, 0x7b, 0xa0, 0x80, 0xaf, 0x80, 0x19, 0x5b, 0x0c, 0xa0, 0x9c, 0x80, 0x27,
	0x60, 0xba, 0x38, 0x14, 0x13, 0xa3, 0x72, 0xe9, 0x66, 0x34, 0x75, 0xe9, 0x86, 0x1d, 0xc2, 0x28,
	0x81, 0xf6, 0x4a, 0xce, 0xa9, 0x55, 0x9a, 0x75, 0xf3, 0x29, 0xed, 0xa9, 0xd1, 0x23, 0xe5, 0x5e,
	0xa9, 0x28, 0xb4, 0x7d, 0xdc, 0x75, 0x31, 0x56, 0x7b, 0xa5, 0x64, 0x70, 0xd3, 0x31, 0xff, 0x9c,
	0x9d, 0xfc, 0x6d, 0x63, 0x32, 0x37, 0x7a, 0xe4, 0xfa, 0x1c, 0x71, 0x33, 0x3e, 0xc6, 0xad, 0xaa,
	0x7c, 0xe9, 0x2a, 0x56, 0x55, 0x49, 0x59, 0xd5, 0xd0, 0x03, 0x3c, 0xcd, 0xf4, 0xcc, 0xef, 0xb3,
	0xed, 0xb8, 0x06, 0x55, 0xc8, 0xc0, 0xd2, 0x0e, 0x55, 0x3e, 0xba, 0x43, 0x99, 0x3f, 0x2f, 0x49,
	0xc6, 0xfd, 0x9c, 0x77, 0xc5, 0xf3, 0x55, 0xf8, 0x04, 0x41, 0x20, 0x11, 0x54, 0x59, 0x15, 0x94,
	0x71, 0x11, 0xd4, 0x70, 0x64, 0x87, 0x51, 0x7c, 0xa7, 0xa1, 0x42, 0x77, 0x00, 0x93, 0x14, 0xc6,
	0xae, 0x32, 0x50, 0x33, 0xe6, 0xc7, 0x02, 0x28, 0x64, 0x65, 0x8e, 0x11, 0x6e, 0xc6, 0x02, 0xfc,
	0x09, 0x72, 0x60, 0xb1, 0xb0, 0xa8, 0x63, 0xcd, 0x7c, 0xc0, 0x1a, 0xb9, 0x35, 0x28, 0x59, 0xf2,
	0x09, 0x17, 0x25, 0x95, 0x0b, 0xf3, 0x0f, 0xe5, 0x86, 0xaf, 0x6d, 0x7c, 0xe8, 0xb7, 0x4f, 0x72,
	0x93, 0x2f, 0x5f, 0x5a, 0x99, 0xc3, 0xe3, 0x8a, 0xa6, 0x4a, 0xac, 0xd8, 0xc8, 0xc8, 0x60, 0x1b,
	0x19, 0x3d, 0xba, 0x8d, 0x14, 0x3d, 0x9c, 0x56, 0xc4, 0x60, 0x3e, 0x91, 0x0e, 0xa7, 0x15, 0x8c,
	0x7c, 0x19, 0x06, 0x13, 0x74, 0xca, 0xbd, 0x6b, 0x09, 0xb0, 0xe9, 0x98, 0x7f, 0x2b, 0x77, 0x44,
	0x3c, 0xb5, 0xbf, 0x77, 0x98, 0xba, 0xb2, 0x90, 0x58, 0xc4, 0xf0, 0x4e, 0xa4, 0x84, 0x76, 0xb0,
	0xd0, 0xe9, 0xb5, 0x0a, 0xcf, 0x53, 0xab, 0x30, 0xac, 0xe7, 0xb1, 0xda, 0x32, 0x04, 0x2a, 0x66,
	0x08, 0x93, 0x8d, 0xb0, 0x7c, 0xba, 0xd5, 0x85, 0xd1, 0x01, 0x72, 0xe2, 0x42, 0xad, 0x84, 0xd9,
	0xa1, 0x08, 0xb2, 0x0b, 0xe2, 0x95, 0x4a, 0xe9, 0xa8, 0x0a, 0x30, 0x90, 0xee, 0x52, 0xcc, 0x18,
	0x0d, 0xbd, 0xd2, 0xa5, 0x18, 0xd6, 0x76, 0x27, 0xf1, 0x33, 0xa8, 0x40, 0x99, 0x12, 0x9a, 0xd9,
	0x94, 0x0a, 0x94, 0x29, 0xdc, 0x11, 0xef, 0x9f, 0x6c, 0xfe, 0xeb, 0x12, 0xa8, 0xec, 0xe0, 0x8e,
	0xf1, 0x1d, 0x50, 0x53, 0x2e, 0x5b, 0x67, 0xae, 0x15, 0xa4, 0x6e, 0x35, 0x37, 0xae, 0x0c, 0x21,
	0x10, 0x13, 0xf9, 0x25, 0x30, 0xa5, 0x5e, 0x79, 0x5e, 0xd6, 0xbc, 0xa9, 0x50, 0x34, 0xd6, 0x86,
	0x51, 0xc8, 0x1f, 0x57, 0x2f, 0x0f, 0xeb, 0x3e, 0xae, 0x50, 0x68, 0x3f, 0xae, 0xbd, 0xe6, 0x6b,
	0xfc, 0x32, 0x98, 0x4e, 0x5d, 0xf1, 0xbd, 0xa8, 0x79, 0x57, 0x25, 0x69, 0x5c, 0x1d, 0x4a, 0x22,
	0xbe, 0xdf, 0x01, 0x73, 0xd9, 0x5b, 0x93, 0x97, 0x72, 0xdf, 0x97, 0xa8, 0x1a, 0xef, 0x16, 0xa1,
	0x92, 0x07, 0xca, 0xde, 0xf1, 0xd3, 0x0d, 0x94, 0xa1, 0xd2, 0x0e, 0x94, 0x7f, 0x39, 0xae, 0x03,
	0xe6, 0xb2, 0xb7, 0xd7, 0x2e, 0x69, 0xb5, 0x99, 0xa2, 0xd2, 0x0e, 0x94, 0x7f, 0xbb, 0x2a, 0x00,
	0xf3, 0xda, 0x1b, 0x50, 0x3a, 0xab, 0xd4, 0x11, 0x36, 0x36, 0x0a, 0x12, 0xca, 0xc6, 0x90, 0xba,
	0xed, 0xa3, 0x33, 0x06, 0x95, 0x44, 0x6b, 0x0c, 0x39, 0x97, 0x65, 0x5e, 0x80, 0x49, 0xf9, 0x1e,
	0xcc, 0xa2, 0xe6, 0x4d, 0x09, 0xdf, 0xb8, 0x3c, 0x18, 0x2f, 0x3e, 0x8b, 0xc1, 0x69, 0xfd, 0xa5,
	0x11, 0x9d, 0x1b, 0x68, 0x29, 0x1b, 0xef, 0x15, 0xa5, 0x54, 0x5d, 0x5e, 0xbe, 0xd6, 0xa1, 0x77,
	0x79, 0x89, 0x22, 0xc7, 0xe5, 0x35, 0x97, 0x2c, 0x48, 0xa4, 0x52, 0x2e, 0x58, 0x2c, 0x0d, 0x08,
	0x16, 0x84, 0x40, 0x1b, 0xa9, 0xb4, 0xad, 0xfd, 0x7d, 0xb0, 0x90, 0xd3, 0xad, 0x7f, 0x35, 0x37,
	0xd8, 0xa5, 0x49, 0x1b, 0x37, 0x0b, 0x93, 0x8a, 0x71, 0xbb, 0xe0, 0x94, 0xae, 0xed, 0xfc, 0x72,
	0xae, 0x8f, 0x2b, 0x74, 0x8d, 0xf5, 0x62, 0x74, 0xb2, 0x76, 0xd4, 0x26, 0xea, 0xe5, 0x5c, 0x1f,
	0xe7, 0x14, 0x5a, 0xed, 0xe8, 0x1b, 0x92, 0x1d, 0x30, 0x9b, 0xe9, 0x36, 0x5e, 0x19, 0xe4, 0x6b,
	0xf1, 0x10, 0xd7, 0x0b, 0x10, 0x89, 0x51, 0x3e, 0x07, 0x86, 0xa6, 0x5d, 0x77, 0x55, 0xab, 0xe8,
	0x34, 0x59, 0xe3, 0x46, 0x21, 0x32, 0x99, 0xa3, 0x4c, 0x07, 0xec, 0x8a, 0xfe, 0x13, 0x0a, 0x91,
	0x96, 0xa3, 0xdc, 0x96, 0x52, 0x0c, 0x4e, 0xeb, 0x5b, 0x46, 0xd7, 0x72, 0xb5, 0x9b, 0xa2, 0xd4,
	0xfa, 0xe9, 0xe0, 0x7e, 0xcb, 0x1f, 0x94, 0x40, 0x63, 0x40, 0x43, 0xe5, 0x8d, 0x7c, 0xc3, 0xd2,
	0x90, 0x37, 0xee, 0x1c, 0x89, 0x5c, 0x95, 0x6f, 0xaa, 0xa5, 0x4f, 0x2f, 0x5f, 0x95, 0x28, 0x47,
	0xbe, 0x39, 0x2d, 0x6f, 0x42, 0xbe, 0xe9, 0x7e, 0xb6, 0x7c, 0xf9, 0xa6, 0x28, 0x07, 0xc8, 0x37,
	0xaf, 0x49, 0xec, 0x10, 0x9c, 0xc9, 0x6b, 0x02, 0xbb, 0x96, 0x1b, 0x26, 0x32, 0xb4, 0x8d, 0xcd,
	0xe2, 0xb4, 0x8a, 0x93, 0x2b, 0x3d, 0x53, 0x5a, 0x27, 0x97, 0x29, 0xf4, 0x4e, 0xae, 0x6d, 0xe4,
	0x11, 0x01, 0x4b, 0x6d, 0xd2, 0xc9, 0x0f, 0x58, 0x0a, 0xdd, 0x80, 0x80, 0xa5, 0x6f, 0x81, 0xc1,
	0xe0, 0xb4, 0xbe, 0xc5, 0x45, 0xbb, 0x95, 0xd3, 0x51, 0x6a, 0x75, 0x37, 0xb8, 0x83, 0x24, 0x00,
	0xf3, 0xda, 0x06, 0x11, 0xfd, 0x6a, 0x92, 0x25, 0xd4, 0xee, 0x30, 0x06, 0xf6, 0x5c, 0xd0, 0xa0,
	0x96, 0xe9, 0xa9, 0x58, 0xcd, 0xfd, 0x8c, 0x4c, 0x96, 0x13, 0xd4, 0x72, 0x7b, 0x10, 0x7e, 0x05,
	0xd4, 0x73, 0x7b, 0x0c, 0xae, 0xe7, 0x7e, 0x2a, 0x4b, 0xdc, 0xb8, 0x75, 0x04, 0x62, 0x79, 0x2f,
	0x95, 0xaa, 0x9e, 0x5f, 0xcc, 0xd5, 0x8f, 0x50, 0xe1, 0xd5, 0xa1, 0x24, 0x4a, 0x5c, 0x1b, 0x50,
	0x66, 0xbe, 0x31, 0x28, 0xbd, 0xc8, 0x90, 0x6b, 0xe3, 0x5a, 0x81, 0x42, 0xee, 0x77, 0x40, 0x4d,
	0x39, 0x8f, 0x5d, 0xca, 0x75, 0x2f, 0x46, 0xa0, 0xdd, 0xa7, 0x68, 0x4f, 0x2c, 0xfb, 0x60, 0x21,
	0xe7, 0x40, 0x32, 0x3f, 0xf9, 0x48, 0x93, 0x6a, 0xf7, 0x29, 0x43, 0x8e, 0xf3, 0xba, 0xe0, 0x94,
	0xee, 0x84, 0x4e, 0xe7, 0xf6, 0x1a, 0x3a, 0xad, 0xdb, 0x0f, 0x3a, 0x37, 0x23, 0x7b, 0x7c, 0xdd,
	0x99, 0xd6, 0x95, 0x41, 0x71, 0x4a, 0x22, 0xd4, 0xef, 0xf1, 0x07, 0x9d, 0x17, 0x89, 0xb8, 0xa6,
	0x1e, 0x07, 0xe5, 0xc7, 0x35, 0x85, 0x6e, 0x40, 0x5c, 0xd3, 0x9f, 0x9e, 0x88, 0x35, 0x29, 0x7d,
	0x28, 0x92, 0xbf, 0x26, 0xa5, 0x28, 0x07, 0xac, 0x49, 0x39, 0xe7, 0x02, 0x8d, 0xd1, 0xef, 0x7f,
	0xf3, 0xc5, 0xb5, 0xd2, 0xc3, 0x1b, 0x3f, 0xf9, 0x6a, 0xb1, 0xf4, 0xe5, 0x57, 0x8b, 0xa5, 0x9f,
	0x7d, 0xb5, 0x58, 0xfa, 0xad, 0xaf, 0x17, 0xdf, 0xf9, 0xf2, 0xeb, 0xc5, 0x77, 0xfe, 0xfe, 0xeb,
	0xc5, 0x77, 0x7e, 0xf1, 0x94, 0x7a, 0x08, 0x11, 0x1d, 0x06, 0x10, 0xef, 0x8d, 0xd1, 0x7f, 0xcb,
	0x76, 0xeb, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x34, 0x70, 0x00, 0x70, 0xe3, 0x4f, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// RegisterModel registers a new model configuration (governance-only)
	RegisterModel(ctx context.Context, in *MsgRegisterModel, opts ...grpc.CallOption) (*MsgRegisterModelResponse, error)
	// ActivateModel activates a model for training (governance-only)
	ActivateModel(ctx context.Context, in *MsgActivateModel, opts ...grpc.CallOption) (*MsgActivateModelResponse, error)
	// SubmitGradient submits a gradient update with IPFS hash (passive IPFS role - Go node only stores hash, not data)
	SubmitGradient(ctx context.Context, in *MsgSubmitGradient, opts ...grpc.CallOption) (*MsgSubmitGradientResponse, error)
	// SubmitAggregation submits aggregated gradient results from off-chain aggregation
	SubmitAggregation(ctx context.Context, in *MsgSubmitAggregation, opts ...grpc.CallOption) (*MsgSubmitAggregationResponse, error)
	// CommitAggregation commits to an aggregation result (commit-reveal scheme for multi-proposer)
	CommitAggregation(ctx context.Context, in *MsgCommitAggregation, opts ...grpc.CallOption) (*MsgCommitAggregationResponse, error)
	// RevealAggregation reveals an aggregation result and verifies commitment
	RevealAggregation(ctx context.Context, in *MsgRevealAggregation, opts ...grpc.CallOption) (*MsgRevealAggregationResponse, error)
	// ChallengeAggregation challenges an aggregation result for dispute resolution
	ChallengeAggregation(ctx context.Context, in *MsgChallengeAggregation, opts ...grpc.CallOption) (*MsgChallengeAggregationResponse, error)
	// ProposeDataset proposes a dataset for governance approval
	ProposeDataset(ctx context.Context, in *MsgProposeDataset, opts ...grpc.CallOption) (*MsgProposeDatasetResponse, error)
	// VoteDataset votes on a dataset proposal
	VoteDataset(ctx context.Context, in *MsgVoteDataset, opts ...grpc.CallOption) (*MsgVoteDatasetResponse, error)
	// MarkDatasetAsOfficial marks an approved dataset as "Official Training Data"
	MarkDatasetAsOfficial(ctx context.Context, in *MsgMarkDatasetAsOfficial, opts ...grpc.CallOption) (*MsgMarkDatasetAsOfficialResponse, error)
	// RemoveDataset removes an approved dataset from the registry
	RemoveDataset(ctx context.Context, in *MsgRemoveDataset, opts ...grpc.CallOption) (*MsgRemoveDatasetResponse, error)
	// RegisterNode registers a node with role specification and resource quotas
	RegisterNode(ctx context.Context, in *MsgRegisterNode, opts ...grpc.CallOption) (*MsgRegisterNodeResponse, error)
	// UpdateNodeRegistration updates node registration information
	UpdateNodeRegistration(ctx context.Context, in *MsgUpdateNodeRegistration, opts ...grpc.CallOption) (*MsgUpdateNodeRegistrationResponse, error)
	// SubmitResourceUsage submits resource usage proof for validation
	SubmitResourceUsage(ctx context.Context, in *MsgSubmitResourceUsage, opts ...grpc.CallOption) (*MsgSubmitResourceUsageResponse, error)
	// CommitPinning commits to pin IPFS content with stake
	CommitPinning(ctx context.Context, in *MsgCommitPinning, opts ...grpc.CallOption) (*MsgCommitPinningResponse, error)
	// ChallengePinning challenges a pinning commitment for data availability verification
	ChallengePinning(ctx context.Context, in *MsgChallengePinning, opts ...grpc.CallOption) (*MsgChallengePinningResponse, error)
	// RespondToChallenge responds to a data availability challenge
	RespondToChallenge(ctx context.Context, in *MsgRespondToChallenge, opts ...grpc.CallOption) (*MsgRespondToChallengeResponse, error)
	// ResolveChallenge resolves an aggregation challenge with CPU verification results
	ResolveChallenge(ctx context.Context, in *MsgResolveChallenge, opts ...grpc.CallOption) (*MsgResolveChallengeResponse, error)
	// SubmitCPUVerification submits CPU verification result for a challenge
	SubmitCPUVerification(ctx context.Context, in *MsgSubmitCPUVerification, opts ...grpc.CallOption) (*MsgSubmitCPUVerificationResponse, error)
	// SubmitRandomVerifierResult submits random GPU verifier result for Layer 2 challenge
	SubmitRandomVerifierResult(ctx context.Context, in *MsgSubmitRandomVerifierResult, opts ...grpc.CallOption) (*MsgSubmitRandomVerifierResultResponse, error)
	// RequestInference requests AI model inference from a serving node
	RequestInference(ctx context.Context, in *MsgRequestInference, opts ...grpc.CallOption) (*MsgRequestInferenceResponse, error)
	// SubmitInferenceResult submits inference result from a serving node
	SubmitInferenceResult(ctx context.Context, in *MsgSubmitInferenceResult, opts ...grpc.CallOption) (*MsgSubmitInferenceResultResponse, error)
	// UpdateServingNodeStatus updates serving node status and model version
	UpdateServingNodeStatus(ctx context.Context, in *MsgUpdateServingNodeStatus, opts ...grpc.CallOption) (*MsgUpdateServingNodeStatusResponse, error)
	// CreateTrapJob creates a trap job for lazy mining detection
	CreateTrapJob(ctx context.Context, in *MsgCreateTrapJob, opts ...grpc.CallOption) (*MsgCreateTrapJobResponse, error)
	// SubmitTrapJobResult submits result for a trap job
	SubmitTrapJobResult(ctx context.Context, in *MsgSubmitTrapJobResult, opts ...grpc.CallOption) (*MsgSubmitTrapJobResultResponse, error)
	// AppealTrapJobSlashing appeals a trap job slashing decision
	AppealTrapJobSlashing(ctx context.Context, in *MsgAppealTrapJobSlashing, opts ...grpc.CallOption) (*MsgAppealTrapJobSlashingResponse, error)
	// ReportLazyValidation reports lazy validation by a validator
	ReportLazyValidation(ctx context.Context, in *MsgReportLazyValidation, opts ...grpc.CallOption) (*MsgReportLazyValidationResponse, error)
	// ReportFalseVerdict reports false verdict by a validator
	ReportFalseVerdict(ctx context.Context, in *MsgReportFalseVerdict, opts ...grpc.CallOption) (*MsgReportFalseVerdictResponse, error)
	// ReportProposerCensorship reports censorship by a proposer
	ReportProposerCensorship(ctx context.Context, in *MsgReportProposerCensorship, opts ...grpc.CallOption) (*MsgReportProposerCensorshipResponse, error)
	// AppealSlashing appeals a slashing decision
	AppealSlashing(ctx context.Context, in *MsgAppealSlashing, opts ...grpc.CallOption) (*MsgAppealSlashingResponse, error)
	// RegisterMentorRelationship registers a mentor-mentee relationship
	RegisterMentorRelationship(ctx context.Context, in *MsgRegisterMentorRelationship, opts ...grpc.CallOption) (*MsgRegisterMentorRelationshipResponse, error)
	// CreateSubnet creates a new subnet for layer-based sharding
	CreateSubnet(ctx context.Context, in *MsgCreateSubnet, opts ...grpc.CallOption) (*MsgCreateSubnetResponse, error)
	// SubmitSubnetActivation submits activation data from a subnet
	SubmitSubnetActivation(ctx context.Context, in *MsgSubmitSubnetActivation, opts ...grpc.CallOption) (*MsgSubmitSubnetActivationResponse, error)
	// AssignMinerToSubnet assigns a miner to a subnet
	AssignMinerToSubnet(ctx context.Context, in *MsgAssignMinerToSubnet, opts ...grpc.CallOption) (*MsgAssignMinerToSubnetResponse, error)
	// CreateTrainingWindow creates a new training window
	CreateTrainingWindow(ctx context.Context, in *MsgCreateTrainingWindow, opts ...grpc.CallOption) (*MsgCreateTrainingWindowResponse, error)
	// SubmitAsyncGradient submits an asynchronous gradient (non-blocking)
	SubmitAsyncGradient(ctx context.Context, in *MsgSubmitAsyncGradient, opts ...grpc.CallOption) (*MsgSubmitAsyncGradientResponse, error)
	// SubmitLazyAggregation submits lazy aggregation at window boundary
	SubmitLazyAggregation(ctx context.Context, in *MsgSubmitLazyAggregation, opts ...grpc.CallOption) (*MsgSubmitLazyAggregationResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterModel(ctx context.Context, in *MsgRegisterModel, opts ...grpc.CallOption) (*MsgRegisterModelResponse, error) {
	out := new(MsgRegisterModelResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/RegisterModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ActivateModel(ctx context.Context, in *MsgActivateModel, opts ...grpc.CallOption) (*MsgActivateModelResponse, error) {
	out := new(MsgActivateModelResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/ActivateModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitGradient(ctx context.Context, in *MsgSubmitGradient, opts ...grpc.CallOption) (*MsgSubmitGradientResponse, error) {
	out := new(MsgSubmitGradientResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/SubmitGradient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitAggregation(ctx context.Context, in *MsgSubmitAggregation, opts ...grpc.CallOption) (*MsgSubmitAggregationResponse, error) {
	out := new(MsgSubmitAggregationResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/SubmitAggregation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CommitAggregation(ctx context.Context, in *MsgCommitAggregation, opts ...grpc.CallOption) (*MsgCommitAggregationResponse, error) {
	out := new(MsgCommitAggregationResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/CommitAggregation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RevealAggregation(ctx context.Context, in *MsgRevealAggregation, opts ...grpc.CallOption) (*MsgRevealAggregationResponse, error) {
	out := new(MsgRevealAggregationResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/RevealAggregation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ChallengeAggregation(ctx context.Context, in *MsgChallengeAggregation, opts ...grpc.CallOption) (*MsgChallengeAggregationResponse, error) {
	out := new(MsgChallengeAggregationResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/ChallengeAggregation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ProposeDataset(ctx context.Context, in *MsgProposeDataset, opts ...grpc.CallOption) (*MsgProposeDatasetResponse, error) {
	out := new(MsgProposeDatasetResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/ProposeDataset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) VoteDataset(ctx context.Context, in *MsgVoteDataset, opts ...grpc.CallOption) (*MsgVoteDatasetResponse, error) {
	out := new(MsgVoteDatasetResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/VoteDataset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MarkDatasetAsOfficial(ctx context.Context, in *MsgMarkDatasetAsOfficial, opts ...grpc.CallOption) (*MsgMarkDatasetAsOfficialResponse, error) {
	out := new(MsgMarkDatasetAsOfficialResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/MarkDatasetAsOfficial", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoveDataset(ctx context.Context, in *MsgRemoveDataset, opts ...grpc.CallOption) (*MsgRemoveDatasetResponse, error) {
	out := new(MsgRemoveDatasetResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/RemoveDataset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterNode(ctx context.Context, in *MsgRegisterNode, opts ...grpc.CallOption) (*MsgRegisterNodeResponse, error) {
	out := new(MsgRegisterNodeResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/RegisterNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateNodeRegistration(ctx context.Context, in *MsgUpdateNodeRegistration, opts ...grpc.CallOption) (*MsgUpdateNodeRegistrationResponse, error) {
	out := new(MsgUpdateNodeRegistrationResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/UpdateNodeRegistration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitResourceUsage(ctx context.Context, in *MsgSubmitResourceUsage, opts ...grpc.CallOption) (*MsgSubmitResourceUsageResponse, error) {
	out := new(MsgSubmitResourceUsageResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/SubmitResourceUsage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CommitPinning(ctx context.Context, in *MsgCommitPinning, opts ...grpc.CallOption) (*MsgCommitPinningResponse, error) {
	out := new(MsgCommitPinningResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/CommitPinning", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ChallengePinning(ctx context.Context, in *MsgChallengePinning, opts ...grpc.CallOption) (*MsgChallengePinningResponse, error) {
	out := new(MsgChallengePinningResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/ChallengePinning", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RespondToChallenge(ctx context.Context, in *MsgRespondToChallenge, opts ...grpc.CallOption) (*MsgRespondToChallengeResponse, error) {
	out := new(MsgRespondToChallengeResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/RespondToChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ResolveChallenge(ctx context.Context, in *MsgResolveChallenge, opts ...grpc.CallOption) (*MsgResolveChallengeResponse, error) {
	out := new(MsgResolveChallengeResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/ResolveChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitCPUVerification(ctx context.Context, in *MsgSubmitCPUVerification, opts ...grpc.CallOption) (*MsgSubmitCPUVerificationResponse, error) {
	out := new(MsgSubmitCPUVerificationResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/SubmitCPUVerification", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitRandomVerifierResult(ctx context.Context, in *MsgSubmitRandomVerifierResult, opts ...grpc.CallOption) (*MsgSubmitRandomVerifierResultResponse, error) {
	out := new(MsgSubmitRandomVerifierResultResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/SubmitRandomVerifierResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RequestInference(ctx context.Context, in *MsgRequestInference, opts ...grpc.CallOption) (*MsgRequestInferenceResponse, error) {
	out := new(MsgRequestInferenceResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/RequestInference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitInferenceResult(ctx context.Context, in *MsgSubmitInferenceResult, opts ...grpc.CallOption) (*MsgSubmitInferenceResultResponse, error) {
	out := new(MsgSubmitInferenceResultResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/SubmitInferenceResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateServingNodeStatus(ctx context.Context, in *MsgUpdateServingNodeStatus, opts ...grpc.CallOption) (*MsgUpdateServingNodeStatusResponse, error) {
	out := new(MsgUpdateServingNodeStatusResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/UpdateServingNodeStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateTrapJob(ctx context.Context, in *MsgCreateTrapJob, opts ...grpc.CallOption) (*MsgCreateTrapJobResponse, error) {
	out := new(MsgCreateTrapJobResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/CreateTrapJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitTrapJobResult(ctx context.Context, in *MsgSubmitTrapJobResult, opts ...grpc.CallOption) (*MsgSubmitTrapJobResultResponse, error) {
	out := new(MsgSubmitTrapJobResultResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/SubmitTrapJobResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AppealTrapJobSlashing(ctx context.Context, in *MsgAppealTrapJobSlashing, opts ...grpc.CallOption) (*MsgAppealTrapJobSlashingResponse, error) {
	out := new(MsgAppealTrapJobSlashingResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/AppealTrapJobSlashing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ReportLazyValidation(ctx context.Context, in *MsgReportLazyValidation, opts ...grpc.CallOption) (*MsgReportLazyValidationResponse, error) {
	out := new(MsgReportLazyValidationResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/ReportLazyValidation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ReportFalseVerdict(ctx context.Context, in *MsgReportFalseVerdict, opts ...grpc.CallOption) (*MsgReportFalseVerdictResponse, error) {
	out := new(MsgReportFalseVerdictResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/ReportFalseVerdict", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ReportProposerCensorship(ctx context.Context, in *MsgReportProposerCensorship, opts ...grpc.CallOption) (*MsgReportProposerCensorshipResponse, error) {
	out := new(MsgReportProposerCensorshipResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/ReportProposerCensorship", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AppealSlashing(ctx context.Context, in *MsgAppealSlashing, opts ...grpc.CallOption) (*MsgAppealSlashingResponse, error) {
	out := new(MsgAppealSlashingResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/AppealSlashing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterMentorRelationship(ctx context.Context, in *MsgRegisterMentorRelationship, opts ...grpc.CallOption) (*MsgRegisterMentorRelationshipResponse, error) {
	out := new(MsgRegisterMentorRelationshipResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/RegisterMentorRelationship", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateSubnet(ctx context.Context, in *MsgCreateSubnet, opts ...grpc.CallOption) (*MsgCreateSubnetResponse, error) {
	out := new(MsgCreateSubnetResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/CreateSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitSubnetActivation(ctx context.Context, in *MsgSubmitSubnetActivation, opts ...grpc.CallOption) (*MsgSubmitSubnetActivationResponse, error) {
	out := new(MsgSubmitSubnetActivationResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/SubmitSubnetActivation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AssignMinerToSubnet(ctx context.Context, in *MsgAssignMinerToSubnet, opts ...grpc.CallOption) (*MsgAssignMinerToSubnetResponse, error) {
	out := new(MsgAssignMinerToSubnetResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/AssignMinerToSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateTrainingWindow(ctx context.Context, in *MsgCreateTrainingWindow, opts ...grpc.CallOption) (*MsgCreateTrainingWindowResponse, error) {
	out := new(MsgCreateTrainingWindowResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/CreateTrainingWindow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitAsyncGradient(ctx context.Context, in *MsgSubmitAsyncGradient, opts ...grpc.CallOption) (*MsgSubmitAsyncGradientResponse, error) {
	out := new(MsgSubmitAsyncGradientResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/SubmitAsyncGradient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitLazyAggregation(ctx context.Context, in *MsgSubmitLazyAggregation, opts ...grpc.CallOption) (*MsgSubmitLazyAggregationResponse, error) {
	out := new(MsgSubmitLazyAggregationResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.Msg/SubmitLazyAggregation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// RegisterModel registers a new model configuration (governance-only)
	RegisterModel(context.Context, *MsgRegisterModel) (*MsgRegisterModelResponse, error)
	// ActivateModel activates a model for training (governance-only)
	ActivateModel(context.Context, *MsgActivateModel) (*MsgActivateModelResponse, error)
	// SubmitGradient submits a gradient update with IPFS hash (passive IPFS role - Go node only stores hash, not data)
	SubmitGradient(context.Context, *MsgSubmitGradient) (*MsgSubmitGradientResponse, error)
	// SubmitAggregation submits aggregated gradient results from off-chain aggregation
	SubmitAggregation(context.Context, *MsgSubmitAggregation) (*MsgSubmitAggregationResponse, error)
	// CommitAggregation commits to an aggregation result (commit-reveal scheme for multi-proposer)
	CommitAggregation(context.Context, *MsgCommitAggregation) (*MsgCommitAggregationResponse, error)
	// RevealAggregation reveals an aggregation result and verifies commitment
	RevealAggregation(context.Context, *MsgRevealAggregation) (*MsgRevealAggregationResponse, error)
	// ChallengeAggregation challenges an aggregation result for dispute resolution
	ChallengeAggregation(context.Context, *MsgChallengeAggregation) (*MsgChallengeAggregationResponse, error)
	// ProposeDataset proposes a dataset for governance approval
	ProposeDataset(context.Context, *MsgProposeDataset) (*MsgProposeDatasetResponse, error)
	// VoteDataset votes on a dataset proposal
	VoteDataset(context.Context, *MsgVoteDataset) (*MsgVoteDatasetResponse, error)
	// MarkDatasetAsOfficial marks an approved dataset as "Official Training Data"
	MarkDatasetAsOfficial(context.Context, *MsgMarkDatasetAsOfficial) (*MsgMarkDatasetAsOfficialResponse, error)
	// RemoveDataset removes an approved dataset from the registry
	RemoveDataset(context.Context, *MsgRemoveDataset) (*MsgRemoveDatasetResponse, error)
	// RegisterNode registers a node with role specification and resource quotas
	RegisterNode(context.Context, *MsgRegisterNode) (*MsgRegisterNodeResponse, error)
	// UpdateNodeRegistration updates node registration information
	UpdateNodeRegistration(context.Context, *MsgUpdateNodeRegistration) (*MsgUpdateNodeRegistrationResponse, error)
	// SubmitResourceUsage submits resource usage proof for validation
	SubmitResourceUsage(context.Context, *MsgSubmitResourceUsage) (*MsgSubmitResourceUsageResponse, error)
	// CommitPinning commits to pin IPFS content with stake
	CommitPinning(context.Context, *MsgCommitPinning) (*MsgCommitPinningResponse, error)
	// ChallengePinning challenges a pinning commitment for data availability verification
	ChallengePinning(context.Context, *MsgChallengePinning) (*MsgChallengePinningResponse, error)
	// RespondToChallenge responds to a data availability challenge
	RespondToChallenge(context.Context, *MsgRespondToChallenge) (*MsgRespondToChallengeResponse, error)
	// ResolveChallenge resolves an aggregation challenge with CPU verification results
	ResolveChallenge(context.Context, *MsgResolveChallenge) (*MsgResolveChallengeResponse, error)
	// SubmitCPUVerification submits CPU verification result for a challenge
	SubmitCPUVerification(context.Context, *MsgSubmitCPUVerification) (*MsgSubmitCPUVerificationResponse, error)
	// SubmitRandomVerifierResult submits random GPU verifier result for Layer 2 challenge
	SubmitRandomVerifierResult(context.Context, *MsgSubmitRandomVerifierResult) (*MsgSubmitRandomVerifierResultResponse, error)
	// RequestInference requests AI model inference from a serving node
	RequestInference(context.Context, *MsgRequestInference) (*MsgRequestInferenceResponse, error)
	// SubmitInferenceResult submits inference result from a serving node
	SubmitInferenceResult(context.Context, *MsgSubmitInferenceResult) (*MsgSubmitInferenceResultResponse, error)
	// UpdateServingNodeStatus updates serving node status and model version
	UpdateServingNodeStatus(context.Context, *MsgUpdateServingNodeStatus) (*MsgUpdateServingNodeStatusResponse, error)
	// CreateTrapJob creates a trap job for lazy mining detection
	CreateTrapJob(context.Context, *MsgCreateTrapJob) (*MsgCreateTrapJobResponse, error)
	// SubmitTrapJobResult submits result for a trap job
	SubmitTrapJobResult(context.Context, *MsgSubmitTrapJobResult) (*MsgSubmitTrapJobResultResponse, error)
	// AppealTrapJobSlashing appeals a trap job slashing decision
	AppealTrapJobSlashing(context.Context, *MsgAppealTrapJobSlashing) (*MsgAppealTrapJobSlashingResponse, error)
	// ReportLazyValidation reports lazy validation by a validator
	ReportLazyValidation(context.Context, *MsgReportLazyValidation) (*MsgReportLazyValidationResponse, error)
	// ReportFalseVerdict reports false verdict by a validator
	ReportFalseVerdict(context.Context, *MsgReportFalseVerdict) (*MsgReportFalseVerdictResponse, error)
	// ReportProposerCensorship reports censorship by a proposer
	ReportProposerCensorship(context.Context, *MsgReportProposerCensorship) (*MsgReportProposerCensorshipResponse, error)
	// AppealSlashing appeals a slashing decision
	AppealSlashing(context.Context, *MsgAppealSlashing) (*MsgAppealSlashingResponse, error)
	// RegisterMentorRelationship registers a mentor-mentee relationship
	RegisterMentorRelationship(context.Context, *MsgRegisterMentorRelationship) (*MsgRegisterMentorRelationshipResponse, error)
	// CreateSubnet creates a new subnet for layer-based sharding
	CreateSubnet(context.Context, *MsgCreateSubnet) (*MsgCreateSubnetResponse, error)
	// SubmitSubnetActivation submits activation data from a subnet
	SubmitSubnetActivation(context.Context, *MsgSubmitSubnetActivation) (*MsgSubmitSubnetActivationResponse, error)
	// AssignMinerToSubnet assigns a miner to a subnet
	AssignMinerToSubnet(context.Context, *MsgAssignMinerToSubnet) (*MsgAssignMinerToSubnetResponse, error)
	// CreateTrainingWindow creates a new training window
	CreateTrainingWindow(context.Context, *MsgCreateTrainingWindow) (*MsgCreateTrainingWindowResponse, error)
	// SubmitAsyncGradient submits an asynchronous gradient (non-blocking)
	SubmitAsyncGradient(context.Context, *MsgSubmitAsyncGradient) (*MsgSubmitAsyncGradientResponse, error)
	// SubmitLazyAggregation submits lazy aggregation at window boundary
	SubmitLazyAggregation(context.Context, *MsgSubmitLazyAggregation) (*MsgSubmitLazyAggregationResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) RegisterModel(ctx context.Context, req *MsgRegisterModel) (*MsgRegisterModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterModel not implemented")
}
func (*UnimplementedMsgServer) ActivateModel(ctx context.Context, req *MsgActivateModel) (*MsgActivateModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateModel not implemented")
}
func (*UnimplementedMsgServer) SubmitGradient(ctx context.Context, req *MsgSubmitGradient) (*MsgSubmitGradientResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitGradient not implemented")
}
func (*UnimplementedMsgServer) SubmitAggregation(ctx context.Context, req *MsgSubmitAggregation) (*MsgSubmitAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAggregation not implemented")
}
func (*UnimplementedMsgServer) CommitAggregation(ctx context.Context, req *MsgCommitAggregation) (*MsgCommitAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitAggregation not implemented")
}
func (*UnimplementedMsgServer) RevealAggregation(ctx context.Context, req *MsgRevealAggregation) (*MsgRevealAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevealAggregation not implemented")
}
func (*UnimplementedMsgServer) ChallengeAggregation(ctx context.Context, req *MsgChallengeAggregation) (*MsgChallengeAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeAggregation not implemented")
}
func (*UnimplementedMsgServer) ProposeDataset(ctx context.Context, req *MsgProposeDataset) (*MsgProposeDatasetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposeDataset not implemented")
}
func (*UnimplementedMsgServer) VoteDataset(ctx context.Context, req *MsgVoteDataset) (*MsgVoteDatasetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VoteDataset not implemented")
}
func (*UnimplementedMsgServer) MarkDatasetAsOfficial(ctx context.Context, req *MsgMarkDatasetAsOfficial) (*MsgMarkDatasetAsOfficialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkDatasetAsOfficial not implemented")
}
func (*UnimplementedMsgServer) RemoveDataset(ctx context.Context, req *MsgRemoveDataset) (*MsgRemoveDatasetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveDataset not implemented")
}
func (*UnimplementedMsgServer) RegisterNode(ctx context.Context, req *MsgRegisterNode) (*MsgRegisterNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterNode not implemented")
}
func (*UnimplementedMsgServer) UpdateNodeRegistration(ctx context.Context, req *MsgUpdateNodeRegistration) (*MsgUpdateNodeRegistrationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNodeRegistration not implemented")
}
func (*UnimplementedMsgServer) SubmitResourceUsage(ctx context.Context, req *MsgSubmitResourceUsage) (*MsgSubmitResourceUsageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitResourceUsage not implemented")
}
func (*UnimplementedMsgServer) CommitPinning(ctx context.Context, req *MsgCommitPinning) (*MsgCommitPinningResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitPinning not implemented")
}
func (*UnimplementedMsgServer) ChallengePinning(ctx context.Context, req *MsgChallengePinning) (*MsgChallengePinningResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengePinning not implemented")
}
func (*UnimplementedMsgServer) RespondToChallenge(ctx context.Context, req *MsgRespondToChallenge) (*MsgRespondToChallengeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondToChallenge not implemented")
}
func (*UnimplementedMsgServer) ResolveChallenge(ctx context.Context, req *MsgResolveChallenge) (*MsgResolveChallengeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveChallenge not implemented")
}
func (*UnimplementedMsgServer) SubmitCPUVerification(ctx context.Context, req *MsgSubmitCPUVerification) (*MsgSubmitCPUVerificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitCPUVerification not implemented")
}
func (*UnimplementedMsgServer) SubmitRandomVerifierResult(ctx context.Context, req *MsgSubmitRandomVerifierResult) (*MsgSubmitRandomVerifierResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitRandomVerifierResult not implemented")
}
func (*UnimplementedMsgServer) RequestInference(ctx context.Context, req *MsgRequestInference) (*MsgRequestInferenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestInference not implemented")
}
func (*UnimplementedMsgServer) SubmitInferenceResult(ctx context.Context, req *MsgSubmitInferenceResult) (*MsgSubmitInferenceResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitInferenceResult not implemented")
}
func (*UnimplementedMsgServer) UpdateServingNodeStatus(ctx context.Context, req *MsgUpdateServingNodeStatus) (*MsgUpdateServingNodeStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateServingNodeStatus not implemented")
}
func (*UnimplementedMsgServer) CreateTrapJob(ctx context.Context, req *MsgCreateTrapJob) (*MsgCreateTrapJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrapJob not implemented")
}
func (*UnimplementedMsgServer) SubmitTrapJobResult(ctx context.Context, req *MsgSubmitTrapJobResult) (*MsgSubmitTrapJobResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTrapJobResult not implemented")
}
func (*UnimplementedMsgServer) AppealTrapJobSlashing(ctx context.Context, req *MsgAppealTrapJobSlashing) (*MsgAppealTrapJobSlashingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppealTrapJobSlashing not implemented")
}
func (*UnimplementedMsgServer) ReportLazyValidation(ctx context.Context, req *MsgReportLazyValidation) (*MsgReportLazyValidationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportLazyValidation not implemented")
}
func (*UnimplementedMsgServer) ReportFalseVerdict(ctx context.Context, req *MsgReportFalseVerdict) (*MsgReportFalseVerdictResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportFalseVerdict not implemented")
}
func (*UnimplementedMsgServer) ReportProposerCensorship(ctx context.Context, req *MsgReportProposerCensorship) (*MsgReportProposerCensorshipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportProposerCensorship not implemented")
}
func (*UnimplementedMsgServer) AppealSlashing(ctx context.Context, req *MsgAppealSlashing) (*MsgAppealSlashingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppealSlashing not implemented")
}
func (*UnimplementedMsgServer) RegisterMentorRelationship(ctx context.Context, req *MsgRegisterMentorRelationship) (*MsgRegisterMentorRelationshipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterMentorRelationship not implemented")
}
func (*UnimplementedMsgServer) CreateSubnet(ctx context.Context, req *MsgCreateSubnet) (*MsgCreateSubnetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSubnet not implemented")
}
func (*UnimplementedMsgServer) SubmitSubnetActivation(ctx context.Context, req *MsgSubmitSubnetActivation) (*MsgSubmitSubnetActivationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitSubnetActivation not implemented")
}
func (*UnimplementedMsgServer) AssignMinerToSubnet(ctx context.Context, req *MsgAssignMinerToSubnet) (*MsgAssignMinerToSubnetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignMinerToSubnet not implemented")
}
func (*UnimplementedMsgServer) CreateTrainingWindow(ctx context.Context, req *MsgCreateTrainingWindow) (*MsgCreateTrainingWindowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrainingWindow not implemented")
}
func (*UnimplementedMsgServer) SubmitAsyncGradient(ctx context.Context, req *MsgSubmitAsyncGradient) (*MsgSubmitAsyncGradientResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAsyncGradient not implemented")
}
func (*UnimplementedMsgServer) SubmitLazyAggregation(ctx context.Context, req *MsgSubmitLazyAggregation) (*MsgSubmitLazyAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitLazyAggregation not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterModel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/RegisterModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterModel(ctx, req.(*MsgRegisterModel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ActivateModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgActivateModel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ActivateModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/ActivateModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ActivateModel(ctx, req.(*MsgActivateModel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitGradient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitGradient)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitGradient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/SubmitGradient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitGradient(ctx, req.(*MsgSubmitGradient))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitAggregation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitAggregation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitAggregation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/SubmitAggregation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitAggregation(ctx, req.(*MsgSubmitAggregation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CommitAggregation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCommitAggregation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CommitAggregation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/CommitAggregation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CommitAggregation(ctx, req.(*MsgCommitAggregation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RevealAggregation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRevealAggregation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RevealAggregation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/RevealAggregation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RevealAggregation(ctx, req.(*MsgRevealAggregation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ChallengeAggregation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgChallengeAggregation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ChallengeAggregation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/ChallengeAggregation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ChallengeAggregation(ctx, req.(*MsgChallengeAggregation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ProposeDataset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProposeDataset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProposeDataset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/ProposeDataset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProposeDataset(ctx, req.(*MsgProposeDataset))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_VoteDataset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgVoteDataset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).VoteDataset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/VoteDataset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).VoteDataset(ctx, req.(*MsgVoteDataset))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MarkDatasetAsOfficial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMarkDatasetAsOfficial)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MarkDatasetAsOfficial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/MarkDatasetAsOfficial",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MarkDatasetAsOfficial(ctx, req.(*MsgMarkDatasetAsOfficial))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoveDataset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoveDataset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoveDataset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/RemoveDataset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoveDataset(ctx, req.(*MsgRemoveDataset))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/RegisterNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterNode(ctx, req.(*MsgRegisterNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateNodeRegistration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateNodeRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateNodeRegistration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/UpdateNodeRegistration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateNodeRegistration(ctx, req.(*MsgUpdateNodeRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitResourceUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitResourceUsage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitResourceUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/SubmitResourceUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitResourceUsage(ctx, req.(*MsgSubmitResourceUsage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CommitPinning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCommitPinning)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CommitPinning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/CommitPinning",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CommitPinning(ctx, req.(*MsgCommitPinning))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ChallengePinning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgChallengePinning)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ChallengePinning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/ChallengePinning",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ChallengePinning(ctx, req.(*MsgChallengePinning))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RespondToChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRespondToChallenge)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RespondToChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/RespondToChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RespondToChallenge(ctx, req.(*MsgRespondToChallenge))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ResolveChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgResolveChallenge)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ResolveChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/ResolveChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ResolveChallenge(ctx, req.(*MsgResolveChallenge))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitCPUVerification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitCPUVerification)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitCPUVerification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/SubmitCPUVerification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitCPUVerification(ctx, req.(*MsgSubmitCPUVerification))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitRandomVerifierResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitRandomVerifierResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitRandomVerifierResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/SubmitRandomVerifierResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitRandomVerifierResult(ctx, req.(*MsgSubmitRandomVerifierResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RequestInference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRequestInference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RequestInference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/RequestInference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RequestInference(ctx, req.(*MsgRequestInference))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitInferenceResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitInferenceResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitInferenceResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/SubmitInferenceResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitInferenceResult(ctx, req.(*MsgSubmitInferenceResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateServingNodeStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateServingNodeStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateServingNodeStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/UpdateServingNodeStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateServingNodeStatus(ctx, req.(*MsgUpdateServingNodeStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateTrapJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateTrapJob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateTrapJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/CreateTrapJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateTrapJob(ctx, req.(*MsgCreateTrapJob))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitTrapJobResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitTrapJobResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitTrapJobResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/SubmitTrapJobResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitTrapJobResult(ctx, req.(*MsgSubmitTrapJobResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AppealTrapJobSlashing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAppealTrapJobSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AppealTrapJobSlashing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/AppealTrapJobSlashing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AppealTrapJobSlashing(ctx, req.(*MsgAppealTrapJobSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ReportLazyValidation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReportLazyValidation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ReportLazyValidation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/ReportLazyValidation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ReportLazyValidation(ctx, req.(*MsgReportLazyValidation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ReportFalseVerdict_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReportFalseVerdict)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ReportFalseVerdict(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/ReportFalseVerdict",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ReportFalseVerdict(ctx, req.(*MsgReportFalseVerdict))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ReportProposerCensorship_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReportProposerCensorship)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ReportProposerCensorship(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/ReportProposerCensorship",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ReportProposerCensorship(ctx, req.(*MsgReportProposerCensorship))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AppealSlashing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAppealSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AppealSlashing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/AppealSlashing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AppealSlashing(ctx, req.(*MsgAppealSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterMentorRelationship_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterMentorRelationship)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterMentorRelationship(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/RegisterMentorRelationship",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterMentorRelationship(ctx, req.(*MsgRegisterMentorRelationship))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateSubnet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/CreateSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateSubnet(ctx, req.(*MsgCreateSubnet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitSubnetActivation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitSubnetActivation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitSubnetActivation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/SubmitSubnetActivation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitSubnetActivation(ctx, req.(*MsgSubmitSubnetActivation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AssignMinerToSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAssignMinerToSubnet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AssignMinerToSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/AssignMinerToSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AssignMinerToSubnet(ctx, req.(*MsgAssignMinerToSubnet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateTrainingWindow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateTrainingWindow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateTrainingWindow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/CreateTrainingWindow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateTrainingWindow(ctx, req.(*MsgCreateTrainingWindow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitAsyncGradient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitAsyncGradient)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitAsyncGradient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/SubmitAsyncGradient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitAsyncGradient(ctx, req.(*MsgSubmitAsyncGradient))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitLazyAggregation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitLazyAggregation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitLazyAggregation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.Msg/SubmitLazyAggregation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitLazyAggregation(ctx, req.(*MsgSubmitLazyAggregation))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "remes.remes.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "RegisterModel",
			Handler:    _Msg_RegisterModel_Handler,
		},
		{
			MethodName: "ActivateModel",
			Handler:    _Msg_ActivateModel_Handler,
		},
		{
			MethodName: "SubmitGradient",
			Handler:    _Msg_SubmitGradient_Handler,
		},
		{
			MethodName: "SubmitAggregation",
			Handler:    _Msg_SubmitAggregation_Handler,
		},
		{
			MethodName: "CommitAggregation",
			Handler:    _Msg_CommitAggregation_Handler,
		},
		{
			MethodName: "RevealAggregation",
			Handler:    _Msg_RevealAggregation_Handler,
		},
		{
			MethodName: "ChallengeAggregation",
			Handler:    _Msg_ChallengeAggregation_Handler,
		},
		{
			MethodName: "ProposeDataset",
			Handler:    _Msg_ProposeDataset_Handler,
		},
		{
			MethodName: "VoteDataset",
			Handler:    _Msg_VoteDataset_Handler,
		},
		{
			MethodName: "MarkDatasetAsOfficial",
			Handler:    _Msg_MarkDatasetAsOfficial_Handler,
		},
		{
			MethodName: "RemoveDataset",
			Handler:    _Msg_RemoveDataset_Handler,
		},
		{
			MethodName: "RegisterNode",
			Handler:    _Msg_RegisterNode_Handler,
		},
		{
			MethodName: "UpdateNodeRegistration",
			Handler:    _Msg_UpdateNodeRegistration_Handler,
		},
		{
			MethodName: "SubmitResourceUsage",
			Handler:    _Msg_SubmitResourceUsage_Handler,
		},
		{
			MethodName: "CommitPinning",
			Handler:    _Msg_CommitPinning_Handler,
		},
		{
			MethodName: "ChallengePinning",
			Handler:    _Msg_ChallengePinning_Handler,
		},
		{
			MethodName: "RespondToChallenge",
			Handler:    _Msg_RespondToChallenge_Handler,
		},
		{
			MethodName: "ResolveChallenge",
			Handler:    _Msg_ResolveChallenge_Handler,
		},
		{
			MethodName: "SubmitCPUVerification",
			Handler:    _Msg_SubmitCPUVerification_Handler,
		},
		{
			MethodName: "SubmitRandomVerifierResult",
			Handler:    _Msg_SubmitRandomVerifierResult_Handler,
		},
		{
			MethodName: "RequestInference",
			Handler:    _Msg_RequestInference_Handler,
		},
		{
			MethodName: "SubmitInferenceResult",
			Handler:    _Msg_SubmitInferenceResult_Handler,
		},
		{
			MethodName: "UpdateServingNodeStatus",
			Handler:    _Msg_UpdateServingNodeStatus_Handler,
		},
		{
			MethodName: "CreateTrapJob",
			Handler:    _Msg_CreateTrapJob_Handler,
		},
		{
			MethodName: "SubmitTrapJobResult",
			Handler:    _Msg_SubmitTrapJobResult_Handler,
		},
		{
			MethodName: "AppealTrapJobSlashing",
			Handler:    _Msg_AppealTrapJobSlashing_Handler,
		},
		{
			MethodName: "ReportLazyValidation",
			Handler:    _Msg_ReportLazyValidation_Handler,
		},
		{
			MethodName: "ReportFalseVerdict",
			Handler:    _Msg_ReportFalseVerdict_Handler,
		},
		{
			MethodName: "ReportProposerCensorship",
			Handler:    _Msg_ReportProposerCensorship_Handler,
		},
		{
			MethodName: "AppealSlashing",
			Handler:    _Msg_AppealSlashing_Handler,
		},
		{
			MethodName: "RegisterMentorRelationship",
			Handler:    _Msg_RegisterMentorRelationship_Handler,
		},
		{
			MethodName: "CreateSubnet",
			Handler:    _Msg_CreateSubnet_Handler,
		},
		{
			MethodName: "SubmitSubnetActivation",
			Handler:    _Msg_SubmitSubnetActivation_Handler,
		},
		{
			MethodName: "AssignMinerToSubnet",
			Handler:    _Msg_AssignMinerToSubnet_Handler,
		},
		{
			MethodName: "CreateTrainingWindow",
			Handler:    _Msg_CreateTrainingWindow_Handler,
		},
		{
			MethodName: "SubmitAsyncGradient",
			Handler:    _Msg_SubmitAsyncGradient_Handler,
		},
		{
			MethodName: "SubmitLazyAggregation",
			Handler:    _Msg_SubmitLazyAggregation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "remes/remes/v1/tx.proto",
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRegisterModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProposalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterModelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterModelResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterModelResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModelId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ModelId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivateModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModelId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ModelId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivateModelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateModelResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateModelResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSubmitGradient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitGradient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitGradient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PorepProofIpfsHash) > 0 {
		i -= len(m.PorepProofIpfsHash)
		copy(dAtA[i:], m.PorepProofIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PorepProofIpfsHash)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.ClaimedLoss) > 0 {
		i -= len(m.ClaimedLoss)
		copy(dAtA[i:], m.ClaimedLoss)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClaimedLoss)))
		i--
		dAtA[i] = 0x7a
	}
	if m.GlobalSeed != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.GlobalSeed))
		i--
		dAtA[i] = 0x70
	}
	if len(m.ContainerSignature) > 0 {
		i -= len(m.ContainerSignature)
		copy(dAtA[i:], m.ContainerSignature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContainerSignature)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.ContainerHash) > 0 {
		i -= len(m.ContainerHash)
		copy(dAtA[i:], m.ContainerHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContainerHash)))
		i--
		dAtA[i] = 0x62
	}
	if m.ModelConfigId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ModelConfigId))
		i--
		dAtA[i] = 0x58
	}
	if m.ProofOfWorkNonce != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProofOfWorkNonce))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Nonce != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x40
	}
	if len(m.GpuArchitecture) > 0 {
		i -= len(m.GpuArchitecture)
		copy(dAtA[i:], m.GpuArchitecture)
		i = encodeVarintTx(dAtA, i, uint64(len(m.GpuArchitecture)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.GradientHash) > 0 {
		i -= len(m.GradientHash)
		copy(dAtA[i:], m.GradientHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.GradientHash)))
		i--
		dAtA[i] = 0x32
	}
	if m.ShardId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x28
	}
	if m.TrainingRoundId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TrainingRoundId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.IpfsHash) > 0 {
		i -= len(m.IpfsHash)
		copy(dAtA[i:], m.IpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.IpfsHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Miner) > 0 {
		i -= len(m.Miner)
		copy(dAtA[i:], m.Miner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Miner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitGradientResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitGradientResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitGradientResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.StoredGradientId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.StoredGradientId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x32
	}
	if m.TrainingRoundId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TrainingRoundId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ParticipantGradientIds) > 0 {
		dAtA4 := make([]byte, len(m.ParticipantGradientIds)*10)
		var j3 int
		for _, num := range m.ParticipantGradientIds {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTx(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MerkleRoot) > 0 {
		i -= len(m.MerkleRoot)
		copy(dAtA[i:], m.MerkleRoot)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MerkleRoot)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AggregatedGradientIpfsHash) > 0 {
		i -= len(m.AggregatedGradientIpfsHash)
		copy(dAtA[i:], m.AggregatedGradientIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AggregatedGradientIpfsHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitAggregationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitAggregationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitAggregationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AggregationId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.AggregationId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCommitAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCommitAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCommitAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParticipantGradientIds) > 0 {
		dAtA6 := make([]byte, len(m.ParticipantGradientIds)*10)
		var j5 int
		for _, num := range m.ParticipantGradientIds {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintTx(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x22
	}
	if m.TrainingRoundId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TrainingRoundId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CommitmentHash) > 0 {
		i -= len(m.CommitmentHash)
		copy(dAtA[i:], m.CommitmentHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CommitmentHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCommitAggregationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCommitAggregationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCommitAggregationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RevealDeadlineHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RevealDeadlineHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.CommitmentId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.CommitmentId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevealAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevealAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevealAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TrainingRoundId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TrainingRoundId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ParticipantGradientIds) > 0 {
		dAtA8 := make([]byte, len(m.ParticipantGradientIds)*10)
		var j7 int
		for _, num := range m.ParticipantGradientIds {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintTx(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MerkleRoot) > 0 {
		i -= len(m.MerkleRoot)
		copy(dAtA[i:], m.MerkleRoot)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MerkleRoot)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AggregatedGradientIpfsHash) > 0 {
		i -= len(m.AggregatedGradientIpfsHash)
		copy(dAtA[i:], m.AggregatedGradientIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AggregatedGradientIpfsHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CommitmentId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.CommitmentId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevealAggregationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevealAggregationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevealAggregationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CommitmentVerified {
		i--
		if m.CommitmentVerified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.AggregationId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.AggregationId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgChallengeAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgChallengeAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgChallengeAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondAmount) > 0 {
		for iNdEx := len(m.BondAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BondAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.EvidenceIpfsHash) > 0 {
		i -= len(m.EvidenceIpfsHash)
		copy(dAtA[i:], m.EvidenceIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EvidenceIpfsHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AggregationId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.AggregationId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Challenger) > 0 {
		i -= len(m.Challenger)
		copy(dAtA[i:], m.Challenger)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Challenger)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgChallengeAggregationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgChallengeAggregationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgChallengeAggregationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChallengeId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ChallengeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposeDataset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposeDataset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposeDataset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.DatasetIpfsHash) > 0 {
		i -= len(m.DatasetIpfsHash)
		copy(dAtA[i:], m.DatasetIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DatasetIpfsHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposeDatasetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposeDatasetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposeDatasetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProposalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgVoteDataset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgVoteDataset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgVoteDataset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RelevanceScore != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RelevanceScore))
		i--
		dAtA[i] = 0x28
	}
	if m.QualityScore != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.QualityScore))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Option) > 0 {
		i -= len(m.Option)
		copy(dAtA[i:], m.Option)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Option)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgVoteDatasetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgVoteDatasetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgVoteDatasetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VoteId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VoteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgMarkDatasetAsOfficial) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMarkDatasetAsOfficial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMarkDatasetAsOfficial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DatasetId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DatasetId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMarkDatasetAsOfficialResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMarkDatasetAsOfficialResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMarkDatasetAsOfficialResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRemoveDataset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveDataset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveDataset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DatasetId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DatasetId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoveDatasetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveDatasetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveDatasetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRegisterNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceProofIpfsHash) > 0 {
		i -= len(m.ResourceProofIpfsHash)
		copy(dAtA[i:], m.ResourceProofIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ResourceProofIpfsHash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RoleAllocations) > 0 {
		for iNdEx := len(m.RoleAllocations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoleAllocations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Roles) > 0 {
		dAtA11 := make([]byte, len(m.Roles)*10)
		var j10 int
		for _, num := range m.Roles {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintTx(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Stake) > 0 {
		i -= len(m.Stake)
		copy(dAtA[i:], m.Stake)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Stake)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.NodeType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.NodeType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegistrationId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RegistrationId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateNodeRegistration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateNodeRegistration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateNodeRegistration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceProofIpfsHash) > 0 {
		i -= len(m.ResourceProofIpfsHash)
		copy(dAtA[i:], m.ResourceProofIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ResourceProofIpfsHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RoleAllocations) > 0 {
		for iNdEx := len(m.RoleAllocations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoleAllocations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Roles) > 0 {
		dAtA14 := make([]byte, len(m.Roles)*10)
		var j13 int
		for _, num := range m.Roles {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintTx(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x1a
	}
	if m.Resources != nil {
		{
			size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateNodeRegistrationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateNodeRegistrationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateNodeRegistrationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSubmitResourceUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitResourceUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitResourceUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofIpfsHash) > 0 {
		i -= len(m.ProofIpfsHash)
		copy(dAtA[i:], m.ProofIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProofIpfsHash)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.ResourceUsage.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Role != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitResourceUsageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitResourceUsageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitResourceUsageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ViolationDetected {
		i--
		if m.ViolationDetected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IsValid {
		i--
		if m.IsValid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCommitPinning) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCommitPinning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCommitPinning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CommitmentDurationBlocks != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.CommitmentDurationBlocks))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Stake) > 0 {
		i -= len(m.Stake)
		copy(dAtA[i:], m.Stake)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Stake)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.IpfsHash) > 0 {
		i -= len(m.IpfsHash)
		copy(dAtA[i:], m.IpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.IpfsHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCommitPinningResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCommitPinningResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCommitPinningResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PinningId) > 0 {
		i -= len(m.PinningId)
		copy(dAtA[i:], m.PinningId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PinningId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgChallengePinning) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgChallengePinning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgChallengePinning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IpfsHash) > 0 {
		i -= len(m.IpfsHash)
		copy(dAtA[i:], m.IpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.IpfsHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Challenger) > 0 {
		i -= len(m.Challenger)
		copy(dAtA[i:], m.Challenger)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Challenger)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgChallengePinningResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgChallengePinningResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgChallengePinningResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChallengeId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ChallengeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRespondToChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRespondToChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRespondToChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofIpfsHash) > 0 {
		i -= len(m.ProofIpfsHash)
		copy(dAtA[i:], m.ProofIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProofIpfsHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ChallengeId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ChallengeId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRespondToChallengeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRespondToChallengeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRespondToChallengeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsValid {
		i--
		if m.IsValid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgResolveChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResolveChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResolveChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResolutionReason) > 0 {
		i -= len(m.ResolutionReason)
		copy(dAtA[i:], m.ResolutionReason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ResolutionReason)))
		i--
		dAtA[i] = 0x22
	}
	if m.FraudDetected {
		i--
		if m.FraudDetected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ChallengeId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ChallengeId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Resolver) > 0 {
		i -= len(m.Resolver)
		copy(dAtA[i:], m.Resolver)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Resolver)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResolveChallengeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResolveChallengeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResolveChallengeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Resolved {
		i--
		if m.Resolved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitCPUVerification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitCPUVerification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitCPUVerification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExpectedHash) > 0 {
		i -= len(m.ExpectedHash)
		copy(dAtA[i:], m.ExpectedHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ExpectedHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ComputedHash) > 0 {
		i -= len(m.ComputedHash)
		copy(dAtA[i:], m.ComputedHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ComputedHash)))
		i--
		dAtA[i] = 0x22
	}
	if m.IsValid {
		i--
		if m.IsValid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ChallengeId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ChallengeId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitCPUVerificationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitCPUVerificationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitCPUVerificationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Accepted {
		i--
		if m.Accepted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitRandomVerifierResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitRandomVerifierResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitRandomVerifierResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataBatchSeed != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DataBatchSeed))
		i--
		dAtA[i] = 0x40
	}
	if m.LossMatch {
		i--
		if m.LossMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.VerifierLoss) > 0 {
		i -= len(m.VerifierLoss)
		copy(dAtA[i:], m.VerifierLoss)
		i = encodeVarintTx(dAtA, i, uint64(len(m.VerifierLoss)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EvidenceIpfsHash) > 0 {
		i -= len(m.EvidenceIpfsHash)
		copy(dAtA[i:], m.EvidenceIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EvidenceIpfsHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GradientHash) > 0 {
		i -= len(m.GradientHash)
		copy(dAtA[i:], m.GradientHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.GradientHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ChallengeId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ChallengeId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Verifier) > 0 {
		i -= len(m.Verifier)
		copy(dAtA[i:], m.Verifier)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Verifier)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitRandomVerifierResultResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitRandomVerifierResultResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitRandomVerifierResultResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Layer_3Triggered {
		i--
		if m.Layer_3Triggered {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Accepted {
		i--
		if m.Accepted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRequestInference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestInference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestInference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fee) > 0 {
		i -= len(m.Fee)
		copy(dAtA[i:], m.Fee)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Fee)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.InputDataIpfsHash) > 0 {
		i -= len(m.InputDataIpfsHash)
		copy(dAtA[i:], m.InputDataIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.InputDataIpfsHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServingNode) > 0 {
		i -= len(m.ServingNode)
		copy(dAtA[i:], m.ServingNode)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ServingNode)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRequestInferenceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestInferenceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestInferenceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitInferenceResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitInferenceResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitInferenceResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LatencyMs != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.LatencyMs))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ResultIpfsHash) > 0 {
		i -= len(m.ResultIpfsHash)
		copy(dAtA[i:], m.ResultIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ResultIpfsHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServingNode) > 0 {
		i -= len(m.ServingNode)
		copy(dAtA[i:], m.ServingNode)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ServingNode)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitInferenceResultResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitInferenceResultResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitInferenceResultResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Accepted {
		i--
		if m.Accepted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateServingNodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateServingNodeStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateServingNodeStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsAvailable {
		i--
		if m.IsAvailable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.ModelIpfsHash) > 0 {
		i -= len(m.ModelIpfsHash)
		copy(dAtA[i:], m.ModelIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ModelIpfsHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServingNode) > 0 {
		i -= len(m.ServingNode)
		copy(dAtA[i:], m.ServingNode)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ServingNode)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateServingNodeStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateServingNodeStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateServingNodeStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Updated {
		i--
		if m.Updated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateTrapJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateTrapJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateTrapJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FederatedSignatures) > 0 {
		for iNdEx := len(m.FederatedSignatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FederatedSignatures[iNdEx])
			copy(dAtA[i:], m.FederatedSignatures[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.FederatedSignatures[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ObfuscateWithDummyData {
		i--
		if m.ObfuscateWithDummyData {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.DeadlineBlocks != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DeadlineBlocks))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ExpectedGradientHash) > 0 {
		i -= len(m.ExpectedGradientHash)
		copy(dAtA[i:], m.ExpectedGradientHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ExpectedGradientHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DatasetIpfsHash) > 0 {
		i -= len(m.DatasetIpfsHash)
		copy(dAtA[i:], m.DatasetIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DatasetIpfsHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TargetMiner) > 0 {
		i -= len(m.TargetMiner)
		copy(dAtA[i:], m.TargetMiner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TargetMiner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateTrapJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateTrapJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateTrapJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrapJobId) > 0 {
		i -= len(m.TrapJobId)
		copy(dAtA[i:], m.TrapJobId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TrapJobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitTrapJobResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitTrapJobResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitTrapJobResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GradientHash) > 0 {
		i -= len(m.GradientHash)
		copy(dAtA[i:], m.GradientHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.GradientHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GradientIpfsHash) > 0 {
		i -= len(m.GradientIpfsHash)
		copy(dAtA[i:], m.GradientIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.GradientIpfsHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TrapJobId) > 0 {
		i -= len(m.TrapJobId)
		copy(dAtA[i:], m.TrapJobId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TrapJobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Miner) > 0 {
		i -= len(m.Miner)
		copy(dAtA[i:], m.Miner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Miner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitTrapJobResultResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitTrapJobResultResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitTrapJobResultResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Verified {
		i--
		if m.Verified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgAppealTrapJobSlashing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAppealTrapJobSlashing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAppealTrapJobSlashing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EvidenceIpfsHash) > 0 {
		i -= len(m.EvidenceIpfsHash)
		copy(dAtA[i:], m.EvidenceIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EvidenceIpfsHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TrapJobId) > 0 {
		i -= len(m.TrapJobId)
		copy(dAtA[i:], m.TrapJobId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TrapJobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Appellant) > 0 {
		i -= len(m.Appellant)
		copy(dAtA[i:], m.Appellant)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Appellant)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAppealTrapJobSlashingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAppealTrapJobSlashingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAppealTrapJobSlashingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppealId) > 0 {
		i -= len(m.AppealId)
		copy(dAtA[i:], m.AppealId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AppealId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgReportLazyValidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReportLazyValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReportLazyValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EvidenceIpfsHash) > 0 {
		i -= len(m.EvidenceIpfsHash)
		copy(dAtA[i:], m.EvidenceIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EvidenceIpfsHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Reporter) > 0 {
		i -= len(m.Reporter)
		copy(dAtA[i:], m.Reporter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reporter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgReportLazyValidationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReportLazyValidationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReportLazyValidationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reported {
		i--
		if m.Reported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgReportFalseVerdict) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReportFalseVerdict) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReportFalseVerdict) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EvidenceIpfsHash) > 0 {
		i -= len(m.EvidenceIpfsHash)
		copy(dAtA[i:], m.EvidenceIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EvidenceIpfsHash)))
		i--
		dAtA[i] = 0x22
	}
	if m.ChallengeId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ChallengeId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Reporter) > 0 {
		i -= len(m.Reporter)
		copy(dAtA[i:], m.Reporter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reporter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgReportFalseVerdictResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReportFalseVerdictResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReportFalseVerdictResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reported {
		i--
		if m.Reported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgReportProposerCensorship) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReportProposerCensorship) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReportProposerCensorship) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EvidenceIpfsHash) > 0 {
		i -= len(m.EvidenceIpfsHash)
		copy(dAtA[i:], m.EvidenceIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EvidenceIpfsHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ExcludedGradientIds) > 0 {
		dAtA18 := make([]byte, len(m.ExcludedGradientIds)*10)
		var j17 int
		for _, num := range m.ExcludedGradientIds {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintTx(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x22
	}
	if m.AggregationId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.AggregationId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ProposerAddress) > 0 {
		i -= len(m.ProposerAddress)
		copy(dAtA[i:], m.ProposerAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProposerAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Reporter) > 0 {
		i -= len(m.Reporter)
		copy(dAtA[i:], m.Reporter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reporter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgReportProposerCensorshipResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReportProposerCensorshipResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReportProposerCensorshipResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reported {
		i--
		if m.Reported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgAppealSlashing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAppealSlashing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAppealSlashing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EvidenceIpfsHash) > 0 {
		i -= len(m.EvidenceIpfsHash)
		copy(dAtA[i:], m.EvidenceIpfsHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EvidenceIpfsHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AppealReason) > 0 {
		i -= len(m.AppealReason)
		copy(dAtA[i:], m.AppealReason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AppealReason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SlashingReason) > 0 {
		i -= len(m.SlashingReason)
		copy(dAtA[i:], m.SlashingReason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SlashingReason)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Appellant) > 0 {
		i -= len(m.Appellant)
		copy(dAtA[i:], m.Appellant)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Appellant)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAppealSlashingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAppealSlashingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAppealSlashingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppealId) > 0 {
		i -= len(m.AppealId)
		copy(dAtA[i:], m.AppealId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AppealId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterMentorRelationship) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterMentorRelationship) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterMentorRelationship) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReducedStakePercentage) > 0 {
		i -= len(m.ReducedStakePercentage)
		copy(dAtA[i:], m.ReducedStakePercentage)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ReducedStakePercentage)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Mentee) > 0 {
		i -= len(m.Mentee)
		copy(dAtA[i:], m.Mentee)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Mentee)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Mentor) > 0 {
		i -= len(m.Mentor)
		copy(dAtA[i:], m.Mentor)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Mentor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterMentorRelationshipResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterMentorRelationshipResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterMentorRelationshipResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Registered {
		i--
		if m.Registered {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposeExecutionEnvironment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposeExecutionEnvironment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposeExecutionEnvironment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Environment.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposeExecutionEnvironmentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposeExecutionEnvironmentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposeExecutionEnvironmentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProposalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgVoteExecutionEnvironment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgVoteExecutionEnvironment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgVoteExecutionEnvironment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VoteOption) > 0 {
		i -= len(m.VoteOption)
		copy(dAtA[i:], m.VoteOption)
		i = encodeVarintTx(dAtA, i, uint64(len(m.VoteOption)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgVoteExecutionEnvironmentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgVoteExecutionEnvironmentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgVoteExecutionEnvironmentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VoteId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VoteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivateExecutionEnvironment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateExecutionEnvironment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateExecutionEnvironment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EnvironmentId) > 0 {
		i -= len(m.EnvironmentId)
		copy(dAtA[i:], m.EnvironmentId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EnvironmentId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivateExecutionEnvironmentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateExecutionEnvironmentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateExecutionEnvironmentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgProposeModelUpgrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposeModelUpgrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposeModelUpgrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposit) > 0 {
		for iNdEx := len(m.Deposit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Deposit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.MigrationWindow != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MigrationWindow))
		i--
		dAtA[i] = 0x40
	}
	if len(m.CompatibilityInfo) > 0 {
		i -= len(m.CompatibilityInfo)
		copy(dAtA[i:], m.CompatibilityInfo)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CompatibilityInfo)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Architecture) > 0 {
		i -= len(m.Architecture)
		copy(dAtA[i:], m.Architecture)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Architecture)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IpfsPath) > 0 {
		i -= len(m.IpfsPath)
		copy(dAtA[i:], m.IpfsPath)
		i = encodeVarintTx(dAtA, i, uint64(len(m.IpfsPath)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NewModelId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.NewModelId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NewModelHash) > 0 {
		i -= len(m.NewModelHash)
		copy(dAtA[i:], m.NewModelHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewModelHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NewModelVersion != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.NewModelVersion))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposeModelUpgradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposeModelUpgradeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposeModelUpgradeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProposalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgVoteModelUpgrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgVoteModelUpgrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgVoteModelUpgrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Vote) > 0 {
		i -= len(m.Vote)
		copy(dAtA[i:], m.Vote)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Vote)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgVoteModelUpgradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgVoteModelUpgradeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgVoteModelUpgradeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgActivateModelUpgrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateModelUpgrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateModelUpgrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProposalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivateModelUpgradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateModelUpgradeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateModelUpgradeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VersionNumber != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VersionNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRollbackModelUpgrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRollbackModelUpgrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRollbackModelUpgrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.VersionNumber != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VersionNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRollbackModelUpgradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRollbackModelUpgradeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRollbackModelUpgradeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateSubnet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSubnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSubnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WindowId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.WindowId))
		i--
		dAtA[i] = 0x28
	}
	if m.NextSubnetId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.NextSubnetId))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.LayerRange.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.SubnetId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SubnetId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateSubnetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSubnetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSubnetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubnetId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SubnetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitSubnetActivation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitSubnetActivation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitSubnetActivation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NextSubnetId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.NextSubnetId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ActivationHash) > 0 {
		i -= len(m.ActivationHash)
		copy(dAtA[i:], m.ActivationHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ActivationHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SubnetId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SubnetId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitSubnetActivationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitSubnetActivationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitSubnetActivationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransmissionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TransmissionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgAssignMinerToSubnet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAssignMinerToSubnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAssignMinerToSubnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WindowId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.WindowId))
		i--
		dAtA[i] = 0x18
	}
	if m.SubnetId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SubnetId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Miner) > 0 {
		i -= len(m.Miner)
		copy(dAtA[i:], m.Miner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Miner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAssignMinerToSubnetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAssignMinerToSubnetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAssignMinerToSubnetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.LayerRange.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.SubnetId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SubnetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateTrainingWindow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateTrainingWindow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateTrainingWindow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AggregatorNode) > 0 {
		i -= len(m.AggregatorNode)
		copy(dAtA[i:], m.AggregatorNode)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AggregatorNode)))
		i--
		dAtA[i] = 0x22
	}
	if m.StartHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.WindowId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.WindowId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateTrainingWindowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateTrainingWindowResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateTrainingWindowResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WindowId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.WindowId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitAsyncGradient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitAsyncGradient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitAsyncGradient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.LayerRange.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.SubnetId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SubnetId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.GradientHash) > 0 {
		i -= len(m.GradientHash)
		copy(dAtA[i:], m.GradientHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.GradientHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.WindowId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.WindowId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Miner) > 0 {
		i -= len(m.Miner)
		copy(dAtA[i:], m.Miner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Miner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitAsyncGradientResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitAsyncGradientResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitAsyncGradientResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubmissionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SubmissionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitLazyAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitLazyAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitLazyAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MerkleRoot) > 0 {
		i -= len(m.MerkleRoot)
		copy(dAtA[i:], m.MerkleRoot)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MerkleRoot)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ResultHash) > 0 {
		i -= len(m.ResultHash)
		copy(dAtA[i:], m.ResultHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ResultHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AggregationMethod) > 0 {
		i -= len(m.AggregationMethod)
		copy(dAtA[i:], m.AggregationMethod)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AggregationMethod)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CollectedGradients) > 0 {
		for iNdEx := len(m.CollectedGradients) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CollectedGradients[iNdEx])
			copy(dAtA[i:], m.CollectedGradients[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.CollectedGradients[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.WindowId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.WindowId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Aggregator) > 0 {
		i -= len(m.Aggregator)
		copy(dAtA[i:], m.Aggregator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Aggregator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitLazyAggregationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitLazyAggregationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitLazyAggregationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AggregationId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.AggregationId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRegisterModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Config.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.ProposalId != 0 {
		n += 1 + sovTx(uint64(m.ProposalId))
	}
	return n
}

func (m *MsgRegisterModelResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ModelId != 0 {
		n += 1 + sovTx(uint64(m.ModelId))
	}
	return n
}

func (m *MsgActivateModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ModelId != 0 {
		n += 1 + sovTx(uint64(m.ModelId))
	}
	return n
}

func (m *MsgActivateModelResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSubmitGradient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Miner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.IpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TrainingRoundId != 0 {
		n += 1 + sovTx(uint64(m.TrainingRoundId))
	}
	if m.ShardId != 0 {
		n += 1 + sovTx(uint64(m.ShardId))
	}
	l = len(m.GradientHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.GpuArchitecture)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovTx(uint64(m.Nonce))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ProofOfWorkNonce != 0 {
		n += 1 + sovTx(uint64(m.ProofOfWorkNonce))
	}
	if m.ModelConfigId != 0 {
		n += 1 + sovTx(uint64(m.ModelConfigId))
	}
	l = len(m.ContainerHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ContainerSignature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.GlobalSeed != 0 {
		n += 1 + sovTx(uint64(m.GlobalSeed))
	}
	l = len(m.ClaimedLoss)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PorepProofIpfsHash)
	if l > 0 {
		n += 2 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitGradientResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoredGradientId != 0 {
		n += 1 + sovTx(uint64(m.StoredGradientId))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AggregatedGradientIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MerkleRoot)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.ParticipantGradientIds) > 0 {
		l = 0
		for _, e := range m.ParticipantGradientIds {
			l += sovTx(uint64(e))
		}
		n += 1 + sovTx(uint64(l)) + l
	}
	if m.TrainingRoundId != 0 {
		n += 1 + sovTx(uint64(m.TrainingRoundId))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitAggregationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregationId != 0 {
		n += 1 + sovTx(uint64(m.AggregationId))
	}
	return n
}

func (m *MsgCommitAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CommitmentHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TrainingRoundId != 0 {
		n += 1 + sovTx(uint64(m.TrainingRoundId))
	}
	if len(m.ParticipantGradientIds) > 0 {
		l = 0
		for _, e := range m.ParticipantGradientIds {
			l += sovTx(uint64(e))
		}
		n += 1 + sovTx(uint64(l)) + l
	}
	return n
}

func (m *MsgCommitAggregationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommitmentId != 0 {
		n += 1 + sovTx(uint64(m.CommitmentId))
	}
	if m.RevealDeadlineHeight != 0 {
		n += 1 + sovTx(uint64(m.RevealDeadlineHeight))
	}
	return n
}

func (m *MsgRevealAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.CommitmentId != 0 {
		n += 1 + sovTx(uint64(m.CommitmentId))
	}
	l = len(m.AggregatedGradientIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MerkleRoot)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.ParticipantGradientIds) > 0 {
		l = 0
		for _, e := range m.ParticipantGradientIds {
			l += sovTx(uint64(e))
		}
		n += 1 + sovTx(uint64(l)) + l
	}
	if m.TrainingRoundId != 0 {
		n += 1 + sovTx(uint64(m.TrainingRoundId))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRevealAggregationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregationId != 0 {
		n += 1 + sovTx(uint64(m.AggregationId))
	}
	if m.CommitmentVerified {
		n += 2
	}
	return n
}

func (m *MsgChallengeAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Challenger)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.AggregationId != 0 {
		n += 1 + sovTx(uint64(m.AggregationId))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.EvidenceIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.BondAmount) > 0 {
		for _, e := range m.BondAmount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgChallengeAggregationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChallengeId != 0 {
		n += 1 + sovTx(uint64(m.ChallengeId))
	}
	return n
}

func (m *MsgProposeDataset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DatasetIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgProposeDatasetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovTx(uint64(m.ProposalId))
	}
	return n
}

func (m *MsgVoteDataset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ProposalId != 0 {
		n += 1 + sovTx(uint64(m.ProposalId))
	}
	l = len(m.Option)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.QualityScore != 0 {
		n += 1 + sovTx(uint64(m.QualityScore))
	}
	if m.RelevanceScore != 0 {
		n += 1 + sovTx(uint64(m.RelevanceScore))
	}
	return n
}

func (m *MsgVoteDatasetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteId != 0 {
		n += 1 + sovTx(uint64(m.VoteId))
	}
	return n
}

func (m *MsgMarkDatasetAsOfficial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DatasetId != 0 {
		n += 1 + sovTx(uint64(m.DatasetId))
	}
	return n
}

func (m *MsgMarkDatasetAsOfficialResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRemoveDataset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DatasetId != 0 {
		n += 1 + sovTx(uint64(m.DatasetId))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRemoveDatasetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRegisterNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.NodeType != 0 {
		n += 1 + sovTx(uint64(m.NodeType))
	}
	l = m.Resources.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Stake)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Roles) > 0 {
		l = 0
		for _, e := range m.Roles {
			l += sovTx(uint64(e))
		}
		n += 1 + sovTx(uint64(l)) + l
	}
	if len(m.RoleAllocations) > 0 {
		for _, e := range m.RoleAllocations {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.ResourceProofIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRegisterNodeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegistrationId != 0 {
		n += 1 + sovTx(uint64(m.RegistrationId))
	}
	return n
}

func (m *MsgUpdateNodeRegistration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Roles) > 0 {
		l = 0
		for _, e := range m.Roles {
			l += sovTx(uint64(e))
		}
		n += 1 + sovTx(uint64(l)) + l
	}
	if len(m.RoleAllocations) > 0 {
		for _, e := range m.RoleAllocations {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.ResourceProofIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateNodeRegistrationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSubmitResourceUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovTx(uint64(m.Role))
	}
	l = m.ResourceUsage.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.ProofIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitResourceUsageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsValid {
		n += 2
	}
	if m.ViolationDetected {
		n += 2
	}
	return n
}

func (m *MsgCommitPinning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.IpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Stake)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.CommitmentDurationBlocks != 0 {
		n += 1 + sovTx(uint64(m.CommitmentDurationBlocks))
	}
	return n
}

func (m *MsgCommitPinningResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PinningId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgChallengePinning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Challenger)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.IpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgChallengePinningResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChallengeId != 0 {
		n += 1 + sovTx(uint64(m.ChallengeId))
	}
	return n
}

func (m *MsgRespondToChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ChallengeId != 0 {
		n += 1 + sovTx(uint64(m.ChallengeId))
	}
	l = len(m.ProofIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRespondToChallengeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsValid {
		n += 2
	}
	return n
}

func (m *MsgResolveChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Resolver)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ChallengeId != 0 {
		n += 1 + sovTx(uint64(m.ChallengeId))
	}
	if m.FraudDetected {
		n += 2
	}
	l = len(m.ResolutionReason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgResolveChallengeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resolved {
		n += 2
	}
	return n
}

func (m *MsgSubmitCPUVerification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ChallengeId != 0 {
		n += 1 + sovTx(uint64(m.ChallengeId))
	}
	if m.IsValid {
		n += 2
	}
	l = len(m.ComputedHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ExpectedHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitCPUVerificationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Accepted {
		n += 2
	}
	return n
}

func (m *MsgSubmitRandomVerifierResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Verifier)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ChallengeId != 0 {
		n += 1 + sovTx(uint64(m.ChallengeId))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.GradientHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.EvidenceIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.VerifierLoss)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.LossMatch {
		n += 2
	}
	if m.DataBatchSeed != 0 {
		n += 1 + sovTx(uint64(m.DataBatchSeed))
	}
	return n
}

func (m *MsgSubmitRandomVerifierResultResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Accepted {
		n += 2
	}
	if m.Layer_3Triggered {
		n += 2
	}
	return n
}

func (m *MsgRequestInference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ServingNode)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.InputDataIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Fee)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRequestInferenceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitInferenceResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServingNode)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ResultIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.LatencyMs != 0 {
		n += 1 + sovTx(uint64(m.LatencyMs))
	}
	return n
}

func (m *MsgSubmitInferenceResultResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Accepted {
		n += 2
	}
	return n
}

func (m *MsgUpdateServingNodeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServingNode)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ModelIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.IsAvailable {
		n += 2
	}
	return n
}

func (m *MsgUpdateServingNodeStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Updated {
		n += 2
	}
	return n
}

func (m *MsgCreateTrapJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TargetMiner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DatasetIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ExpectedGradientHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DeadlineBlocks != 0 {
		n += 1 + sovTx(uint64(m.DeadlineBlocks))
	}
	if m.ObfuscateWithDummyData {
		n += 2
	}
	if len(m.FederatedSignatures) > 0 {
		for _, b := range m.FederatedSignatures {
			l = len(b)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateTrapJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TrapJobId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitTrapJobResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Miner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TrapJobId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.GradientIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.GradientHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitTrapJobResultResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Verified {
		n += 2
	}
	return n
}

func (m *MsgAppealTrapJobSlashing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Appellant)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TrapJobId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.EvidenceIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAppealTrapJobSlashingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppealId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgReportLazyValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reporter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.EvidenceIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgReportLazyValidationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reported {
		n += 2
	}
	return n
}

func (m *MsgReportFalseVerdict) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reporter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ChallengeId != 0 {
		n += 1 + sovTx(uint64(m.ChallengeId))
	}
	l = len(m.EvidenceIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgReportFalseVerdictResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reported {
		n += 2
	}
	return n
}

func (m *MsgReportProposerCensorship) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reporter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ProposerAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.AggregationId != 0 {
		n += 1 + sovTx(uint64(m.AggregationId))
	}
	if len(m.ExcludedGradientIds) > 0 {
		l = 0
		for _, e := range m.ExcludedGradientIds {
			l += sovTx(uint64(e))
		}
		n += 1 + sovTx(uint64(l)) + l
	}
	l = len(m.EvidenceIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgReportProposerCensorshipResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reported {
		n += 2
	}
	return n
}

func (m *MsgAppealSlashing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Appellant)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SlashingReason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AppealReason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.EvidenceIpfsHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAppealSlashingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppealId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRegisterMentorRelationship) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Mentor)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Mentee)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ReducedStakePercentage)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRegisterMentorRelationshipResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Registered {
		n += 2
	}
	return n
}

func (m *MsgProposeExecutionEnvironment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Environment.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgProposeExecutionEnvironmentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovTx(uint64(m.ProposalId))
	}
	return n
}

func (m *MsgVoteExecutionEnvironment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ProposalId != 0 {
		n += 1 + sovTx(uint64(m.ProposalId))
	}
	l = len(m.VoteOption)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgVoteExecutionEnvironmentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteId != 0 {
		n += 1 + sovTx(uint64(m.VoteId))
	}
	return n
}

func (m *MsgActivateExecutionEnvironment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.EnvironmentId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgActivateExecutionEnvironmentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgProposeModelUpgrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.NewModelVersion != 0 {
		n += 1 + sovTx(uint64(m.NewModelVersion))
	}
	l = len(m.NewModelHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.NewModelId != 0 {
		n += 1 + sovTx(uint64(m.NewModelId))
	}
	l = len(m.IpfsPath)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CompatibilityInfo)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MigrationWindow != 0 {
		n += 1 + sovTx(uint64(m.MigrationWindow))
	}
	if len(m.Deposit) > 0 {
		for _, e := range m.Deposit {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgProposeModelUpgradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovTx(uint64(m.ProposalId))
	}
	return n
}

func (m *MsgVoteModelUpgrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ProposalId != 0 {
		n += 1 + sovTx(uint64(m.ProposalId))
	}
	l = len(m.Vote)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgVoteModelUpgradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgActivateModelUpgrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ProposalId != 0 {
		n += 1 + sovTx(uint64(m.ProposalId))
	}
	return n
}

func (m *MsgActivateModelUpgradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionNumber != 0 {
		n += 1 + sovTx(uint64(m.VersionNumber))
	}
	return n
}

func (m *MsgRollbackModelUpgrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.VersionNumber != 0 {
		n += 1 + sovTx(uint64(m.VersionNumber))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRollbackModelUpgradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateSubnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SubnetId != 0 {
		n += 1 + sovTx(uint64(m.SubnetId))
	}
	l = m.LayerRange.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.NextSubnetId != 0 {
		n += 1 + sovTx(uint64(m.NextSubnetId))
	}
	if m.WindowId != 0 {
		n += 1 + sovTx(uint64(m.WindowId))
	}
	return n
}

func (m *MsgCreateSubnetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetId != 0 {
		n += 1 + sovTx(uint64(m.SubnetId))
	}
	return n
}

func (m *MsgSubmitSubnetActivation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SubnetId != 0 {
		n += 1 + sovTx(uint64(m.SubnetId))
	}
	l = len(m.ActivationHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.NextSubnetId != 0 {
		n += 1 + sovTx(uint64(m.NextSubnetId))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitSubnetActivationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransmissionId != 0 {
		n += 1 + sovTx(uint64(m.TransmissionId))
	}
	return n
}

func (m *MsgAssignMinerToSubnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Miner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SubnetId != 0 {
		n += 1 + sovTx(uint64(m.SubnetId))
	}
	if m.WindowId != 0 {
		n += 1 + sovTx(uint64(m.WindowId))
	}
	return n
}

func (m *MsgAssignMinerToSubnetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetId != 0 {
		n += 1 + sovTx(uint64(m.SubnetId))
	}
	l = m.LayerRange.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateTrainingWindow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.WindowId != 0 {
		n += 1 + sovTx(uint64(m.WindowId))
	}
	if m.StartHeight != 0 {
		n += 1 + sovTx(uint64(m.StartHeight))
	}
	l = len(m.AggregatorNode)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateTrainingWindowResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WindowId != 0 {
		n += 1 + sovTx(uint64(m.WindowId))
	}
	return n
}

func (m *MsgSubmitAsyncGradient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Miner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.WindowId != 0 {
		n += 1 + sovTx(uint64(m.WindowId))
	}
	l = len(m.GradientHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SubnetId != 0 {
		n += 1 + sovTx(uint64(m.SubnetId))
	}
	l = m.LayerRange.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSubmitAsyncGradientResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubmissionId != 0 {
		n += 1 + sovTx(uint64(m.SubmissionId))
	}
	return n
}

func (m *MsgSubmitLazyAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Aggregator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.WindowId != 0 {
		n += 1 + sovTx(uint64(m.WindowId))
	}
	if len(m.CollectedGradients) > 0 {
		for _, s := range m.CollectedGradients {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.AggregationMethod)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ResultHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MerkleRoot)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitLazyAggregationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregationId != 0 {
		n += 1 + sovTx(uint64(m.AggregationId))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterModelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterModelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterModelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelId", wireType)
			}
			m.ModelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelId", wireType)
			}
			m.ModelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateModelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateModelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateModelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitGradient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitGradient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitGradient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Miner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingRoundId", wireType)
			}
			m.TrainingRoundId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainingRoundId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GradientHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GradientHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuArchitecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuArchitecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofOfWorkNonce", wireType)
			}
			m.ProofOfWorkNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProofOfWorkNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelConfigId", wireType)
			}
			m.ModelConfigId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelConfigId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerSignature = append(m.ContainerSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.ContainerSignature == nil {
				m.ContainerSignature = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalSeed", wireType)
			}
			m.GlobalSeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalSeed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedLoss", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimedLoss = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PorepProofIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PorepProofIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitGradientResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitGradientResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitGradientResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoredGradientId", wireType)
			}
			m.StoredGradientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoredGradientId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatedGradientIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregatedGradientIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ParticipantGradientIds = append(m.ParticipantGradientIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParticipantGradientIds) == 0 {
					m.ParticipantGradientIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ParticipantGradientIds = append(m.ParticipantGradientIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantGradientIds", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingRoundId", wireType)
			}
			m.TrainingRoundId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainingRoundId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitAggregationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitAggregationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitAggregationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationId", wireType)
			}
			m.AggregationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AggregationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCommitAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCommitAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCommitAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitmentHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitmentHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingRoundId", wireType)
			}
			m.TrainingRoundId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainingRoundId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ParticipantGradientIds = append(m.ParticipantGradientIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParticipantGradientIds) == 0 {
					m.ParticipantGradientIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ParticipantGradientIds = append(m.ParticipantGradientIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantGradientIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCommitAggregationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCommitAggregationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCommitAggregationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitmentId", wireType)
			}
			m.CommitmentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitmentId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevealDeadlineHeight", wireType)
			}
			m.RevealDeadlineHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevealDeadlineHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevealAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevealAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevealAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitmentId", wireType)
			}
			m.CommitmentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitmentId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatedGradientIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregatedGradientIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ParticipantGradientIds = append(m.ParticipantGradientIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParticipantGradientIds) == 0 {
					m.ParticipantGradientIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ParticipantGradientIds = append(m.ParticipantGradientIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantGradientIds", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingRoundId", wireType)
			}
			m.TrainingRoundId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainingRoundId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevealAggregationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevealAggregationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevealAggregationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationId", wireType)
			}
			m.AggregationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AggregationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitmentVerified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CommitmentVerified = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgChallengeAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgChallengeAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgChallengeAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenger", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenger = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationId", wireType)
			}
			m.AggregationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AggregationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondAmount = append(m.BondAmount, types.Coin{})
			if err := m.BondAmount[len(m.BondAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgChallengeAggregationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgChallengeAggregationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgChallengeAggregationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeId", wireType)
			}
			m.ChallengeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposeDataset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposeDataset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposeDataset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposeDatasetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposeDatasetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposeDatasetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgVoteDataset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgVoteDataset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgVoteDataset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QualityScore", wireType)
			}
			m.QualityScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QualityScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelevanceScore", wireType)
			}
			m.RelevanceScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelevanceScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgVoteDatasetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgVoteDatasetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgVoteDatasetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteId", wireType)
			}
			m.VoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoteId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMarkDatasetAsOfficial) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMarkDatasetAsOfficial: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMarkDatasetAsOfficial: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetId", wireType)
			}
			m.DatasetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatasetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMarkDatasetAsOfficialResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMarkDatasetAsOfficialResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMarkDatasetAsOfficialResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveDataset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveDataset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveDataset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetId", wireType)
			}
			m.DatasetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatasetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveDatasetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveDatasetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveDatasetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeType", wireType)
			}
			m.NodeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeType |= NodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stake = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v NodeType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= NodeType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Roles = append(m.Roles, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Roles) == 0 {
					m.Roles = make([]NodeType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v NodeType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= NodeType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Roles = append(m.Roles, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleAllocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleAllocations = append(m.RoleAllocations, &RoleAllocation{})
			if err := m.RoleAllocations[len(m.RoleAllocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceProofIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceProofIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationId", wireType)
			}
			m.RegistrationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegistrationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateNodeRegistration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateNodeRegistration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateNodeRegistration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &ResourceSpec{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v NodeType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= NodeType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Roles = append(m.Roles, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Roles) == 0 {
					m.Roles = make([]NodeType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v NodeType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= NodeType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Roles = append(m.Roles, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleAllocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleAllocations = append(m.RoleAllocations, &RoleAllocation{})
			if err := m.RoleAllocations[len(m.RoleAllocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceProofIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceProofIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateNodeRegistrationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateNodeRegistrationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateNodeRegistrationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitResourceUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitResourceUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitResourceUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= NodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceUsage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceUsage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitResourceUsageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitResourceUsageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitResourceUsageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsValid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsValid = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViolationDetected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ViolationDetected = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCommitPinning) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCommitPinning: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCommitPinning: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stake = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitmentDurationBlocks", wireType)
			}
			m.CommitmentDurationBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitmentDurationBlocks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCommitPinningResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCommitPinningResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCommitPinningResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinningId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PinningId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgChallengePinning) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgChallengePinning: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgChallengePinning: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenger", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenger = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgChallengePinningResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgChallengePinningResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgChallengePinningResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeId", wireType)
			}
			m.ChallengeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRespondToChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRespondToChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRespondToChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeId", wireType)
			}
			m.ChallengeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRespondToChallengeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRespondToChallengeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRespondToChallengeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsValid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsValid = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResolveChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResolveChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResolveChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeId", wireType)
			}
			m.ChallengeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FraudDetected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FraudDetected = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolutionReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolutionReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResolveChallengeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResolveChallengeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResolveChallengeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Resolved = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitCPUVerification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitCPUVerification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitCPUVerification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeId", wireType)
			}
			m.ChallengeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsValid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsValid = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputedHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComputedHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitCPUVerificationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitCPUVerificationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitCPUVerificationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accepted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Accepted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitRandomVerifierResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitRandomVerifierResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitRandomVerifierResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Verifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeId", wireType)
			}
			m.ChallengeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GradientHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GradientHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifierLoss", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifierLoss = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LossMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LossMatch = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataBatchSeed", wireType)
			}
			m.DataBatchSeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataBatchSeed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitRandomVerifierResultResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitRandomVerifierResultResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitRandomVerifierResultResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accepted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Accepted = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer_3Triggered", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Layer_3Triggered = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestInference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestInference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestInference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServingNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServingNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputDataIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputDataIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestInferenceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestInferenceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestInferenceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitInferenceResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitInferenceResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitInferenceResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServingNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServingNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyMs", wireType)
			}
			m.LatencyMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatencyMs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitInferenceResultResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitInferenceResultResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitInferenceResultResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accepted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Accepted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateServingNodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateServingNodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateServingNodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServingNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServingNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAvailable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAvailable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateServingNodeStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateServingNodeStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateServingNodeStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Updated = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateTrapJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateTrapJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateTrapJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetMiner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetMiner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedGradientHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedGradientHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadlineBlocks", wireType)
			}
			m.DeadlineBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeadlineBlocks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObfuscateWithDummyData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ObfuscateWithDummyData = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FederatedSignatures", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FederatedSignatures = append(m.FederatedSignatures, make([]byte, postIndex-iNdEx))
			copy(m.FederatedSignatures[len(m.FederatedSignatures)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateTrapJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateTrapJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateTrapJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrapJobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrapJobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitTrapJobResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitTrapJobResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitTrapJobResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Miner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrapJobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrapJobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GradientIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GradientIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GradientHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GradientHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitTrapJobResultResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitTrapJobResultResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitTrapJobResultResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verified = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAppealTrapJobSlashing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAppealTrapJobSlashing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAppealTrapJobSlashing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appellant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Appellant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrapJobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrapJobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAppealTrapJobSlashingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAppealTrapJobSlashingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAppealTrapJobSlashingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReportLazyValidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReportLazyValidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReportLazyValidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReportLazyValidationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReportLazyValidationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReportLazyValidationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reported = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReportFalseVerdict) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReportFalseVerdict: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReportFalseVerdict: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeId", wireType)
			}
			m.ChallengeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReportFalseVerdictResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReportFalseVerdictResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReportFalseVerdictResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reported = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReportProposerCensorship) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReportProposerCensorship: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReportProposerCensorship: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationId", wireType)
			}
			m.AggregationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AggregationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExcludedGradientIds = append(m.ExcludedGradientIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ExcludedGradientIds) == 0 {
					m.ExcludedGradientIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExcludedGradientIds = append(m.ExcludedGradientIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludedGradientIds", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReportProposerCensorshipResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReportProposerCensorshipResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReportProposerCensorshipResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reported = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAppealSlashing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAppealSlashing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAppealSlashing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appellant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Appellant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashingReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAppealSlashingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAppealSlashingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAppealSlashingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterMentorRelationship) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterMentorRelationship: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterMentorRelationship: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mentor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mentor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mentee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mentee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReducedStakePercentage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReducedStakePercentage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterMentorRelationshipResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterMentorRelationshipResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterMentorRelationshipResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Registered", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Registered = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposeExecutionEnvironment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposeExecutionEnvironment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposeExecutionEnvironment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Environment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposeExecutionEnvironmentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposeExecutionEnvironmentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposeExecutionEnvironmentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgVoteExecutionEnvironment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgVoteExecutionEnvironment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgVoteExecutionEnvironment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteOption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoteOption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgVoteExecutionEnvironmentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgVoteExecutionEnvironmentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgVoteExecutionEnvironmentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteId", wireType)
			}
			m.VoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoteId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateExecutionEnvironment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateExecutionEnvironment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateExecutionEnvironment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvironmentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvironmentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateExecutionEnvironmentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateExecutionEnvironmentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateExecutionEnvironmentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposeModelUpgrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposeModelUpgrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposeModelUpgrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewModelVersion", wireType)
			}
			m.NewModelVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewModelVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewModelHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewModelHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewModelId", wireType)
			}
			m.NewModelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewModelId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpfsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpfsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompatibilityInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompatibilityInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationWindow", wireType)
			}
			m.MigrationWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigrationWindow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = append(m.Deposit, types.Coin{})
			if err := m.Deposit[len(m.Deposit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposeModelUpgradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposeModelUpgradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposeModelUpgradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgVoteModelUpgrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgVoteModelUpgrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgVoteModelUpgrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgVoteModelUpgradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgVoteModelUpgradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgVoteModelUpgradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateModelUpgrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateModelUpgrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateModelUpgrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateModelUpgradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateModelUpgradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateModelUpgradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionNumber", wireType)
			}
			m.VersionNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRollbackModelUpgrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRollbackModelUpgrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRollbackModelUpgrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionNumber", wireType)
			}
			m.VersionNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRollbackModelUpgradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRollbackModelUpgradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRollbackModelUpgradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSubnet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSubnet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSubnet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			m.SubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LayerRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LayerRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSubnetId", wireType)
			}
			m.NextSubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowId", wireType)
			}
			m.WindowId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSubnetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSubnetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSubnetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			m.SubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitSubnetActivation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitSubnetActivation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitSubnetActivation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			m.SubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivationHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSubnetId", wireType)
			}
			m.NextSubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitSubnetActivationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitSubnetActivationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitSubnetActivationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransmissionId", wireType)
			}
			m.TransmissionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransmissionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAssignMinerToSubnet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAssignMinerToSubnet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAssignMinerToSubnet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Miner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			m.SubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowId", wireType)
			}
			m.WindowId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAssignMinerToSubnetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAssignMinerToSubnetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAssignMinerToSubnetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			m.SubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LayerRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LayerRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateTrainingWindow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateTrainingWindow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateTrainingWindow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowId", wireType)
			}
			m.WindowId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatorNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregatorNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateTrainingWindowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateTrainingWindowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateTrainingWindowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowId", wireType)
			}
			m.WindowId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitAsyncGradient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitAsyncGradient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitAsyncGradient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Miner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowId", wireType)
			}
			m.WindowId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GradientHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GradientHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			m.SubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LayerRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LayerRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitAsyncGradientResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitAsyncGradientResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitAsyncGradientResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmissionId", wireType)
			}
			m.SubmissionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmissionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitLazyAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitLazyAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitLazyAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggregator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowId", wireType)
			}
			m.WindowId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedGradients", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectedGradients = append(m.CollectedGradients, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregationMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleRoot = append(m.MerkleRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.MerkleRoot == nil {
				m.MerkleRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitLazyAggregationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitLazyAggregationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitLazyAggregationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationId", wireType)
			}
			m.AggregationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AggregationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
