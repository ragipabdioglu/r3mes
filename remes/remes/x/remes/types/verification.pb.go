// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: remes/remes/v1/verification.proto

package types

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RunForwardPassRequest contains all information needed to run a forward pass
type RunForwardPassRequest struct {
	// IPFS hash of the miner's model weights
	WeightsIpfsHash string `protobuf:"bytes,1,opt,name=weights_ipfs_hash,json=weightsIpfsHash,proto3" json:"weights_ipfs_hash,omitempty"`
	// Batch identifier (deterministic batch selection)
	BatchId string `protobuf:"bytes,2,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Model configuration ID
	ModelConfigId uint64 `protobuf:"varint,3,opt,name=model_config_id,json=modelConfigId,proto3" json:"model_config_id,omitempty"`
	// Dataset IPFS hash (optional, for batch retrieval)
	DatasetIpfsHash string `protobuf:"bytes,4,opt,name=dataset_ipfs_hash,json=datasetIpfsHash,proto3" json:"dataset_ipfs_hash,omitempty"`
	// Timeout in seconds (default: 300)
	TimeoutSeconds uint32 `protobuf:"varint,5,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
}

func (m *RunForwardPassRequest) Reset()         { *m = RunForwardPassRequest{} }
func (m *RunForwardPassRequest) String() string { return proto.CompactTextString(m) }
func (*RunForwardPassRequest) ProtoMessage()    {}
func (*RunForwardPassRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ca8c41b711a62c6, []int{0}
}
func (m *RunForwardPassRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunForwardPassRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunForwardPassRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunForwardPassRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunForwardPassRequest.Merge(m, src)
}
func (m *RunForwardPassRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunForwardPassRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunForwardPassRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunForwardPassRequest proto.InternalMessageInfo

func (m *RunForwardPassRequest) GetWeightsIpfsHash() string {
	if m != nil {
		return m.WeightsIpfsHash
	}
	return ""
}

func (m *RunForwardPassRequest) GetBatchId() string {
	if m != nil {
		return m.BatchId
	}
	return ""
}

func (m *RunForwardPassRequest) GetModelConfigId() uint64 {
	if m != nil {
		return m.ModelConfigId
	}
	return 0
}

func (m *RunForwardPassRequest) GetDatasetIpfsHash() string {
	if m != nil {
		return m.DatasetIpfsHash
	}
	return ""
}

func (m *RunForwardPassRequest) GetTimeoutSeconds() uint32 {
	if m != nil {
		return m.TimeoutSeconds
	}
	return 0
}

// RunForwardPassResponse contains the calculated loss
type RunForwardPassResponse struct {
	// Calculated loss as BitNet integer
	LossInt int64 `protobuf:"varint,1,opt,name=loss_int,json=lossInt,proto3" json:"loss_int,omitempty"`
	// Success status
	Success bool `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	// Error message if failed
	ErrorMessage string `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Execution time in milliseconds
	ExecutionTimeMs uint64 `protobuf:"varint,4,opt,name=execution_time_ms,json=executionTimeMs,proto3" json:"execution_time_ms,omitempty"`
	// GPU used for inference (if applicable)
	GpuInfo string `protobuf:"bytes,5,opt,name=gpu_info,json=gpuInfo,proto3" json:"gpu_info,omitempty"`
}

func (m *RunForwardPassResponse) Reset()         { *m = RunForwardPassResponse{} }
func (m *RunForwardPassResponse) String() string { return proto.CompactTextString(m) }
func (*RunForwardPassResponse) ProtoMessage()    {}
func (*RunForwardPassResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ca8c41b711a62c6, []int{1}
}
func (m *RunForwardPassResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunForwardPassResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunForwardPassResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunForwardPassResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunForwardPassResponse.Merge(m, src)
}
func (m *RunForwardPassResponse) XXX_Size() int {
	return m.Size()
}
func (m *RunForwardPassResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RunForwardPassResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RunForwardPassResponse proto.InternalMessageInfo

func (m *RunForwardPassResponse) GetLossInt() int64 {
	if m != nil {
		return m.LossInt
	}
	return 0
}

func (m *RunForwardPassResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *RunForwardPassResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *RunForwardPassResponse) GetExecutionTimeMs() uint64 {
	if m != nil {
		return m.ExecutionTimeMs
	}
	return 0
}

func (m *RunForwardPassResponse) GetGpuInfo() string {
	if m != nil {
		return m.GpuInfo
	}
	return ""
}

// HealthCheckRequest for service health check
type HealthCheckRequest struct {
}

func (m *HealthCheckRequest) Reset()         { *m = HealthCheckRequest{} }
func (m *HealthCheckRequest) String() string { return proto.CompactTextString(m) }
func (*HealthCheckRequest) ProtoMessage()    {}
func (*HealthCheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ca8c41b711a62c6, []int{2}
}
func (m *HealthCheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthCheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheckRequest.Merge(m, src)
}
func (m *HealthCheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheckRequest proto.InternalMessageInfo

// HealthCheckResponse contains service status
type HealthCheckResponse struct {
	// Service is healthy
	Healthy bool `protobuf:"varint,1,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Service version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Available GPUs
	AvailableGpus []string `protobuf:"bytes,3,rep,name=available_gpus,json=availableGpus,proto3" json:"available_gpus,omitempty"`
	// Model loaded status
	ModelLoaded bool `protobuf:"varint,4,opt,name=model_loaded,json=modelLoaded,proto3" json:"model_loaded,omitempty"`
}

func (m *HealthCheckResponse) Reset()         { *m = HealthCheckResponse{} }
func (m *HealthCheckResponse) String() string { return proto.CompactTextString(m) }
func (*HealthCheckResponse) ProtoMessage()    {}
func (*HealthCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ca8c41b711a62c6, []int{3}
}
func (m *HealthCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheckResponse.Merge(m, src)
}
func (m *HealthCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheckResponse proto.InternalMessageInfo

func (m *HealthCheckResponse) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *HealthCheckResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *HealthCheckResponse) GetAvailableGpus() []string {
	if m != nil {
		return m.AvailableGpus
	}
	return nil
}

func (m *HealthCheckResponse) GetModelLoaded() bool {
	if m != nil {
		return m.ModelLoaded
	}
	return false
}

func init() {
	proto.RegisterType((*RunForwardPassRequest)(nil), "remes.remes.v1.RunForwardPassRequest")
	proto.RegisterType((*RunForwardPassResponse)(nil), "remes.remes.v1.RunForwardPassResponse")
	proto.RegisterType((*HealthCheckRequest)(nil), "remes.remes.v1.HealthCheckRequest")
	proto.RegisterType((*HealthCheckResponse)(nil), "remes.remes.v1.HealthCheckResponse")
}

func init() { proto.RegisterFile("remes/remes/v1/verification.proto", fileDescriptor_9ca8c41b711a62c6) }

var fileDescriptor_9ca8c41b711a62c6 = []byte{
	// 525 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x93, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0xc7, 0xe3, 0x5f, 0xf2, 0x23, 0xc9, 0xb6, 0x49, 0xc4, 0x06, 0x90, 0xe9, 0xc1, 0x4a, 0x53,
	0xb5, 0x44, 0x48, 0xa4, 0x2a, 0xbc, 0x01, 0x95, 0xa0, 0x91, 0xa8, 0x84, 0xb6, 0xa8, 0x07, 0x2e,
	0xab, 0x8d, 0x3d, 0xb6, 0x57, 0xd8, 0x5e, 0xe3, 0x59, 0xbb, 0xed, 0x5b, 0x20, 0xf1, 0x34, 0xbc,
	0x01, 0x27, 0xd4, 0x23, 0x12, 0x17, 0x94, 0xbc, 0x08, 0xf2, 0xda, 0x89, 0x92, 0x82, 0xe0, 0xb2,
	0xd2, 0x7c, 0x67, 0xec, 0x99, 0xcf, 0xfc, 0x21, 0xfb, 0x19, 0xc4, 0x80, 0xc7, 0xd5, 0x5b, 0x9c,
	0x1c, 0x17, 0x90, 0x49, 0x5f, 0xba, 0x42, 0x4b, 0x95, 0x4c, 0xd3, 0x4c, 0x69, 0x45, 0xfb, 0xc6,
	0x39, 0xad, 0xde, 0xe2, 0x64, 0xfc, 0xc3, 0x22, 0x0f, 0x59, 0x9e, 0xbc, 0x52, 0xd9, 0x95, 0xc8,
	0xbc, 0xb7, 0x02, 0x91, 0xc1, 0xc7, 0x1c, 0x50, 0xd3, 0xa7, 0xe4, 0xfe, 0x15, 0xc8, 0x20, 0xd4,
	0xc8, 0x65, 0xea, 0x23, 0x0f, 0x05, 0x86, 0xb6, 0x35, 0xb2, 0x26, 0x5d, 0x36, 0xa8, 0x1d, 0xb3,
	0xd4, 0xc7, 0x33, 0x81, 0x21, 0x7d, 0x4c, 0x3a, 0x73, 0xa1, 0xdd, 0x90, 0x4b, 0xcf, 0xfe, 0xcf,
	0x84, 0xb4, 0x8d, 0x3d, 0xf3, 0xe8, 0x11, 0x19, 0xc4, 0xca, 0x83, 0x88, 0xbb, 0x2a, 0xf1, 0x65,
	0x50, 0x46, 0x34, 0x47, 0xd6, 0xa4, 0xc5, 0x7a, 0x46, 0x3e, 0x35, 0xea, 0xcc, 0x2b, 0xd3, 0x79,
	0x42, 0x0b, 0x04, 0xbd, 0x91, 0xae, 0x55, 0xa5, 0xab, 0x1d, 0xeb, 0x74, 0x4f, 0xc8, 0x40, 0xcb,
	0x18, 0x54, 0xae, 0x39, 0x82, 0xab, 0x12, 0x0f, 0xed, 0xff, 0x47, 0xd6, 0xa4, 0xc7, 0xfa, 0xb5,
	0x7c, 0x51, 0xa9, 0xe3, 0x2f, 0x16, 0x79, 0x74, 0x97, 0x0e, 0x53, 0x95, 0x20, 0x94, 0x25, 0x47,
	0x0a, 0x91, 0xcb, 0x44, 0x1b, 0xaa, 0x26, 0x6b, 0x97, 0xf6, 0x2c, 0xd1, 0xd4, 0x26, 0x6d, 0xcc,
	0x5d, 0x17, 0x10, 0x0d, 0x4c, 0x87, 0xad, 0x4c, 0x7a, 0x40, 0x7a, 0x90, 0x65, 0x2a, 0xe3, 0x31,
	0x20, 0x8a, 0x00, 0x0c, 0x4a, 0x97, 0xed, 0x1a, 0xf1, 0xbc, 0xd2, 0x4a, 0x12, 0xb8, 0x06, 0x37,
	0x2f, 0xbb, 0xce, 0xcb, 0x82, 0x78, 0x8c, 0x86, 0xa4, 0xc5, 0x06, 0x6b, 0xc7, 0x3b, 0x19, 0xc3,
	0x39, 0x96, 0x55, 0x04, 0x69, 0xce, 0x65, 0xe2, 0x2b, 0x83, 0xd0, 0x65, 0xed, 0x20, 0xcd, 0x67,
	0x89, 0xaf, 0xc6, 0x0f, 0x08, 0x3d, 0x03, 0x11, 0xe9, 0xf0, 0x34, 0x04, 0xf7, 0x43, 0x3d, 0x95,
	0xf1, 0x67, 0x8b, 0x0c, 0xb7, 0xe4, 0x1a, 0xc7, 0x26, 0xed, 0xd0, 0xc8, 0x37, 0x86, 0xa6, 0xc3,
	0x56, 0x66, 0xe9, 0x29, 0x20, 0x43, 0xa9, 0x92, 0xd5, 0x68, 0x6a, 0x93, 0x1e, 0x92, 0xbe, 0x28,
	0x84, 0x8c, 0xc4, 0x3c, 0x02, 0x1e, 0xa4, 0x39, 0xda, 0xcd, 0x51, 0x73, 0xd2, 0x65, 0xbd, 0xb5,
	0xfa, 0x3a, 0xcd, 0x91, 0xee, 0x93, 0xdd, 0x6a, 0x82, 0x91, 0x12, 0x1e, 0x78, 0x06, 0xa5, 0xc3,
	0x76, 0x8c, 0xf6, 0xc6, 0x48, 0xcf, 0xbf, 0x59, 0x64, 0x78, 0xb9, 0xb1, 0x6c, 0x17, 0x90, 0x15,
	0xd2, 0x05, 0xca, 0x49, 0x7f, 0xbb, 0xfd, 0xf4, 0x70, 0xba, 0xbd, 0x80, 0xd3, 0x3f, 0x2e, 0xdf,
	0xde, 0xd1, 0xbf, 0xc2, 0x6a, 0xec, 0x4b, 0xb2, 0xb3, 0xd1, 0x0d, 0x3a, 0xbe, 0xfb, 0xd9, 0xef,
	0x1d, 0xdc, 0x3b, 0xf8, 0x6b, 0x4c, 0xf5, 0xdf, 0x97, 0xcf, 0xbe, 0x2e, 0x1c, 0xeb, 0x76, 0xe1,
	0x58, 0x3f, 0x17, 0x8e, 0xf5, 0x69, 0xe9, 0x34, 0x6e, 0x97, 0x4e, 0xe3, 0xfb, 0xd2, 0x69, 0xbc,
	0x1f, 0x56, 0xd7, 0x75, 0x5d, 0x5f, 0x99, 0xbe, 0x49, 0x01, 0xe7, 0xf7, 0xcc, 0x71, 0xbd, 0xf8,
	0x15, 0x00, 0x00, 0xff, 0xff, 0x52, 0x3e, 0x9a, 0x71, 0x81, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VerificationServiceClient is the client API for VerificationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VerificationServiceClient interface {
	// RunForwardPass performs a forward pass (inference) on a batch
	// This is called by the Go validator to verify miner's claimed loss
	RunForwardPass(ctx context.Context, in *RunForwardPassRequest, opts ...grpc.CallOption) (*RunForwardPassResponse, error)
	// Health check for the verification service
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type verificationServiceClient struct {
	cc grpc1.ClientConn
}

func NewVerificationServiceClient(cc grpc1.ClientConn) VerificationServiceClient {
	return &verificationServiceClient{cc}
}

func (c *verificationServiceClient) RunForwardPass(ctx context.Context, in *RunForwardPassRequest, opts ...grpc.CallOption) (*RunForwardPassResponse, error) {
	out := new(RunForwardPassResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.VerificationService/RunForwardPass", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verificationServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, "/remes.remes.v1.VerificationService/HealthCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VerificationServiceServer is the server API for VerificationService service.
type VerificationServiceServer interface {
	// RunForwardPass performs a forward pass (inference) on a batch
	// This is called by the Go validator to verify miner's claimed loss
	RunForwardPass(context.Context, *RunForwardPassRequest) (*RunForwardPassResponse, error)
	// Health check for the verification service
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
}

// UnimplementedVerificationServiceServer can be embedded to have forward compatible implementations.
type UnimplementedVerificationServiceServer struct {
}

func (*UnimplementedVerificationServiceServer) RunForwardPass(ctx context.Context, req *RunForwardPassRequest) (*RunForwardPassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunForwardPass not implemented")
}
func (*UnimplementedVerificationServiceServer) HealthCheck(ctx context.Context, req *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}

func RegisterVerificationServiceServer(s grpc1.Server, srv VerificationServiceServer) {
	s.RegisterService(&_VerificationService_serviceDesc, srv)
}

func _VerificationService_RunForwardPass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunForwardPassRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerificationServiceServer).RunForwardPass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.VerificationService/RunForwardPass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerificationServiceServer).RunForwardPass(ctx, req.(*RunForwardPassRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerificationService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerificationServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remes.remes.v1.VerificationService/HealthCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerificationServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var VerificationService_serviceDesc = _VerificationService_serviceDesc
var _VerificationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "remes.remes.v1.VerificationService",
	HandlerType: (*VerificationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunForwardPass",
			Handler:    _VerificationService_RunForwardPass_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _VerificationService_HealthCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "remes/remes/v1/verification.proto",
}

func (m *RunForwardPassRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunForwardPassRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunForwardPassRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeoutSeconds != 0 {
		i = encodeVarintVerification(dAtA, i, uint64(m.TimeoutSeconds))
		i--
		dAtA[i] = 0x28
	}
	if len(m.DatasetIpfsHash) > 0 {
		i -= len(m.DatasetIpfsHash)
		copy(dAtA[i:], m.DatasetIpfsHash)
		i = encodeVarintVerification(dAtA, i, uint64(len(m.DatasetIpfsHash)))
		i--
		dAtA[i] = 0x22
	}
	if m.ModelConfigId != 0 {
		i = encodeVarintVerification(dAtA, i, uint64(m.ModelConfigId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BatchId) > 0 {
		i -= len(m.BatchId)
		copy(dAtA[i:], m.BatchId)
		i = encodeVarintVerification(dAtA, i, uint64(len(m.BatchId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WeightsIpfsHash) > 0 {
		i -= len(m.WeightsIpfsHash)
		copy(dAtA[i:], m.WeightsIpfsHash)
		i = encodeVarintVerification(dAtA, i, uint64(len(m.WeightsIpfsHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunForwardPassResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunForwardPassResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunForwardPassResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GpuInfo) > 0 {
		i -= len(m.GpuInfo)
		copy(dAtA[i:], m.GpuInfo)
		i = encodeVarintVerification(dAtA, i, uint64(len(m.GpuInfo)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ExecutionTimeMs != 0 {
		i = encodeVarintVerification(dAtA, i, uint64(m.ExecutionTimeMs))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintVerification(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.LossInt != 0 {
		i = encodeVarintVerification(dAtA, i, uint64(m.LossInt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HealthCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCheckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *HealthCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModelLoaded {
		i--
		if m.ModelLoaded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.AvailableGpus) > 0 {
		for iNdEx := len(m.AvailableGpus) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AvailableGpus[iNdEx])
			copy(dAtA[i:], m.AvailableGpus[iNdEx])
			i = encodeVarintVerification(dAtA, i, uint64(len(m.AvailableGpus[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintVerification(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.Healthy {
		i--
		if m.Healthy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintVerification(dAtA []byte, offset int, v uint64) int {
	offset -= sovVerification(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RunForwardPassRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WeightsIpfsHash)
	if l > 0 {
		n += 1 + l + sovVerification(uint64(l))
	}
	l = len(m.BatchId)
	if l > 0 {
		n += 1 + l + sovVerification(uint64(l))
	}
	if m.ModelConfigId != 0 {
		n += 1 + sovVerification(uint64(m.ModelConfigId))
	}
	l = len(m.DatasetIpfsHash)
	if l > 0 {
		n += 1 + l + sovVerification(uint64(l))
	}
	if m.TimeoutSeconds != 0 {
		n += 1 + sovVerification(uint64(m.TimeoutSeconds))
	}
	return n
}

func (m *RunForwardPassResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LossInt != 0 {
		n += 1 + sovVerification(uint64(m.LossInt))
	}
	if m.Success {
		n += 2
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovVerification(uint64(l))
	}
	if m.ExecutionTimeMs != 0 {
		n += 1 + sovVerification(uint64(m.ExecutionTimeMs))
	}
	l = len(m.GpuInfo)
	if l > 0 {
		n += 1 + l + sovVerification(uint64(l))
	}
	return n
}

func (m *HealthCheckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *HealthCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Healthy {
		n += 2
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovVerification(uint64(l))
	}
	if len(m.AvailableGpus) > 0 {
		for _, s := range m.AvailableGpus {
			l = len(s)
			n += 1 + l + sovVerification(uint64(l))
		}
	}
	if m.ModelLoaded {
		n += 2
	}
	return n
}

func sovVerification(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVerification(x uint64) (n int) {
	return sovVerification(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RunForwardPassRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVerification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunForwardPassRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunForwardPassRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightsIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVerification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVerification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WeightsIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVerification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVerification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelConfigId", wireType)
			}
			m.ModelConfigId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelConfigId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVerification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVerification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutSeconds", wireType)
			}
			m.TimeoutSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutSeconds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVerification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVerification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunForwardPassResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVerification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunForwardPassResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunForwardPassResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LossInt", wireType)
			}
			m.LossInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LossInt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVerification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVerification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionTimeMs", wireType)
			}
			m.ExecutionTimeMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutionTimeMs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVerification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVerification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVerification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVerification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVerification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVerification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVerification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVerification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Healthy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Healthy = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVerification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVerification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableGpus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVerification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVerification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailableGpus = append(m.AvailableGpus, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelLoaded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ModelLoaded = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVerification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVerification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVerification(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVerification
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVerification
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVerification
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupVerification
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthVerification
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthVerification        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVerification          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupVerification = fmt.Errorf("proto: unexpected end of group")
)
