package keeper_test

import (
	"testing"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/stretchr/testify/require"
)

// TestProofOfReplication_RoundTrip verifies that a PoRep generated by the keeper
// can be successfully verified using the on-chain verification logic.
func TestProofOfReplication_RoundTrip(t *testing.T) {
	f := initFixture(t)
	ctx := sdk.UnwrapSDKContext(f.ctx)

	data := []byte("test-gradient-data-for-porep")
	miner := "cosmos1mineraddress0000000000000000000000"
	ipfsHash := "QmTestGradientHash0000000000000000000"

	porep, err := f.keeper.GeneratePoRep(ctx, data, miner, ipfsHash)
	require.NoError(t, err)
	require.NotNil(t, porep)

	// Basic sanity checks
	require.NotEmpty(t, porep.DataHash)
	require.NotEmpty(t, porep.ReplicaHash)
	require.NotEmpty(t, porep.MerkleProof)
	require.NotEmpty(t, porep.StorageProof)
	require.NotEmpty(t, porep.ReplicationId)
	require.Equal(t, miner, porep.MinerAddress)

	// Now verify using the keeper logic
	ok, err := f.keeper.VerifyPoRep(ctx, porep, ipfsHash)
	require.NoError(t, err)
	require.True(t, ok, "generated PoRep must verify successfully")
}

// TestProofOfReplication_InvalidReplicationID ensures that tampering with the
// replication ID causes verification to fail.
func TestProofOfReplication_InvalidReplicationID(t *testing.T) {
	f := initFixture(t)
	ctx := sdk.UnwrapSDKContext(f.ctx)

	data := []byte("test-gradient-data-for-porep-invalid")
	miner := "cosmos1mineraddress0000000000000000000000"
	ipfsHash := "QmTestGradientHash0000000000000000001"

	porep, err := f.keeper.GeneratePoRep(ctx, data, miner, ipfsHash)
	require.NoError(t, err)

	// Tamper with replication ID
	porep.ReplicationId = "deadbeef" + porep.ReplicationId

	ok, err := f.keeper.VerifyPoRep(ctx, porep, ipfsHash)
	require.Error(t, err)
	require.False(t, ok)
}

// TestProofOfReplication_InvalidStorageProof ensures that tampering with the
// storage proof causes verification to fail.
func TestProofOfReplication_InvalidStorageProof(t *testing.T) {
	f := initFixture(t)
	ctx := sdk.UnwrapSDKContext(f.ctx)

	data := []byte("test-gradient-data-for-porep-storage")
	miner := "cosmos1mineraddress0000000000000000000000"
	ipfsHash := "QmTestGradientHash0000000000000000002"

	porep, err := f.keeper.GeneratePoRep(ctx, data, miner, ipfsHash)
	require.NoError(t, err)

	// Tamper with storage proof
	if len(porep.StorageProof) > 0 {
		porep.StorageProof[0] ^= 0xFF
	}

	ok, err := f.keeper.VerifyPoRep(ctx, porep, ipfsHash)
	require.Error(t, err)
	require.False(t, ok)
}


