// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: remes/remes/v1/node.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// NodeType represents the type of node
type NodeType int32

const (
	// NODE_TYPE_UNSPECIFIED indicates an unspecified node type
	NODE_TYPE_UNSPECIFIED NodeType = 0
	// NODE_TYPE_MINING indicates a mining node
	NODE_TYPE_MINING NodeType = 1
	// NODE_TYPE_SERVING indicates a serving node
	NODE_TYPE_SERVING NodeType = 2
	// NODE_TYPE_VALIDATOR indicates a validator node
	NODE_TYPE_VALIDATOR NodeType = 3
	// NODE_TYPE_PROPOSER indicates a proposer node
	NODE_TYPE_PROPOSER NodeType = 4
)

var NodeType_name = map[int32]string{
	0: "NODE_TYPE_UNSPECIFIED",
	1: "NODE_TYPE_MINING",
	2: "NODE_TYPE_SERVING",
	3: "NODE_TYPE_VALIDATOR",
	4: "NODE_TYPE_PROPOSER",
}

var NodeType_value = map[string]int32{
	"NODE_TYPE_UNSPECIFIED": 0,
	"NODE_TYPE_MINING":      1,
	"NODE_TYPE_SERVING":     2,
	"NODE_TYPE_VALIDATOR":   3,
	"NODE_TYPE_PROPOSER":    4,
}

func (x NodeType) String() string {
	return proto.EnumName(NodeType_name, int32(x))
}

func (NodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1e0a350c3a4a928, []int{0}
}

// NodeStatus represents the status of a node
type NodeStatus int32

const (
	// NODE_STATUS_UNSPECIFIED indicates an unspecified status
	NODE_STATUS_UNSPECIFIED NodeStatus = 0
	// NODE_STATUS_ACTIVE indicates an active node
	NODE_STATUS_ACTIVE NodeStatus = 1
	// NODE_STATUS_INACTIVE indicates an inactive node
	NODE_STATUS_INACTIVE NodeStatus = 2
	// NODE_STATUS_SLASHED indicates a slashed node
	NODE_STATUS_SLASHED NodeStatus = 3
	// NODE_STATUS_SUSPENDED indicates a suspended node
	NODE_STATUS_SUSPENDED NodeStatus = 4
)

var NodeStatus_name = map[int32]string{
	0: "NODE_STATUS_UNSPECIFIED",
	1: "NODE_STATUS_ACTIVE",
	2: "NODE_STATUS_INACTIVE",
	3: "NODE_STATUS_SLASHED",
	4: "NODE_STATUS_SUSPENDED",
}

var NodeStatus_value = map[string]int32{
	"NODE_STATUS_UNSPECIFIED": 0,
	"NODE_STATUS_ACTIVE":      1,
	"NODE_STATUS_INACTIVE":    2,
	"NODE_STATUS_SLASHED":     3,
	"NODE_STATUS_SUSPENDED":   4,
}

func (x NodeStatus) String() string {
	return proto.EnumName(NodeStatus_name, int32(x))
}

func (NodeStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1e0a350c3a4a928, []int{1}
}

// ResourceSpec represents the resource specification for a node
type ResourceSpec struct {
	// cpu_cores is the number of CPU cores
	CpuCores uint32 `protobuf:"varint,1,opt,name=cpu_cores,json=cpuCores,proto3" json:"cpu_cores,omitempty"`
	// memory_gb is the memory in GB
	MemoryGb uint32 `protobuf:"varint,2,opt,name=memory_gb,json=memoryGb,proto3" json:"memory_gb,omitempty"`
	// gpu_count is the number of GPUs
	GpuCount uint32 `protobuf:"varint,3,opt,name=gpu_count,json=gpuCount,proto3" json:"gpu_count,omitempty"`
	// gpu_memory_gb is the GPU memory in GB
	GpuMemoryGb uint32 `protobuf:"varint,4,opt,name=gpu_memory_gb,json=gpuMemoryGb,proto3" json:"gpu_memory_gb,omitempty"`
	// storage_gb is the storage in GB
	StorageGb uint32 `protobuf:"varint,5,opt,name=storage_gb,json=storageGb,proto3" json:"storage_gb,omitempty"`
	// network_bandwidth_mbps is the network bandwidth in Mbps
	NetworkBandwidthMbps uint32 `protobuf:"varint,6,opt,name=network_bandwidth_mbps,json=networkBandwidthMbps,proto3" json:"network_bandwidth_mbps,omitempty"`
}

func (m *ResourceSpec) Reset()         { *m = ResourceSpec{} }
func (m *ResourceSpec) String() string { return proto.CompactTextString(m) }
func (*ResourceSpec) ProtoMessage()    {}
func (*ResourceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1e0a350c3a4a928, []int{0}
}
func (m *ResourceSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceSpec.Merge(m, src)
}
func (m *ResourceSpec) XXX_Size() int {
	return m.Size()
}
func (m *ResourceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceSpec proto.InternalMessageInfo

func (m *ResourceSpec) GetCpuCores() uint32 {
	if m != nil {
		return m.CpuCores
	}
	return 0
}

func (m *ResourceSpec) GetMemoryGb() uint32 {
	if m != nil {
		return m.MemoryGb
	}
	return 0
}

func (m *ResourceSpec) GetGpuCount() uint32 {
	if m != nil {
		return m.GpuCount
	}
	return 0
}

func (m *ResourceSpec) GetGpuMemoryGb() uint32 {
	if m != nil {
		return m.GpuMemoryGb
	}
	return 0
}

func (m *ResourceSpec) GetStorageGb() uint32 {
	if m != nil {
		return m.StorageGb
	}
	return 0
}

func (m *ResourceSpec) GetNetworkBandwidthMbps() uint32 {
	if m != nil {
		return m.NetworkBandwidthMbps
	}
	return 0
}

// ResourceQuota represents a resource quota for a specific role
type ResourceQuota struct {
	// role is the node role
	Role NodeType `protobuf:"varint,1,opt,name=role,proto3,enum=remes.remes.v1.NodeType" json:"role,omitempty"`
	// cpu_cores is the allocated CPU cores
	CpuCores uint32 `protobuf:"varint,2,opt,name=cpu_cores,json=cpuCores,proto3" json:"cpu_cores,omitempty"`
	// memory_gb is the allocated memory in GB
	MemoryGb uint32 `protobuf:"varint,3,opt,name=memory_gb,json=memoryGb,proto3" json:"memory_gb,omitempty"`
	// gpu_count is the allocated GPUs
	GpuCount uint32 `protobuf:"varint,4,opt,name=gpu_count,json=gpuCount,proto3" json:"gpu_count,omitempty"`
	// gpu_memory_gb is the allocated GPU memory in GB
	GpuMemoryGb uint32 `protobuf:"varint,5,opt,name=gpu_memory_gb,json=gpuMemoryGb,proto3" json:"gpu_memory_gb,omitempty"`
}

func (m *ResourceQuota) Reset()         { *m = ResourceQuota{} }
func (m *ResourceQuota) String() string { return proto.CompactTextString(m) }
func (*ResourceQuota) ProtoMessage()    {}
func (*ResourceQuota) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1e0a350c3a4a928, []int{1}
}
func (m *ResourceQuota) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceQuota) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceQuota.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceQuota) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceQuota.Merge(m, src)
}
func (m *ResourceQuota) XXX_Size() int {
	return m.Size()
}
func (m *ResourceQuota) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceQuota.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceQuota proto.InternalMessageInfo

func (m *ResourceQuota) GetRole() NodeType {
	if m != nil {
		return m.Role
	}
	return NODE_TYPE_UNSPECIFIED
}

func (m *ResourceQuota) GetCpuCores() uint32 {
	if m != nil {
		return m.CpuCores
	}
	return 0
}

func (m *ResourceQuota) GetMemoryGb() uint32 {
	if m != nil {
		return m.MemoryGb
	}
	return 0
}

func (m *ResourceQuota) GetGpuCount() uint32 {
	if m != nil {
		return m.GpuCount
	}
	return 0
}

func (m *ResourceQuota) GetGpuMemoryGb() uint32 {
	if m != nil {
		return m.GpuMemoryGb
	}
	return 0
}

// NodeRegistration represents a registered node in the network
type NodeRegistration struct {
	// node_address is the address of the node
	NodeAddress string `protobuf:"bytes,1,opt,name=node_address,json=nodeAddress,proto3" json:"node_address,omitempty"`
	// node_type is the primary node type
	NodeType NodeType `protobuf:"varint,2,opt,name=node_type,json=nodeType,proto3,enum=remes.remes.v1.NodeType" json:"node_type,omitempty"`
	// resources is the total resource specification
	Resources ResourceSpec `protobuf:"bytes,3,opt,name=resources,proto3" json:"resources"`
	// stake is the staked amount
	Stake string `protobuf:"bytes,4,opt,name=stake,proto3" json:"stake,omitempty"`
	// status is the node status
	Status NodeStatus `protobuf:"varint,5,opt,name=status,proto3,enum=remes.remes.v1.NodeStatus" json:"status,omitempty"`
	// roles is the list of roles this node can perform (multi-role support)
	Roles []NodeType `protobuf:"varint,6,rep,packed,name=roles,proto3,enum=remes.remes.v1.NodeType" json:"roles,omitempty"`
	// role_allocations maps roles to resource quotas
	RoleAllocations []*RoleAllocation `protobuf:"bytes,7,rep,name=role_allocations,json=roleAllocations,proto3" json:"role_allocations,omitempty"`
	// registered_at_height is the block height when registered
	RegisteredAtHeight int64 `protobuf:"varint,8,opt,name=registered_at_height,json=registeredAtHeight,proto3" json:"registered_at_height,omitempty"`
	// registered_at_time is the timestamp when registered
	RegisteredAtTime time.Time `protobuf:"bytes,9,opt,name=registered_at_time,json=registeredAtTime,proto3,stdtime" json:"registered_at_time"`
	// resource_proof_ipfs_hash is the IPFS hash of the resource allocation proof
	ResourceProofIpfsHash string `protobuf:"bytes,10,opt,name=resource_proof_ipfs_hash,json=resourceProofIpfsHash,proto3" json:"resource_proof_ipfs_hash,omitempty"`
	// last_heartbeat_height is the last block height when node sent heartbeat
	LastHeartbeatHeight int64 `protobuf:"varint,11,opt,name=last_heartbeat_height,json=lastHeartbeatHeight,proto3" json:"last_heartbeat_height,omitempty"`
	// slashing_events is the number of slashing events
	SlashingEvents uint64 `protobuf:"varint,12,opt,name=slashing_events,json=slashingEvents,proto3" json:"slashing_events,omitempty"`
}

func (m *NodeRegistration) Reset()         { *m = NodeRegistration{} }
func (m *NodeRegistration) String() string { return proto.CompactTextString(m) }
func (*NodeRegistration) ProtoMessage()    {}
func (*NodeRegistration) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1e0a350c3a4a928, []int{2}
}
func (m *NodeRegistration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeRegistration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeRegistration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeRegistration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeRegistration.Merge(m, src)
}
func (m *NodeRegistration) XXX_Size() int {
	return m.Size()
}
func (m *NodeRegistration) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeRegistration.DiscardUnknown(m)
}

var xxx_messageInfo_NodeRegistration proto.InternalMessageInfo

func (m *NodeRegistration) GetNodeAddress() string {
	if m != nil {
		return m.NodeAddress
	}
	return ""
}

func (m *NodeRegistration) GetNodeType() NodeType {
	if m != nil {
		return m.NodeType
	}
	return NODE_TYPE_UNSPECIFIED
}

func (m *NodeRegistration) GetResources() ResourceSpec {
	if m != nil {
		return m.Resources
	}
	return ResourceSpec{}
}

func (m *NodeRegistration) GetStake() string {
	if m != nil {
		return m.Stake
	}
	return ""
}

func (m *NodeRegistration) GetStatus() NodeStatus {
	if m != nil {
		return m.Status
	}
	return NODE_STATUS_UNSPECIFIED
}

func (m *NodeRegistration) GetRoles() []NodeType {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *NodeRegistration) GetRoleAllocations() []*RoleAllocation {
	if m != nil {
		return m.RoleAllocations
	}
	return nil
}

func (m *NodeRegistration) GetRegisteredAtHeight() int64 {
	if m != nil {
		return m.RegisteredAtHeight
	}
	return 0
}

func (m *NodeRegistration) GetRegisteredAtTime() time.Time {
	if m != nil {
		return m.RegisteredAtTime
	}
	return time.Time{}
}

func (m *NodeRegistration) GetResourceProofIpfsHash() string {
	if m != nil {
		return m.ResourceProofIpfsHash
	}
	return ""
}

func (m *NodeRegistration) GetLastHeartbeatHeight() int64 {
	if m != nil {
		return m.LastHeartbeatHeight
	}
	return 0
}

func (m *NodeRegistration) GetSlashingEvents() uint64 {
	if m != nil {
		return m.SlashingEvents
	}
	return 0
}

// RoleAllocation represents resource allocation for a specific role
type RoleAllocation struct {
	// role is the node role
	Role NodeType `protobuf:"varint,1,opt,name=role,proto3,enum=remes.remes.v1.NodeType" json:"role,omitempty"`
	// quota is the resource quota for this role
	Quota ResourceQuota `protobuf:"bytes,2,opt,name=quota,proto3" json:"quota"`
}

func (m *RoleAllocation) Reset()         { *m = RoleAllocation{} }
func (m *RoleAllocation) String() string { return proto.CompactTextString(m) }
func (*RoleAllocation) ProtoMessage()    {}
func (*RoleAllocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1e0a350c3a4a928, []int{3}
}
func (m *RoleAllocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleAllocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleAllocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleAllocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleAllocation.Merge(m, src)
}
func (m *RoleAllocation) XXX_Size() int {
	return m.Size()
}
func (m *RoleAllocation) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleAllocation.DiscardUnknown(m)
}

var xxx_messageInfo_RoleAllocation proto.InternalMessageInfo

func (m *RoleAllocation) GetRole() NodeType {
	if m != nil {
		return m.Role
	}
	return NODE_TYPE_UNSPECIFIED
}

func (m *RoleAllocation) GetQuota() ResourceQuota {
	if m != nil {
		return m.Quota
	}
	return ResourceQuota{}
}

func init() {
	proto.RegisterEnum("remes.remes.v1.NodeType", NodeType_name, NodeType_value)
	proto.RegisterEnum("remes.remes.v1.NodeStatus", NodeStatus_name, NodeStatus_value)
	proto.RegisterType((*ResourceSpec)(nil), "remes.remes.v1.ResourceSpec")
	proto.RegisterType((*ResourceQuota)(nil), "remes.remes.v1.ResourceQuota")
	proto.RegisterType((*NodeRegistration)(nil), "remes.remes.v1.NodeRegistration")
	proto.RegisterType((*RoleAllocation)(nil), "remes.remes.v1.RoleAllocation")
}

func init() { proto.RegisterFile("remes/remes/v1/node.proto", fileDescriptor_f1e0a350c3a4a928) }

var fileDescriptor_f1e0a350c3a4a928 = []byte{
	// 848 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0x41, 0x73, 0xdb, 0x44,
	0x14, 0xb6, 0x62, 0x3b, 0xd8, 0xcf, 0x89, 0xab, 0x6e, 0x9c, 0x56, 0x75, 0xa9, 0x13, 0x7c, 0x21,
	0xd3, 0x01, 0x9b, 0x1a, 0x18, 0x86, 0x1b, 0x4e, 0x2c, 0x12, 0xcd, 0x34, 0x8e, 0x59, 0x39, 0x99,
	0x81, 0x8b, 0x66, 0x65, 0x6f, 0x64, 0x4f, 0x6d, 0xad, 0xd8, 0x5d, 0xa5, 0xe4, 0x1f, 0xc0, 0x89,
	0x5e, 0xf8, 0x05, 0xfc, 0x09, 0x7e, 0x42, 0x8f, 0x3d, 0x72, 0x2a, 0x4c, 0xf2, 0x47, 0x98, 0x5d,
	0x49, 0x55, 0xdc, 0x42, 0x98, 0x5e, 0x76, 0x76, 0xbf, 0xef, 0x7b, 0x3b, 0xef, 0x7d, 0x7a, 0x4f,
	0x0b, 0x0f, 0x38, 0x5d, 0x52, 0xd1, 0x4d, 0xd6, 0x8b, 0x27, 0xdd, 0x90, 0x4d, 0x69, 0x27, 0xe2,
	0x4c, 0x32, 0x54, 0xd7, 0x60, 0x27, 0x59, 0x2f, 0x9e, 0x34, 0xef, 0x92, 0xe5, 0x3c, 0x64, 0x5d,
	0xbd, 0x26, 0x92, 0x66, 0x23, 0x60, 0x01, 0xd3, 0xdb, 0xae, 0xda, 0xa5, 0xe8, 0x4e, 0xc0, 0x58,
	0xb0, 0xa0, 0x5d, 0x7d, 0xf2, 0xe3, 0xf3, 0xae, 0x9c, 0x2f, 0xa9, 0x90, 0x64, 0x19, 0x25, 0x82,
	0xf6, 0x6b, 0x03, 0x36, 0x30, 0x15, 0x2c, 0xe6, 0x13, 0xea, 0x46, 0x74, 0x82, 0x1e, 0x42, 0x75,
	0x12, 0xc5, 0xde, 0x84, 0x71, 0x2a, 0x2c, 0x63, 0xd7, 0xd8, 0xdb, 0xc4, 0x95, 0x49, 0x14, 0x1f,
	0xa8, 0xb3, 0x22, 0x97, 0x74, 0xc9, 0xf8, 0xa5, 0x17, 0xf8, 0xd6, 0x5a, 0x42, 0x26, 0xc0, 0xa1,
	0xaf, 0xc8, 0x40, 0x47, 0xc6, 0xa1, 0xb4, 0x8a, 0x09, 0x19, 0xa8, 0xc8, 0x38, 0x94, 0xa8, 0x0d,
	0x9b, 0x8a, 0xcc, 0xa3, 0x4b, 0x5a, 0x50, 0x0b, 0xa2, 0xf8, 0x38, 0xbb, 0xe0, 0x11, 0x80, 0x90,
	0x8c, 0x93, 0x80, 0x2a, 0x41, 0x59, 0x0b, 0xaa, 0x29, 0x72, 0xe8, 0xa3, 0x2f, 0xe0, 0x5e, 0x48,
	0xe5, 0x73, 0xc6, 0x9f, 0x79, 0x3e, 0x09, 0xa7, 0xcf, 0xe7, 0x53, 0x39, 0xf3, 0x96, 0x7e, 0x24,
	0xac, 0x75, 0x2d, 0x6d, 0xa4, 0xec, 0x7e, 0x46, 0x1e, 0xfb, 0x91, 0x68, 0xff, 0x61, 0xc0, 0x66,
	0x56, 0xe0, 0x77, 0x31, 0x93, 0x04, 0x7d, 0x02, 0x25, 0xce, 0x16, 0x54, 0x17, 0x57, 0xef, 0x59,
	0x9d, 0x55, 0x6f, 0x3b, 0x43, 0x36, 0xa5, 0xe3, 0xcb, 0x88, 0x62, 0xad, 0x5a, 0xf5, 0x63, 0xed,
	0x36, 0x3f, 0x8a, 0xb7, 0xf9, 0x51, 0xfa, 0x3f, 0x3f, 0xca, 0xef, 0xf8, 0xd1, 0xfe, 0xb5, 0x0c,
	0xa6, 0xca, 0x06, 0xd3, 0x60, 0x2e, 0x24, 0x27, 0x72, 0xce, 0x42, 0xf4, 0x11, 0x6c, 0xa8, 0xc6,
	0xf0, 0xc8, 0x74, 0xca, 0xa9, 0x48, 0x3e, 0x51, 0x15, 0xd7, 0x14, 0xd6, 0x4f, 0x20, 0xf4, 0x25,
	0x54, 0xb5, 0x44, 0x5e, 0x46, 0x54, 0xa7, 0x7c, 0x5b, 0x95, 0x95, 0x30, 0xdd, 0xa1, 0x6f, 0xa0,
	0xca, 0x53, 0xa3, 0x84, 0x2e, 0xa6, 0xd6, 0xfb, 0xf0, 0xed, 0xb0, 0x9b, 0xad, 0xb2, 0x5f, 0x7a,
	0xf9, 0x7a, 0xa7, 0x80, 0xf3, 0x20, 0xd4, 0x80, 0xb2, 0x90, 0xe4, 0x19, 0xd5, 0xd5, 0x56, 0x71,
	0x72, 0x40, 0x3d, 0x58, 0x17, 0x92, 0xc8, 0x58, 0xe8, 0x1a, 0xeb, 0xbd, 0xe6, 0xbf, 0xe5, 0xe2,
	0x6a, 0x05, 0x4e, 0x95, 0xa8, 0x03, 0x65, 0xe5, 0xbe, 0xfa, 0xb4, 0xc5, 0x5b, 0xd3, 0x4f, 0x64,
	0xc8, 0x01, 0x53, 0x6d, 0x3c, 0xb2, 0x58, 0xb0, 0x89, 0x36, 0x4a, 0x58, 0x1f, 0xec, 0x16, 0xf7,
	0x6a, 0xbd, 0xd6, 0x3b, 0x25, 0xb0, 0x05, 0xed, 0xbf, 0x91, 0xe1, 0x3b, 0x7c, 0xe5, 0x2c, 0xd0,
	0x67, 0xd0, 0xe0, 0xda, 0x70, 0xca, 0xe9, 0xd4, 0x23, 0xd2, 0x9b, 0xd1, 0x79, 0x30, 0x93, 0x56,
	0x65, 0xd7, 0xd8, 0x2b, 0x62, 0x94, 0x73, 0x7d, 0x79, 0xa4, 0x19, 0x84, 0x01, 0xad, 0x46, 0xa8,
	0x21, 0xb3, 0xaa, 0xda, 0xc1, 0x66, 0x27, 0x99, 0xc0, 0x4e, 0x36, 0x81, 0x9d, 0x71, 0x36, 0x81,
	0xfb, 0x15, 0xe5, 0xdf, 0x8b, 0xbf, 0x76, 0x0c, 0x6c, 0xde, 0xbc, 0x55, 0x09, 0xd0, 0x57, 0x60,
	0x65, 0xbe, 0x7a, 0x11, 0x67, 0xec, 0xdc, 0x9b, 0x47, 0xe7, 0xc2, 0x9b, 0x11, 0x31, 0xb3, 0x40,
	0xbb, 0xbb, 0x9d, 0xf1, 0x23, 0x45, 0x3b, 0xd1, 0xb9, 0x38, 0x22, 0x62, 0x86, 0x7a, 0xb0, 0xbd,
	0x20, 0x42, 0x65, 0x4d, 0xb8, 0xf4, 0x69, 0x9e, 0x7f, 0x4d, 0xe7, 0xbf, 0xa5, 0xc8, 0xa3, 0x8c,
	0x4b, 0x0b, 0xf8, 0x18, 0xee, 0x88, 0x05, 0x11, 0xb3, 0x79, 0x18, 0x78, 0xf4, 0x82, 0x86, 0x52,
	0x58, 0x1b, 0xbb, 0xc6, 0x5e, 0x09, 0xd7, 0x33, 0xd8, 0xd6, 0x68, 0xfb, 0x12, 0xea, 0xab, 0xf6,
	0xbd, 0xe7, 0x30, 0x7d, 0x0d, 0xe5, 0x1f, 0xd5, 0x0c, 0xea, 0xae, 0xac, 0xf5, 0x1e, 0xfd, 0x57,
	0x7b, 0xe9, 0x41, 0x4d, 0xfb, 0x2b, 0x89, 0x78, 0xfc, 0x8b, 0x01, 0x95, 0xec, 0x36, 0xf4, 0x00,
	0xb6, 0x87, 0x27, 0x03, 0xdb, 0x1b, 0x7f, 0x3f, 0xb2, 0xbd, 0xd3, 0xa1, 0x3b, 0xb2, 0x0f, 0x9c,
	0x6f, 0x1d, 0x7b, 0x60, 0x16, 0x50, 0x03, 0xcc, 0x9c, 0x3a, 0x76, 0x86, 0xce, 0xf0, 0xd0, 0x34,
	0xd0, 0x36, 0xdc, 0xcd, 0x51, 0xd7, 0xc6, 0x67, 0x0a, 0x5e, 0x43, 0xf7, 0x61, 0x2b, 0x87, 0xcf,
	0xfa, 0x4f, 0x9d, 0x41, 0x7f, 0x7c, 0x82, 0xcd, 0x22, 0xba, 0x07, 0x28, 0x27, 0x46, 0xf8, 0x64,
	0x74, 0xe2, 0xda, 0xd8, 0x2c, 0x35, 0x4b, 0x3f, 0xff, 0xde, 0x2a, 0x3c, 0xfe, 0xcd, 0x00, 0xc8,
	0x9b, 0x16, 0x3d, 0x84, 0xfb, 0x5a, 0xec, 0x8e, 0xfb, 0xe3, 0x53, 0xf7, 0xad, 0x7c, 0xb2, 0x9b,
	0x52, 0xb2, 0x7f, 0x30, 0x76, 0xce, 0x6c, 0xd3, 0x40, 0x16, 0x34, 0x6e, 0xe2, 0xce, 0x30, 0x65,
	0xf2, 0xa4, 0x52, 0xc6, 0x7d, 0xda, 0x77, 0x8f, 0xec, 0x81, 0x59, 0x7c, 0x53, 0x75, 0x46, 0x9c,
	0xba, 0x23, 0x7b, 0x38, 0xb0, 0x07, 0x59, 0x5e, 0xfb, 0x9f, 0xbe, 0xbc, 0x6a, 0x19, 0xaf, 0xae,
	0x5a, 0xc6, 0xdf, 0x57, 0x2d, 0xe3, 0xc5, 0x75, 0xab, 0xf0, 0xea, 0xba, 0x55, 0xf8, 0xf3, 0xba,
	0x55, 0xf8, 0x61, 0x2b, 0x79, 0x55, 0x7e, 0x4a, 0x5f, 0x17, 0xf5, 0x67, 0x10, 0xfe, 0xba, 0xee,
	0xc9, 0xcf, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0xe8, 0xda, 0x0e, 0x9d, 0x79, 0x06, 0x00, 0x00,
}

func (m *ResourceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NetworkBandwidthMbps != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.NetworkBandwidthMbps))
		i--
		dAtA[i] = 0x30
	}
	if m.StorageGb != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.StorageGb))
		i--
		dAtA[i] = 0x28
	}
	if m.GpuMemoryGb != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.GpuMemoryGb))
		i--
		dAtA[i] = 0x20
	}
	if m.GpuCount != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.GpuCount))
		i--
		dAtA[i] = 0x18
	}
	if m.MemoryGb != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.MemoryGb))
		i--
		dAtA[i] = 0x10
	}
	if m.CpuCores != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.CpuCores))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResourceQuota) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceQuota) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceQuota) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GpuMemoryGb != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.GpuMemoryGb))
		i--
		dAtA[i] = 0x28
	}
	if m.GpuCount != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.GpuCount))
		i--
		dAtA[i] = 0x20
	}
	if m.MemoryGb != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.MemoryGb))
		i--
		dAtA[i] = 0x18
	}
	if m.CpuCores != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.CpuCores))
		i--
		dAtA[i] = 0x10
	}
	if m.Role != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeRegistration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeRegistration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeRegistration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SlashingEvents != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.SlashingEvents))
		i--
		dAtA[i] = 0x60
	}
	if m.LastHeartbeatHeight != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.LastHeartbeatHeight))
		i--
		dAtA[i] = 0x58
	}
	if len(m.ResourceProofIpfsHash) > 0 {
		i -= len(m.ResourceProofIpfsHash)
		copy(dAtA[i:], m.ResourceProofIpfsHash)
		i = encodeVarintNode(dAtA, i, uint64(len(m.ResourceProofIpfsHash)))
		i--
		dAtA[i] = 0x52
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.RegisteredAtTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RegisteredAtTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintNode(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x4a
	if m.RegisteredAtHeight != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.RegisteredAtHeight))
		i--
		dAtA[i] = 0x40
	}
	if len(m.RoleAllocations) > 0 {
		for iNdEx := len(m.RoleAllocations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoleAllocations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Roles) > 0 {
		dAtA3 := make([]byte, len(m.Roles)*10)
		var j2 int
		for _, num := range m.Roles {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintNode(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x32
	}
	if m.Status != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Stake) > 0 {
		i -= len(m.Stake)
		copy(dAtA[i:], m.Stake)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Stake)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.NodeType != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.NodeType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintNode(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleAllocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleAllocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleAllocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Quota.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Role != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNode(dAtA []byte, offset int, v uint64) int {
	offset -= sovNode(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ResourceSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuCores != 0 {
		n += 1 + sovNode(uint64(m.CpuCores))
	}
	if m.MemoryGb != 0 {
		n += 1 + sovNode(uint64(m.MemoryGb))
	}
	if m.GpuCount != 0 {
		n += 1 + sovNode(uint64(m.GpuCount))
	}
	if m.GpuMemoryGb != 0 {
		n += 1 + sovNode(uint64(m.GpuMemoryGb))
	}
	if m.StorageGb != 0 {
		n += 1 + sovNode(uint64(m.StorageGb))
	}
	if m.NetworkBandwidthMbps != 0 {
		n += 1 + sovNode(uint64(m.NetworkBandwidthMbps))
	}
	return n
}

func (m *ResourceQuota) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Role != 0 {
		n += 1 + sovNode(uint64(m.Role))
	}
	if m.CpuCores != 0 {
		n += 1 + sovNode(uint64(m.CpuCores))
	}
	if m.MemoryGb != 0 {
		n += 1 + sovNode(uint64(m.MemoryGb))
	}
	if m.GpuCount != 0 {
		n += 1 + sovNode(uint64(m.GpuCount))
	}
	if m.GpuMemoryGb != 0 {
		n += 1 + sovNode(uint64(m.GpuMemoryGb))
	}
	return n
}

func (m *NodeRegistration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.NodeType != 0 {
		n += 1 + sovNode(uint64(m.NodeType))
	}
	l = m.Resources.Size()
	n += 1 + l + sovNode(uint64(l))
	l = len(m.Stake)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovNode(uint64(m.Status))
	}
	if len(m.Roles) > 0 {
		l = 0
		for _, e := range m.Roles {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	if len(m.RoleAllocations) > 0 {
		for _, e := range m.RoleAllocations {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if m.RegisteredAtHeight != 0 {
		n += 1 + sovNode(uint64(m.RegisteredAtHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RegisteredAtTime)
	n += 1 + l + sovNode(uint64(l))
	l = len(m.ResourceProofIpfsHash)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.LastHeartbeatHeight != 0 {
		n += 1 + sovNode(uint64(m.LastHeartbeatHeight))
	}
	if m.SlashingEvents != 0 {
		n += 1 + sovNode(uint64(m.SlashingEvents))
	}
	return n
}

func (m *RoleAllocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Role != 0 {
		n += 1 + sovNode(uint64(m.Role))
	}
	l = m.Quota.Size()
	n += 1 + l + sovNode(uint64(l))
	return n
}

func sovNode(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNode(x uint64) (n int) {
	return sovNode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ResourceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCores", wireType)
			}
			m.CpuCores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCores |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryGb", wireType)
			}
			m.MemoryGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryGb |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuCount", wireType)
			}
			m.GpuCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpuCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuMemoryGb", wireType)
			}
			m.GpuMemoryGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpuMemoryGb |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageGb", wireType)
			}
			m.StorageGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageGb |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkBandwidthMbps", wireType)
			}
			m.NetworkBandwidthMbps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkBandwidthMbps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceQuota) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceQuota: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceQuota: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= NodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCores", wireType)
			}
			m.CpuCores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCores |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryGb", wireType)
			}
			m.MemoryGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryGb |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuCount", wireType)
			}
			m.GpuCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpuCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuMemoryGb", wireType)
			}
			m.GpuMemoryGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpuMemoryGb |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeRegistration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeRegistration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeRegistration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeType", wireType)
			}
			m.NodeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeType |= NodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stake = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= NodeStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v NodeType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= NodeType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Roles = append(m.Roles, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Roles) == 0 {
					m.Roles = make([]NodeType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v NodeType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= NodeType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Roles = append(m.Roles, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleAllocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleAllocations = append(m.RoleAllocations, &RoleAllocation{})
			if err := m.RoleAllocations[len(m.RoleAllocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAtHeight", wireType)
			}
			m.RegisteredAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegisteredAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAtTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.RegisteredAtTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceProofIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceProofIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeatHeight", wireType)
			}
			m.LastHeartbeatHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeartbeatHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingEvents", wireType)
			}
			m.SlashingEvents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashingEvents |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleAllocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleAllocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleAllocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= NodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quota", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Quota.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNode
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNode
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNode
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNode        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNode          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNode = fmt.Errorf("proto: unexpected end of group")
)
