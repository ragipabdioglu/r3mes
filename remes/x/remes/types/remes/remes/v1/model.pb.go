// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: remes/remes/v1/model.proto

package types

import (
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ModelType identifies the neural network architecture
type ModelType int32

const (
	ModelType_MODEL_TYPE_UNSPECIFIED ModelType = 0
	ModelType_MODEL_TYPE_BITNET      ModelType = 1  // BitNet 1.58-bit (current default)
	ModelType_MODEL_TYPE_MAMBA       ModelType = 2  // Mamba state-space model
	ModelType_MODEL_TYPE_RWKV        ModelType = 3  // RWKV attention-free transformer
	ModelType_MODEL_TYPE_CUSTOM      ModelType = 99 // Custom architecture (via governance)
)

// Enum value maps for ModelType.
var (
	ModelType_name = map[int32]string{
		0:  "MODEL_TYPE_UNSPECIFIED",
		1:  "MODEL_TYPE_BITNET",
		2:  "MODEL_TYPE_MAMBA",
		3:  "MODEL_TYPE_RWKV",
		99: "MODEL_TYPE_CUSTOM",
	}
	ModelType_value = map[string]int32{
		"MODEL_TYPE_UNSPECIFIED": 0,
		"MODEL_TYPE_BITNET":      1,
		"MODEL_TYPE_MAMBA":       2,
		"MODEL_TYPE_RWKV":        3,
		"MODEL_TYPE_CUSTOM":      99,
	}
)

func (x ModelType) Enum() *ModelType {
	p := new(ModelType)
	*p = x
	return p
}

func (x ModelType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ModelType) Descriptor() protoreflect.EnumDescriptor {
	return file_remes_remes_v1_model_proto_enumTypes[0].Descriptor()
}

func (ModelType) Type() protoreflect.EnumType {
	return &file_remes_remes_v1_model_proto_enumTypes[0]
}

func (x ModelType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ModelType.Descriptor instead.
func (ModelType) EnumDescriptor() ([]byte, []int) {
	return file_remes_remes_v1_model_proto_rawDescGZIP(), []int{0}
}

// EncryptionType specifies encryption method for enterprise privacy
type EncryptionType int32

const (
	EncryptionType_ENCRYPTION_TYPE_UNSPECIFIED    EncryptionType = 0
	EncryptionType_ENCRYPTION_TYPE_PLAINTEXT      EncryptionType = 1 // No encryption (current default)
	EncryptionType_ENCRYPTION_TYPE_TEE_SGX        EncryptionType = 2 // Intel SGX Trusted Execution Environment
	EncryptionType_ENCRYPTION_TYPE_HOMOMORPHIC    EncryptionType = 3 // Homomorphic encryption (future)
	EncryptionType_ENCRYPTION_TYPE_ZERO_KNOWLEDGE EncryptionType = 4 // ZK proofs (future)
)

// Enum value maps for EncryptionType.
var (
	EncryptionType_name = map[int32]string{
		0: "ENCRYPTION_TYPE_UNSPECIFIED",
		1: "ENCRYPTION_TYPE_PLAINTEXT",
		2: "ENCRYPTION_TYPE_TEE_SGX",
		3: "ENCRYPTION_TYPE_HOMOMORPHIC",
		4: "ENCRYPTION_TYPE_ZERO_KNOWLEDGE",
	}
	EncryptionType_value = map[string]int32{
		"ENCRYPTION_TYPE_UNSPECIFIED":    0,
		"ENCRYPTION_TYPE_PLAINTEXT":      1,
		"ENCRYPTION_TYPE_TEE_SGX":        2,
		"ENCRYPTION_TYPE_HOMOMORPHIC":    3,
		"ENCRYPTION_TYPE_ZERO_KNOWLEDGE": 4,
	}
)

func (x EncryptionType) Enum() *EncryptionType {
	p := new(EncryptionType)
	*p = x
	return p
}

func (x EncryptionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EncryptionType) Descriptor() protoreflect.EnumDescriptor {
	return file_remes_remes_v1_model_proto_enumTypes[1].Descriptor()
}

func (EncryptionType) Type() protoreflect.EnumType {
	return &file_remes_remes_v1_model_proto_enumTypes[1]
}

func (x EncryptionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EncryptionType.Descriptor instead.
func (EncryptionType) EnumDescriptor() ([]byte, []int) {
	return file_remes_remes_v1_model_proto_rawDescGZIP(), []int{1}
}

// ModelConfig represents a generic model configuration
// This replaces BitNet-specific hard-coding
type ModelConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// model_type identifies the model architecture
	ModelType ModelType `protobuf:"varint,1,opt,name=model_type,json=modelType,proto3,enum=remes.remes.v1.ModelType" json:"model_type,omitempty"`
	// model_version is the version string (e.g., "b1.58", "v2.0")
	ModelVersion string `protobuf:"bytes,2,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
	// architecture_config is a JSON blob containing architecture-specific parameters
	// For BitNet: {"hidden_size": 768, "num_layers": 12, "lora_rank": 8, ...}
	// For Mamba: {"d_model": 512, "d_state": 16, "d_conv": 4, ...}
	// For RWKV: {"n_embd": 4096, "n_layer": 32, "n_head": 32, ...}
	ArchitectureConfig string `protobuf:"bytes,3,opt,name=architecture_config,json=architectureConfig,proto3" json:"architecture_config,omitempty"` // JSON-encoded configuration
	// container_hash is the Docker/OCI image hash for deterministic execution
	// Format: "sha256:abc123..." (Docker image digest)
	// This enables support for future architectures without protocol changes
	ContainerHash string `protobuf:"bytes,4,opt,name=container_hash,json=containerHash,proto3" json:"container_hash,omitempty"`
	// container_registry is the container registry URL (e.g., "docker.io", "ghcr.io")
	ContainerRegistry string `protobuf:"bytes,5,opt,name=container_registry,json=containerRegistry,proto3" json:"container_registry,omitempty"`
	// execution_environment_id references an approved execution environment
	ExecutionEnvironmentId uint64 `protobuf:"varint,6,opt,name=execution_environment_id,json=executionEnvironmentId,proto3" json:"execution_environment_id,omitempty"`
	// encryption_type specifies encryption method
	EncryptionType EncryptionType `protobuf:"varint,7,opt,name=encryption_type,json=encryptionType,proto3,enum=remes.remes.v1.EncryptionType" json:"encryption_type,omitempty"`
	// encrypted_weights_ipfs_hash is the IPFS hash of encrypted model weights
	// Only used if encryption_type != ENCRYPTION_TYPE_PLAINTEXT
	EncryptedWeightsIpfsHash string `protobuf:"bytes,8,opt,name=encrypted_weights_ipfs_hash,json=encryptedWeightsIpfsHash,proto3" json:"encrypted_weights_ipfs_hash,omitempty"`
	// decryption_key_holder is the address authorized to decrypt (if applicable)
	// For TEE-SGX: This is the enclave address
	DecryptionKeyHolder string `protobuf:"bytes,9,opt,name=decryption_key_holder,json=decryptionKeyHolder,proto3" json:"decryption_key_holder,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ModelConfig) Reset() {
	*x = ModelConfig{}
	mi := &file_remes_remes_v1_model_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModelConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModelConfig) ProtoMessage() {}

func (x *ModelConfig) ProtoReflect() protoreflect.Message {
	mi := &file_remes_remes_v1_model_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModelConfig.ProtoReflect.Descriptor instead.
func (*ModelConfig) Descriptor() ([]byte, []int) {
	return file_remes_remes_v1_model_proto_rawDescGZIP(), []int{0}
}

func (x *ModelConfig) GetModelType() ModelType {
	if x != nil {
		return x.ModelType
	}
	return ModelType_MODEL_TYPE_UNSPECIFIED
}

func (x *ModelConfig) GetModelVersion() string {
	if x != nil {
		return x.ModelVersion
	}
	return ""
}

func (x *ModelConfig) GetArchitectureConfig() string {
	if x != nil {
		return x.ArchitectureConfig
	}
	return ""
}

func (x *ModelConfig) GetContainerHash() string {
	if x != nil {
		return x.ContainerHash
	}
	return ""
}

func (x *ModelConfig) GetContainerRegistry() string {
	if x != nil {
		return x.ContainerRegistry
	}
	return ""
}

func (x *ModelConfig) GetExecutionEnvironmentId() uint64 {
	if x != nil {
		return x.ExecutionEnvironmentId
	}
	return 0
}

func (x *ModelConfig) GetEncryptionType() EncryptionType {
	if x != nil {
		return x.EncryptionType
	}
	return EncryptionType_ENCRYPTION_TYPE_UNSPECIFIED
}

func (x *ModelConfig) GetEncryptedWeightsIpfsHash() string {
	if x != nil {
		return x.EncryptedWeightsIpfsHash
	}
	return ""
}

func (x *ModelConfig) GetDecryptionKeyHolder() string {
	if x != nil {
		return x.DecryptionKeyHolder
	}
	return ""
}

// ModelRegistry stores approved model configurations
type ModelRegistry struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// model_id is the unique identifier for this model
	ModelId uint64 `protobuf:"varint,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	// config is the model configuration
	Config *ModelConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	// approved_at_height is when this model was approved
	ApprovedAtHeight int64 `protobuf:"varint,3,opt,name=approved_at_height,json=approvedAtHeight,proto3" json:"approved_at_height,omitempty"`
	// approved_by is the governance proposal ID that approved this model
	ApprovedBy uint64 `protobuf:"varint,4,opt,name=approved_by,json=approvedBy,proto3" json:"approved_by,omitempty"`
	// is_active indicates if this model is currently active for training
	IsActive bool `protobuf:"varint,5,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	// created_at is the timestamp when this model was registered
	CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ModelRegistry) Reset() {
	*x = ModelRegistry{}
	mi := &file_remes_remes_v1_model_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModelRegistry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModelRegistry) ProtoMessage() {}

func (x *ModelRegistry) ProtoReflect() protoreflect.Message {
	mi := &file_remes_remes_v1_model_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModelRegistry.ProtoReflect.Descriptor instead.
func (*ModelRegistry) Descriptor() ([]byte, []int) {
	return file_remes_remes_v1_model_proto_rawDescGZIP(), []int{1}
}

func (x *ModelRegistry) GetModelId() uint64 {
	if x != nil {
		return x.ModelId
	}
	return 0
}

func (x *ModelRegistry) GetConfig() *ModelConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *ModelRegistry) GetApprovedAtHeight() int64 {
	if x != nil {
		return x.ApprovedAtHeight
	}
	return 0
}

func (x *ModelRegistry) GetApprovedBy() uint64 {
	if x != nil {
		return x.ApprovedBy
	}
	return 0
}

func (x *ModelRegistry) GetIsActive() bool {
	if x != nil {
		return x.IsActive
	}
	return false
}

func (x *ModelRegistry) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

var File_remes_remes_v1_model_proto protoreflect.FileDescriptor

const file_remes_remes_v1_model_proto_rawDesc = "" +
	"\n" +
	"\x1aremes/remes/v1/model.proto\x12\x0eremes.remes.v1\x1a\x11amino/amino.proto\x1a\x14gogoproto/gogo.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\x8d\x04\n" +
	"\vModelConfig\x128\n" +
	"\n" +
	"model_type\x18\x01 \x01(\x0e2\x19.remes.remes.v1.ModelTypeR\tmodelType\x12#\n" +
	"\rmodel_version\x18\x02 \x01(\tR\fmodelVersion\x12/\n" +
	"\x13architecture_config\x18\x03 \x01(\tR\x12architectureConfig\x12%\n" +
	"\x0econtainer_hash\x18\x04 \x01(\tR\rcontainerHash\x12-\n" +
	"\x12container_registry\x18\x05 \x01(\tR\x11containerRegistry\x128\n" +
	"\x18execution_environment_id\x18\x06 \x01(\x04R\x16executionEnvironmentId\x12G\n" +
	"\x0fencryption_type\x18\a \x01(\x0e2\x1e.remes.remes.v1.EncryptionTypeR\x0eencryptionType\x12=\n" +
	"\x1bencrypted_weights_ipfs_hash\x18\b \x01(\tR\x18encryptedWeightsIpfsHash\x122\n" +
	"\x15decryption_key_holder\x18\t \x01(\tR\x13decryptionKeyHolder:\"\xe8\xa0\x1f\x01\x8a\xe7\xb0*\x19remes/x/remes/ModelConfig\"\xbc\x02\n" +
	"\rModelRegistry\x12\x19\n" +
	"\bmodel_id\x18\x01 \x01(\x04R\amodelId\x129\n" +
	"\x06config\x18\x02 \x01(\v2\x1b.remes.remes.v1.ModelConfigB\x04\xc8\xde\x1f\x00R\x06config\x12,\n" +
	"\x12approved_at_height\x18\x03 \x01(\x03R\x10approvedAtHeight\x12\x1f\n" +
	"\vapproved_by\x18\x04 \x01(\x04R\n" +
	"approvedBy\x12\x1b\n" +
	"\tis_active\x18\x05 \x01(\bR\bisActive\x12C\n" +
	"\n" +
	"created_at\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampB\b\xc8\xde\x1f\x00\x90\xdf\x1f\x01R\tcreatedAt:$\xe8\xa0\x1f\x01\x8a\xe7\xb0*\x1bremes/x/remes/ModelRegistry*\x80\x01\n" +
	"\tModelType\x12\x1a\n" +
	"\x16MODEL_TYPE_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11MODEL_TYPE_BITNET\x10\x01\x12\x14\n" +
	"\x10MODEL_TYPE_MAMBA\x10\x02\x12\x13\n" +
	"\x0fMODEL_TYPE_RWKV\x10\x03\x12\x15\n" +
	"\x11MODEL_TYPE_CUSTOM\x10c*\xb2\x01\n" +
	"\x0eEncryptionType\x12\x1f\n" +
	"\x1bENCRYPTION_TYPE_UNSPECIFIED\x10\x00\x12\x1d\n" +
	"\x19ENCRYPTION_TYPE_PLAINTEXT\x10\x01\x12\x1b\n" +
	"\x17ENCRYPTION_TYPE_TEE_SGX\x10\x02\x12\x1f\n" +
	"\x1bENCRYPTION_TYPE_HOMOMORPHIC\x10\x03\x12\"\n" +
	"\x1eENCRYPTION_TYPE_ZERO_KNOWLEDGE\x10\x04B\x15Z\x13remes/x/remes/typesb\x06proto3"

var (
	file_remes_remes_v1_model_proto_rawDescOnce sync.Once
	file_remes_remes_v1_model_proto_rawDescData []byte
)

func file_remes_remes_v1_model_proto_rawDescGZIP() []byte {
	file_remes_remes_v1_model_proto_rawDescOnce.Do(func() {
		file_remes_remes_v1_model_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_remes_remes_v1_model_proto_rawDesc), len(file_remes_remes_v1_model_proto_rawDesc)))
	})
	return file_remes_remes_v1_model_proto_rawDescData
}

var file_remes_remes_v1_model_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_remes_remes_v1_model_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_remes_remes_v1_model_proto_goTypes = []any{
	(ModelType)(0),                // 0: remes.remes.v1.ModelType
	(EncryptionType)(0),           // 1: remes.remes.v1.EncryptionType
	(*ModelConfig)(nil),           // 2: remes.remes.v1.ModelConfig
	(*ModelRegistry)(nil),         // 3: remes.remes.v1.ModelRegistry
	(*timestamppb.Timestamp)(nil), // 4: google.protobuf.Timestamp
}
var file_remes_remes_v1_model_proto_depIdxs = []int32{
	0, // 0: remes.remes.v1.ModelConfig.model_type:type_name -> remes.remes.v1.ModelType
	1, // 1: remes.remes.v1.ModelConfig.encryption_type:type_name -> remes.remes.v1.EncryptionType
	2, // 2: remes.remes.v1.ModelRegistry.config:type_name -> remes.remes.v1.ModelConfig
	4, // 3: remes.remes.v1.ModelRegistry.created_at:type_name -> google.protobuf.Timestamp
	4, // [4:4] is the sub-list for method output_type
	4, // [4:4] is the sub-list for method input_type
	4, // [4:4] is the sub-list for extension type_name
	4, // [4:4] is the sub-list for extension extendee
	0, // [0:4] is the sub-list for field type_name
}

func init() { file_remes_remes_v1_model_proto_init() }
func file_remes_remes_v1_model_proto_init() {
	if File_remes_remes_v1_model_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_remes_remes_v1_model_proto_rawDesc), len(file_remes_remes_v1_model_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_remes_remes_v1_model_proto_goTypes,
		DependencyIndexes: file_remes_remes_v1_model_proto_depIdxs,
		EnumInfos:         file_remes_remes_v1_model_proto_enumTypes,
		MessageInfos:      file_remes_remes_v1_model_proto_msgTypes,
	}.Build()
	File_remes_remes_v1_model_proto = out.File
	file_remes_remes_v1_model_proto_goTypes = nil
	file_remes_remes_v1_model_proto_depIdxs = nil
}
