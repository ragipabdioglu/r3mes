// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: remes/remes/v1/state.proto

package types

import (
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// GlobalModelState represents the current global model state
type GlobalModelState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// model_ipfs_hash is the IPFS hash of the current global model
	ModelIpfsHash string `protobuf:"bytes,1,opt,name=model_ipfs_hash,json=modelIpfsHash,proto3" json:"model_ipfs_hash,omitempty"`
	// model_version is the version of the current model (e.g., "v1.0.0")
	ModelVersion string `protobuf:"bytes,2,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
	// last_updated_height is the block height when the model was last updated
	LastUpdatedHeight int64 `protobuf:"varint,3,opt,name=last_updated_height,json=lastUpdatedHeight,proto3" json:"last_updated_height,omitempty"`
	// last_updated_time is the timestamp when the model was last updated
	LastUpdatedTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=last_updated_time,json=lastUpdatedTime,proto3" json:"last_updated_time,omitempty"`
	// training_round_id is the training round ID of the current global model
	TrainingRoundId uint64 `protobuf:"varint,5,opt,name=training_round_id,json=trainingRoundId,proto3" json:"training_round_id,omitempty"`
	// last_aggregation_id is the aggregation ID that was used to create this global model
	LastAggregationId uint64 `protobuf:"varint,6,opt,name=last_aggregation_id,json=lastAggregationId,proto3" json:"last_aggregation_id,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GlobalModelState) Reset() {
	*x = GlobalModelState{}
	mi := &file_remes_remes_v1_state_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GlobalModelState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GlobalModelState) ProtoMessage() {}

func (x *GlobalModelState) ProtoReflect() protoreflect.Message {
	mi := &file_remes_remes_v1_state_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GlobalModelState.ProtoReflect.Descriptor instead.
func (*GlobalModelState) Descriptor() ([]byte, []int) {
	return file_remes_remes_v1_state_proto_rawDescGZIP(), []int{0}
}

func (x *GlobalModelState) GetModelIpfsHash() string {
	if x != nil {
		return x.ModelIpfsHash
	}
	return ""
}

func (x *GlobalModelState) GetModelVersion() string {
	if x != nil {
		return x.ModelVersion
	}
	return ""
}

func (x *GlobalModelState) GetLastUpdatedHeight() int64 {
	if x != nil {
		return x.LastUpdatedHeight
	}
	return 0
}

func (x *GlobalModelState) GetLastUpdatedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastUpdatedTime
	}
	return nil
}

func (x *GlobalModelState) GetTrainingRoundId() uint64 {
	if x != nil {
		return x.TrainingRoundId
	}
	return 0
}

func (x *GlobalModelState) GetLastAggregationId() uint64 {
	if x != nil {
		return x.LastAggregationId
	}
	return 0
}

// AggregationRecord represents an aggregation record stored on-chain
type AggregationRecord struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// aggregation_id is the unique identifier for this aggregation
	AggregationId uint64 `protobuf:"varint,1,opt,name=aggregation_id,json=aggregationId,proto3" json:"aggregation_id,omitempty"`
	// proposer is the address of the proposer who performed aggregation
	Proposer string `protobuf:"bytes,2,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// aggregated_gradient_ipfs_hash is the IPFS hash of the aggregated gradient result
	AggregatedGradientIpfsHash string `protobuf:"bytes,3,opt,name=aggregated_gradient_ipfs_hash,json=aggregatedGradientIpfsHash,proto3" json:"aggregated_gradient_ipfs_hash,omitempty"`
	// merkle_root is the Merkle root hash of all included gradients
	MerkleRoot string `protobuf:"bytes,4,opt,name=merkle_root,json=merkleRoot,proto3" json:"merkle_root,omitempty"`
	// participant_gradient_ids are the IDs of all gradients included in aggregation
	ParticipantGradientIds []uint64 `protobuf:"varint,5,rep,packed,name=participant_gradient_ids,json=participantGradientIds,proto3" json:"participant_gradient_ids,omitempty"`
	// training_round_id is the identifier for the training round
	TrainingRoundId uint64 `protobuf:"varint,6,opt,name=training_round_id,json=trainingRoundId,proto3" json:"training_round_id,omitempty"`
	// model_version is the version of the model used
	ModelVersion string `protobuf:"bytes,7,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
	// submitted_at_height is the block height when this aggregation was submitted
	SubmittedAtHeight int64 `protobuf:"varint,8,opt,name=submitted_at_height,json=submittedAtHeight,proto3" json:"submitted_at_height,omitempty"`
	// status is the current status (pending, finalized, challenged)
	Status string `protobuf:"bytes,9,opt,name=status,proto3" json:"status,omitempty"`
	// challenge_deadline_height is the block height when challenge period ends (submitted_at_height + challenge_period_blocks)
	ChallengeDeadlineHeight int64 `protobuf:"varint,10,opt,name=challenge_deadline_height,json=challengeDeadlineHeight,proto3" json:"challenge_deadline_height,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *AggregationRecord) Reset() {
	*x = AggregationRecord{}
	mi := &file_remes_remes_v1_state_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AggregationRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AggregationRecord) ProtoMessage() {}

func (x *AggregationRecord) ProtoReflect() protoreflect.Message {
	mi := &file_remes_remes_v1_state_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AggregationRecord.ProtoReflect.Descriptor instead.
func (*AggregationRecord) Descriptor() ([]byte, []int) {
	return file_remes_remes_v1_state_proto_rawDescGZIP(), []int{1}
}

func (x *AggregationRecord) GetAggregationId() uint64 {
	if x != nil {
		return x.AggregationId
	}
	return 0
}

func (x *AggregationRecord) GetProposer() string {
	if x != nil {
		return x.Proposer
	}
	return ""
}

func (x *AggregationRecord) GetAggregatedGradientIpfsHash() string {
	if x != nil {
		return x.AggregatedGradientIpfsHash
	}
	return ""
}

func (x *AggregationRecord) GetMerkleRoot() string {
	if x != nil {
		return x.MerkleRoot
	}
	return ""
}

func (x *AggregationRecord) GetParticipantGradientIds() []uint64 {
	if x != nil {
		return x.ParticipantGradientIds
	}
	return nil
}

func (x *AggregationRecord) GetTrainingRoundId() uint64 {
	if x != nil {
		return x.TrainingRoundId
	}
	return 0
}

func (x *AggregationRecord) GetModelVersion() string {
	if x != nil {
		return x.ModelVersion
	}
	return ""
}

func (x *AggregationRecord) GetSubmittedAtHeight() int64 {
	if x != nil {
		return x.SubmittedAtHeight
	}
	return 0
}

func (x *AggregationRecord) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *AggregationRecord) GetChallengeDeadlineHeight() int64 {
	if x != nil {
		return x.ChallengeDeadlineHeight
	}
	return 0
}

// AggregationCommitment represents a commitment to an aggregation result (commit-reveal scheme)
type AggregationCommitment struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// commitment_id is the unique identifier for this commitment
	CommitmentId uint64 `protobuf:"varint,1,opt,name=commitment_id,json=commitmentId,proto3" json:"commitment_id,omitempty"`
	// proposer is the address of the proposer who made the commitment
	Proposer string `protobuf:"bytes,2,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// commitment_hash is the hash of (aggregated_hash + merkle_root + participant_ids + salt)
	CommitmentHash string `protobuf:"bytes,3,opt,name=commitment_hash,json=commitmentHash,proto3" json:"commitment_hash,omitempty"`
	// training_round_id is the identifier for the training round
	TrainingRoundId uint64 `protobuf:"varint,4,opt,name=training_round_id,json=trainingRoundId,proto3" json:"training_round_id,omitempty"`
	// participant_gradient_ids are the IDs of all gradients included in aggregation
	ParticipantGradientIds []uint64 `protobuf:"varint,5,rep,packed,name=participant_gradient_ids,json=participantGradientIds,proto3" json:"participant_gradient_ids,omitempty"`
	// committed_at_height is the block height when this commitment was made
	CommittedAtHeight int64 `protobuf:"varint,6,opt,name=committed_at_height,json=committedAtHeight,proto3" json:"committed_at_height,omitempty"`
	// reveal_deadline_height is the block height when reveal period starts
	RevealDeadlineHeight int64 `protobuf:"varint,7,opt,name=reveal_deadline_height,json=revealDeadlineHeight,proto3" json:"reveal_deadline_height,omitempty"`
	// status is the current status (committed, revealed, expired)
	Status string `protobuf:"bytes,8,opt,name=status,proto3" json:"status,omitempty"`
	// revealed_aggregation_id is the aggregation ID created after reveal (if revealed)
	RevealedAggregationId uint64 `protobuf:"varint,9,opt,name=revealed_aggregation_id,json=revealedAggregationId,proto3" json:"revealed_aggregation_id,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *AggregationCommitment) Reset() {
	*x = AggregationCommitment{}
	mi := &file_remes_remes_v1_state_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AggregationCommitment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AggregationCommitment) ProtoMessage() {}

func (x *AggregationCommitment) ProtoReflect() protoreflect.Message {
	mi := &file_remes_remes_v1_state_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AggregationCommitment.ProtoReflect.Descriptor instead.
func (*AggregationCommitment) Descriptor() ([]byte, []int) {
	return file_remes_remes_v1_state_proto_rawDescGZIP(), []int{2}
}

func (x *AggregationCommitment) GetCommitmentId() uint64 {
	if x != nil {
		return x.CommitmentId
	}
	return 0
}

func (x *AggregationCommitment) GetProposer() string {
	if x != nil {
		return x.Proposer
	}
	return ""
}

func (x *AggregationCommitment) GetCommitmentHash() string {
	if x != nil {
		return x.CommitmentHash
	}
	return ""
}

func (x *AggregationCommitment) GetTrainingRoundId() uint64 {
	if x != nil {
		return x.TrainingRoundId
	}
	return 0
}

func (x *AggregationCommitment) GetParticipantGradientIds() []uint64 {
	if x != nil {
		return x.ParticipantGradientIds
	}
	return nil
}

func (x *AggregationCommitment) GetCommittedAtHeight() int64 {
	if x != nil {
		return x.CommittedAtHeight
	}
	return 0
}

func (x *AggregationCommitment) GetRevealDeadlineHeight() int64 {
	if x != nil {
		return x.RevealDeadlineHeight
	}
	return 0
}

func (x *AggregationCommitment) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *AggregationCommitment) GetRevealedAggregationId() uint64 {
	if x != nil {
		return x.RevealedAggregationId
	}
	return 0
}

// MiningContribution represents a miner's contribution to the network
type MiningContribution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// miner_address is the address of the miner
	MinerAddress string `protobuf:"bytes,1,opt,name=miner_address,json=minerAddress,proto3" json:"miner_address,omitempty"`
	// total_submissions is the total number of gradient submissions
	TotalSubmissions uint64 `protobuf:"varint,2,opt,name=total_submissions,json=totalSubmissions,proto3" json:"total_submissions,omitempty"`
	// successful_submissions is the number of successful submissions
	SuccessfulSubmissions uint64 `protobuf:"varint,3,opt,name=successful_submissions,json=successfulSubmissions,proto3" json:"successful_submissions,omitempty"`
	// trust_score is the reputation score (0.0 to 1.0)
	TrustScore string `protobuf:"bytes,4,opt,name=trust_score,json=trustScore,proto3" json:"trust_score,omitempty"`
	// reputation_tier is the tier (excellent, trusted, developing, new)
	ReputationTier string `protobuf:"bytes,5,opt,name=reputation_tier,json=reputationTier,proto3" json:"reputation_tier,omitempty"`
	// slashing_events is the number of slashing events
	SlashingEvents uint64 `protobuf:"varint,6,opt,name=slashing_events,json=slashingEvents,proto3" json:"slashing_events,omitempty"`
	// last_submission_height is the block height of the last submission
	LastSubmissionHeight int64 `protobuf:"varint,7,opt,name=last_submission_height,json=lastSubmissionHeight,proto3" json:"last_submission_height,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *MiningContribution) Reset() {
	*x = MiningContribution{}
	mi := &file_remes_remes_v1_state_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MiningContribution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MiningContribution) ProtoMessage() {}

func (x *MiningContribution) ProtoReflect() protoreflect.Message {
	mi := &file_remes_remes_v1_state_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MiningContribution.ProtoReflect.Descriptor instead.
func (*MiningContribution) Descriptor() ([]byte, []int) {
	return file_remes_remes_v1_state_proto_rawDescGZIP(), []int{3}
}

func (x *MiningContribution) GetMinerAddress() string {
	if x != nil {
		return x.MinerAddress
	}
	return ""
}

func (x *MiningContribution) GetTotalSubmissions() uint64 {
	if x != nil {
		return x.TotalSubmissions
	}
	return 0
}

func (x *MiningContribution) GetSuccessfulSubmissions() uint64 {
	if x != nil {
		return x.SuccessfulSubmissions
	}
	return 0
}

func (x *MiningContribution) GetTrustScore() string {
	if x != nil {
		return x.TrustScore
	}
	return ""
}

func (x *MiningContribution) GetReputationTier() string {
	if x != nil {
		return x.ReputationTier
	}
	return ""
}

func (x *MiningContribution) GetSlashingEvents() uint64 {
	if x != nil {
		return x.SlashingEvents
	}
	return 0
}

func (x *MiningContribution) GetLastSubmissionHeight() int64 {
	if x != nil {
		return x.LastSubmissionHeight
	}
	return 0
}

// ChallengeRecord represents a challenge to an aggregation
type ChallengeRecord struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// challenge_id is the unique identifier for this challenge
	ChallengeId uint64 `protobuf:"varint,1,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id,omitempty"`
	// challenger is the address of the node challenging the aggregation
	Challenger string `protobuf:"bytes,2,opt,name=challenger,proto3" json:"challenger,omitempty"`
	// aggregation_id is the ID of the aggregation being challenged
	AggregationId uint64 `protobuf:"varint,3,opt,name=aggregation_id,json=aggregationId,proto3" json:"aggregation_id,omitempty"`
	// reason is the reason for the challenge
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	// evidence_ipfs_hash is the IPFS hash of evidence supporting the challenge
	EvidenceIpfsHash string `protobuf:"bytes,5,opt,name=evidence_ipfs_hash,json=evidenceIpfsHash,proto3" json:"evidence_ipfs_hash,omitempty"`
	// status is the current status (pending, resolved, rejected)
	Status string `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
	// created_at_height is the block height when this challenge was created
	CreatedAtHeight int64 `protobuf:"varint,7,opt,name=created_at_height,json=createdAtHeight,proto3" json:"created_at_height,omitempty"`
	// cpu_verification_panel is the list of validator addresses selected for CPU verification
	CpuVerificationPanel []string `protobuf:"bytes,8,rep,name=cpu_verification_panel,json=cpuVerificationPanel,proto3" json:"cpu_verification_panel,omitempty"`
	// cpu_verification_results stores verification results from panel validators
	CpuVerificationResults []*CPUVerificationResult `protobuf:"bytes,9,rep,name=cpu_verification_results,json=cpuVerificationResults,proto3" json:"cpu_verification_results,omitempty"`
	// resolution_height is the block height when challenge was resolved
	ResolutionHeight int64 `protobuf:"varint,10,opt,name=resolution_height,json=resolutionHeight,proto3" json:"resolution_height,omitempty"`
	// fraud_detected indicates if fraud was detected
	FraudDetected bool `protobuf:"varint,11,opt,name=fraud_detected,json=fraudDetected,proto3" json:"fraud_detected,omitempty"`
	// layer indicates the verification layer (1=GPU-to-GPU, 2=High-Stakes Challenge, 3=CPU Iron Sandbox)
	Layer uint32 `protobuf:"varint,12,opt,name=layer,proto3" json:"layer,omitempty"`
	// bond_amount is the bond amount required for Layer 2 challenge (10x base reward)
	BondAmount string `protobuf:"bytes,13,opt,name=bond_amount,json=bondAmount,proto3" json:"bond_amount,omitempty"` // sdk.Coin format
	// random_verifier is the randomly selected GPU verifier for Layer 2
	RandomVerifier string `protobuf:"bytes,14,opt,name=random_verifier,json=randomVerifier,proto3" json:"random_verifier,omitempty"`
	// random_verifier_result is the result from random verifier ("valid", "invalid", "pending")
	RandomVerifierResult string `protobuf:"bytes,15,opt,name=random_verifier_result,json=randomVerifierResult,proto3" json:"random_verifier_result,omitempty"`
	// miner_weights_ipfs is the IPFS hash of miner's model weights (for Loss-Based Spot Checking)
	MinerWeightsIpfs string `protobuf:"bytes,16,opt,name=miner_weights_ipfs,json=minerWeightsIpfs,proto3" json:"miner_weights_ipfs,omitempty"`
	// data_batch_seed is the VRF seed for deterministic batch selection (for Loss-Based Spot Checking)
	DataBatchSeed uint64 `protobuf:"varint,17,opt,name=data_batch_seed,json=dataBatchSeed,proto3" json:"data_batch_seed,omitempty"`
	// verifier_loss is the loss calculated by the random verifier (BitNet integer format)
	VerifierLoss string `protobuf:"bytes,18,opt,name=verifier_loss,json=verifierLoss,proto3" json:"verifier_loss,omitempty"`
	// loss_match indicates if miner's claimed loss matches verifier's calculated loss (within tolerance)
	LossMatch bool `protobuf:"varint,19,opt,name=loss_match,json=lossMatch,proto3" json:"loss_match,omitempty"`
	// loss_tolerance is the tolerance used for loss comparison (BitNet integer format, default: Â±1)
	LossTolerance string `protobuf:"bytes,20,opt,name=loss_tolerance,json=lossTolerance,proto3" json:"loss_tolerance,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChallengeRecord) Reset() {
	*x = ChallengeRecord{}
	mi := &file_remes_remes_v1_state_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChallengeRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChallengeRecord) ProtoMessage() {}

func (x *ChallengeRecord) ProtoReflect() protoreflect.Message {
	mi := &file_remes_remes_v1_state_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChallengeRecord.ProtoReflect.Descriptor instead.
func (*ChallengeRecord) Descriptor() ([]byte, []int) {
	return file_remes_remes_v1_state_proto_rawDescGZIP(), []int{4}
}

func (x *ChallengeRecord) GetChallengeId() uint64 {
	if x != nil {
		return x.ChallengeId
	}
	return 0
}

func (x *ChallengeRecord) GetChallenger() string {
	if x != nil {
		return x.Challenger
	}
	return ""
}

func (x *ChallengeRecord) GetAggregationId() uint64 {
	if x != nil {
		return x.AggregationId
	}
	return 0
}

func (x *ChallengeRecord) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *ChallengeRecord) GetEvidenceIpfsHash() string {
	if x != nil {
		return x.EvidenceIpfsHash
	}
	return ""
}

func (x *ChallengeRecord) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *ChallengeRecord) GetCreatedAtHeight() int64 {
	if x != nil {
		return x.CreatedAtHeight
	}
	return 0
}

func (x *ChallengeRecord) GetCpuVerificationPanel() []string {
	if x != nil {
		return x.CpuVerificationPanel
	}
	return nil
}

func (x *ChallengeRecord) GetCpuVerificationResults() []*CPUVerificationResult {
	if x != nil {
		return x.CpuVerificationResults
	}
	return nil
}

func (x *ChallengeRecord) GetResolutionHeight() int64 {
	if x != nil {
		return x.ResolutionHeight
	}
	return 0
}

func (x *ChallengeRecord) GetFraudDetected() bool {
	if x != nil {
		return x.FraudDetected
	}
	return false
}

func (x *ChallengeRecord) GetLayer() uint32 {
	if x != nil {
		return x.Layer
	}
	return 0
}

func (x *ChallengeRecord) GetBondAmount() string {
	if x != nil {
		return x.BondAmount
	}
	return ""
}

func (x *ChallengeRecord) GetRandomVerifier() string {
	if x != nil {
		return x.RandomVerifier
	}
	return ""
}

func (x *ChallengeRecord) GetRandomVerifierResult() string {
	if x != nil {
		return x.RandomVerifierResult
	}
	return ""
}

func (x *ChallengeRecord) GetMinerWeightsIpfs() string {
	if x != nil {
		return x.MinerWeightsIpfs
	}
	return ""
}

func (x *ChallengeRecord) GetDataBatchSeed() uint64 {
	if x != nil {
		return x.DataBatchSeed
	}
	return 0
}

func (x *ChallengeRecord) GetVerifierLoss() string {
	if x != nil {
		return x.VerifierLoss
	}
	return ""
}

func (x *ChallengeRecord) GetLossMatch() bool {
	if x != nil {
		return x.LossMatch
	}
	return false
}

func (x *ChallengeRecord) GetLossTolerance() string {
	if x != nil {
		return x.LossTolerance
	}
	return ""
}

// CPUVerificationResult represents a CPU verification result from a validator
type CPUVerificationResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// validator_address is the address of the validator
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	// is_valid indicates if the gradient is valid
	IsValid bool `protobuf:"varint,2,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`
	// computed_hash is the hash computed by the validator
	ComputedHash string `protobuf:"bytes,3,opt,name=computed_hash,json=computedHash,proto3" json:"computed_hash,omitempty"`
	// expected_hash is the expected hash from the aggregation
	ExpectedHash string `protobuf:"bytes,4,opt,name=expected_hash,json=expectedHash,proto3" json:"expected_hash,omitempty"`
	// verification_time is when the verification was performed
	VerificationTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=verification_time,json=verificationTime,proto3" json:"verification_time,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *CPUVerificationResult) Reset() {
	*x = CPUVerificationResult{}
	mi := &file_remes_remes_v1_state_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CPUVerificationResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CPUVerificationResult) ProtoMessage() {}

func (x *CPUVerificationResult) ProtoReflect() protoreflect.Message {
	mi := &file_remes_remes_v1_state_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CPUVerificationResult.ProtoReflect.Descriptor instead.
func (*CPUVerificationResult) Descriptor() ([]byte, []int) {
	return file_remes_remes_v1_state_proto_rawDescGZIP(), []int{5}
}

func (x *CPUVerificationResult) GetValidatorAddress() string {
	if x != nil {
		return x.ValidatorAddress
	}
	return ""
}

func (x *CPUVerificationResult) GetIsValid() bool {
	if x != nil {
		return x.IsValid
	}
	return false
}

func (x *CPUVerificationResult) GetComputedHash() string {
	if x != nil {
		return x.ComputedHash
	}
	return ""
}

func (x *CPUVerificationResult) GetExpectedHash() string {
	if x != nil {
		return x.ExpectedHash
	}
	return ""
}

func (x *CPUVerificationResult) GetVerificationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.VerificationTime
	}
	return nil
}

// ParticipantSyncState represents a participant's synchronization state
type ParticipantSyncState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// participant_address is the address of the participant (miner or node)
	ParticipantAddress string `protobuf:"bytes,1,opt,name=participant_address,json=participantAddress,proto3" json:"participant_address,omitempty"`
	// current_model_version is the model version the participant is currently using
	CurrentModelVersion string `protobuf:"bytes,2,opt,name=current_model_version,json=currentModelVersion,proto3" json:"current_model_version,omitempty"`
	// last_sync_height is the block height when the participant last synced
	LastSyncHeight int64 `protobuf:"varint,3,opt,name=last_sync_height,json=lastSyncHeight,proto3" json:"last_sync_height,omitempty"`
	// last_sync_time is the timestamp when the participant last synced
	LastSyncTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=last_sync_time,json=lastSyncTime,proto3" json:"last_sync_time,omitempty"`
	// is_synced indicates if the participant is synced with the latest model version
	IsSynced bool `protobuf:"varint,5,opt,name=is_synced,json=isSynced,proto3" json:"is_synced,omitempty"`
	// sync_lag_blocks is the number of blocks behind the participant is
	SyncLagBlocks int64 `protobuf:"varint,6,opt,name=sync_lag_blocks,json=syncLagBlocks,proto3" json:"sync_lag_blocks,omitempty"`
	// participant_type is the type of participant (miner, validator, serving_node)
	ParticipantType string `protobuf:"bytes,7,opt,name=participant_type,json=participantType,proto3" json:"participant_type,omitempty"`
	// is_partitioned indicates if the participant is currently partitioned
	IsPartitioned bool `protobuf:"varint,8,opt,name=is_partitioned,json=isPartitioned,proto3" json:"is_partitioned,omitempty"`
	// partition_detected_at is the block height when partition was detected
	PartitionDetectedAt int64 `protobuf:"varint,9,opt,name=partition_detected_at,json=partitionDetectedAt,proto3" json:"partition_detected_at,omitempty"`
	// partition_detected_time is the timestamp when partition was detected
	PartitionDetectedTime *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=partition_detected_time,json=partitionDetectedTime,proto3" json:"partition_detected_time,omitempty"`
	// partition_recovered_at is the block height when partition was recovered
	PartitionRecoveredAt int64 `protobuf:"varint,11,opt,name=partition_recovered_at,json=partitionRecoveredAt,proto3" json:"partition_recovered_at,omitempty"`
	// partition_recovered_time is the timestamp when partition was recovered
	PartitionRecoveredTime *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=partition_recovered_time,json=partitionRecoveredTime,proto3" json:"partition_recovered_time,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *ParticipantSyncState) Reset() {
	*x = ParticipantSyncState{}
	mi := &file_remes_remes_v1_state_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ParticipantSyncState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ParticipantSyncState) ProtoMessage() {}

func (x *ParticipantSyncState) ProtoReflect() protoreflect.Message {
	mi := &file_remes_remes_v1_state_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ParticipantSyncState.ProtoReflect.Descriptor instead.
func (*ParticipantSyncState) Descriptor() ([]byte, []int) {
	return file_remes_remes_v1_state_proto_rawDescGZIP(), []int{6}
}

func (x *ParticipantSyncState) GetParticipantAddress() string {
	if x != nil {
		return x.ParticipantAddress
	}
	return ""
}

func (x *ParticipantSyncState) GetCurrentModelVersion() string {
	if x != nil {
		return x.CurrentModelVersion
	}
	return ""
}

func (x *ParticipantSyncState) GetLastSyncHeight() int64 {
	if x != nil {
		return x.LastSyncHeight
	}
	return 0
}

func (x *ParticipantSyncState) GetLastSyncTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastSyncTime
	}
	return nil
}

func (x *ParticipantSyncState) GetIsSynced() bool {
	if x != nil {
		return x.IsSynced
	}
	return false
}

func (x *ParticipantSyncState) GetSyncLagBlocks() int64 {
	if x != nil {
		return x.SyncLagBlocks
	}
	return 0
}

func (x *ParticipantSyncState) GetParticipantType() string {
	if x != nil {
		return x.ParticipantType
	}
	return ""
}

func (x *ParticipantSyncState) GetIsPartitioned() bool {
	if x != nil {
		return x.IsPartitioned
	}
	return false
}

func (x *ParticipantSyncState) GetPartitionDetectedAt() int64 {
	if x != nil {
		return x.PartitionDetectedAt
	}
	return 0
}

func (x *ParticipantSyncState) GetPartitionDetectedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.PartitionDetectedTime
	}
	return nil
}

func (x *ParticipantSyncState) GetPartitionRecoveredAt() int64 {
	if x != nil {
		return x.PartitionRecoveredAt
	}
	return 0
}

func (x *ParticipantSyncState) GetPartitionRecoveredTime() *timestamppb.Timestamp {
	if x != nil {
		return x.PartitionRecoveredTime
	}
	return nil
}

// PartitionRecoveryInfo contains information for partition recovery
type PartitionRecoveryInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// participant_address is the address of the participant
	ParticipantAddress string `protobuf:"bytes,1,opt,name=participant_address,json=participantAddress,proto3" json:"participant_address,omitempty"`
	// was_partitioned indicates if the participant was partitioned
	WasPartitioned bool `protobuf:"varint,2,opt,name=was_partitioned,json=wasPartitioned,proto3" json:"was_partitioned,omitempty"`
	// partition_duration is the duration of the partition in blocks
	PartitionDuration int64 `protobuf:"varint,3,opt,name=partition_duration,json=partitionDuration,proto3" json:"partition_duration,omitempty"`
	// recovery_type is the type of recovery (incremental, full_catchup)
	RecoveryType string `protobuf:"bytes,4,opt,name=recovery_type,json=recoveryType,proto3" json:"recovery_type,omitempty"`
	// requires_full_sync indicates if full sync is required
	RequiresFullSync bool `protobuf:"varint,5,opt,name=requires_full_sync,json=requiresFullSync,proto3" json:"requires_full_sync,omitempty"`
	// sync_lag_blocks is the number of blocks behind
	SyncLagBlocks int64 `protobuf:"varint,6,opt,name=sync_lag_blocks,json=syncLagBlocks,proto3" json:"sync_lag_blocks,omitempty"`
	// global_state is the current global model state (if incremental recovery)
	GlobalState *GlobalModelState `protobuf:"bytes,7,opt,name=global_state,json=globalState,proto3" json:"global_state,omitempty"`
	// catch_up_gradients are the gradients needed for catch-up (if incremental recovery)
	CatchUpGradients []*StoredGradient `protobuf:"bytes,8,rep,name=catch_up_gradients,json=catchUpGradients,proto3" json:"catch_up_gradients,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PartitionRecoveryInfo) Reset() {
	*x = PartitionRecoveryInfo{}
	mi := &file_remes_remes_v1_state_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartitionRecoveryInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartitionRecoveryInfo) ProtoMessage() {}

func (x *PartitionRecoveryInfo) ProtoReflect() protoreflect.Message {
	mi := &file_remes_remes_v1_state_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartitionRecoveryInfo.ProtoReflect.Descriptor instead.
func (*PartitionRecoveryInfo) Descriptor() ([]byte, []int) {
	return file_remes_remes_v1_state_proto_rawDescGZIP(), []int{7}
}

func (x *PartitionRecoveryInfo) GetParticipantAddress() string {
	if x != nil {
		return x.ParticipantAddress
	}
	return ""
}

func (x *PartitionRecoveryInfo) GetWasPartitioned() bool {
	if x != nil {
		return x.WasPartitioned
	}
	return false
}

func (x *PartitionRecoveryInfo) GetPartitionDuration() int64 {
	if x != nil {
		return x.PartitionDuration
	}
	return 0
}

func (x *PartitionRecoveryInfo) GetRecoveryType() string {
	if x != nil {
		return x.RecoveryType
	}
	return ""
}

func (x *PartitionRecoveryInfo) GetRequiresFullSync() bool {
	if x != nil {
		return x.RequiresFullSync
	}
	return false
}

func (x *PartitionRecoveryInfo) GetSyncLagBlocks() int64 {
	if x != nil {
		return x.SyncLagBlocks
	}
	return 0
}

func (x *PartitionRecoveryInfo) GetGlobalState() *GlobalModelState {
	if x != nil {
		return x.GlobalState
	}
	return nil
}

func (x *PartitionRecoveryInfo) GetCatchUpGradients() []*StoredGradient {
	if x != nil {
		return x.CatchUpGradients
	}
	return nil
}

// ProofOfReplication represents a cryptographic proof that a miner stores actual data
type ProofOfReplication struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// data_hash is the hash of the original gradient data
	DataHash string `protobuf:"bytes,1,opt,name=data_hash,json=dataHash,proto3" json:"data_hash,omitempty"`
	// replica_hash is the hash of the stored replica (miner-specific encoding)
	ReplicaHash string `protobuf:"bytes,2,opt,name=replica_hash,json=replicaHash,proto3" json:"replica_hash,omitempty"`
	// merkle_proof is the Merkle proof of inclusion (serialized)
	MerkleProof []byte `protobuf:"bytes,3,opt,name=merkle_proof,json=merkleProof,proto3" json:"merkle_proof,omitempty"`
	// storage_proof is the proof that data is stored (serialized)
	StorageProof []byte `protobuf:"bytes,4,opt,name=storage_proof,json=storageProof,proto3" json:"storage_proof,omitempty"`
	// replication_id is the unique replication identifier
	ReplicationId string `protobuf:"bytes,5,opt,name=replication_id,json=replicationId,proto3" json:"replication_id,omitempty"`
	// miner_address is the address of the miner storing the replica
	MinerAddress string `protobuf:"bytes,6,opt,name=miner_address,json=minerAddress,proto3" json:"miner_address,omitempty"`
	// timestamp is when replication occurred (Unix timestamp)
	Timestamp     int64 `protobuf:"varint,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProofOfReplication) Reset() {
	*x = ProofOfReplication{}
	mi := &file_remes_remes_v1_state_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProofOfReplication) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProofOfReplication) ProtoMessage() {}

func (x *ProofOfReplication) ProtoReflect() protoreflect.Message {
	mi := &file_remes_remes_v1_state_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProofOfReplication.ProtoReflect.Descriptor instead.
func (*ProofOfReplication) Descriptor() ([]byte, []int) {
	return file_remes_remes_v1_state_proto_rawDescGZIP(), []int{8}
}

func (x *ProofOfReplication) GetDataHash() string {
	if x != nil {
		return x.DataHash
	}
	return ""
}

func (x *ProofOfReplication) GetReplicaHash() string {
	if x != nil {
		return x.ReplicaHash
	}
	return ""
}

func (x *ProofOfReplication) GetMerkleProof() []byte {
	if x != nil {
		return x.MerkleProof
	}
	return nil
}

func (x *ProofOfReplication) GetStorageProof() []byte {
	if x != nil {
		return x.StorageProof
	}
	return nil
}

func (x *ProofOfReplication) GetReplicationId() string {
	if x != nil {
		return x.ReplicationId
	}
	return ""
}

func (x *ProofOfReplication) GetMinerAddress() string {
	if x != nil {
		return x.MinerAddress
	}
	return ""
}

func (x *ProofOfReplication) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// PartitionStatus represents the partition status of a participant
type PartitionStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// is_partitioned indicates if the participant is currently partitioned
	IsPartitioned bool `protobuf:"varint,1,opt,name=is_partitioned,json=isPartitioned,proto3" json:"is_partitioned,omitempty"`
	// sync_lag_blocks is the number of blocks behind
	SyncLagBlocks int64 `protobuf:"varint,2,opt,name=sync_lag_blocks,json=syncLagBlocks,proto3" json:"sync_lag_blocks,omitempty"`
	// time_since_last_sync is the time since last sync
	TimeSinceLastSync string `protobuf:"bytes,3,opt,name=time_since_last_sync,json=timeSinceLastSync,proto3" json:"time_since_last_sync,omitempty"`
	// last_sync_height is the block height of last sync
	LastSyncHeight int64 `protobuf:"varint,4,opt,name=last_sync_height,json=lastSyncHeight,proto3" json:"last_sync_height,omitempty"`
	// last_sync_time is the timestamp of last sync
	LastSyncTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=last_sync_time,json=lastSyncTime,proto3" json:"last_sync_time,omitempty"`
	// partition_detected_at is the block height when partition was detected
	PartitionDetectedAt int64 `protobuf:"varint,6,opt,name=partition_detected_at,json=partitionDetectedAt,proto3" json:"partition_detected_at,omitempty"`
	// partition_recovered_at is the block height when partition was recovered
	PartitionRecoveredAt int64 `protobuf:"varint,7,opt,name=partition_recovered_at,json=partitionRecoveredAt,proto3" json:"partition_recovered_at,omitempty"`
	// partition_duration is the duration of the partition in blocks
	PartitionDuration int64 `protobuf:"varint,8,opt,name=partition_duration,json=partitionDuration,proto3" json:"partition_duration,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *PartitionStatus) Reset() {
	*x = PartitionStatus{}
	mi := &file_remes_remes_v1_state_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartitionStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartitionStatus) ProtoMessage() {}

func (x *PartitionStatus) ProtoReflect() protoreflect.Message {
	mi := &file_remes_remes_v1_state_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartitionStatus.ProtoReflect.Descriptor instead.
func (*PartitionStatus) Descriptor() ([]byte, []int) {
	return file_remes_remes_v1_state_proto_rawDescGZIP(), []int{9}
}

func (x *PartitionStatus) GetIsPartitioned() bool {
	if x != nil {
		return x.IsPartitioned
	}
	return false
}

func (x *PartitionStatus) GetSyncLagBlocks() int64 {
	if x != nil {
		return x.SyncLagBlocks
	}
	return 0
}

func (x *PartitionStatus) GetTimeSinceLastSync() string {
	if x != nil {
		return x.TimeSinceLastSync
	}
	return ""
}

func (x *PartitionStatus) GetLastSyncHeight() int64 {
	if x != nil {
		return x.LastSyncHeight
	}
	return 0
}

func (x *PartitionStatus) GetLastSyncTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastSyncTime
	}
	return nil
}

func (x *PartitionStatus) GetPartitionDetectedAt() int64 {
	if x != nil {
		return x.PartitionDetectedAt
	}
	return 0
}

func (x *PartitionStatus) GetPartitionRecoveredAt() int64 {
	if x != nil {
		return x.PartitionRecoveredAt
	}
	return 0
}

func (x *PartitionStatus) GetPartitionDuration() int64 {
	if x != nil {
		return x.PartitionDuration
	}
	return 0
}

var File_remes_remes_v1_state_proto protoreflect.FileDescriptor

const file_remes_remes_v1_state_proto_rawDesc = "" +
	"\n" +
	"\x1aremes/remes/v1/state.proto\x12\x0eremes.remes.v1\x1a\x11amino/amino.proto\x1a\x14gogoproto/gogo.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a$remes/remes/v1/stored_gradient.proto\"\xe6\x02\n" +
	"\x10GlobalModelState\x12&\n" +
	"\x0fmodel_ipfs_hash\x18\x01 \x01(\tR\rmodelIpfsHash\x12#\n" +
	"\rmodel_version\x18\x02 \x01(\tR\fmodelVersion\x12.\n" +
	"\x13last_updated_height\x18\x03 \x01(\x03R\x11lastUpdatedHeight\x12P\n" +
	"\x11last_updated_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampB\b\xc8\xde\x1f\x00\x90\xdf\x1f\x01R\x0flastUpdatedTime\x12*\n" +
	"\x11training_round_id\x18\x05 \x01(\x04R\x0ftrainingRoundId\x12.\n" +
	"\x13last_aggregation_id\x18\x06 \x01(\x04R\x11lastAggregationId:'\xe8\xa0\x1f\x01\x8a\xe7\xb0*\x1eremes/x/remes/GlobalModelState\"\xf3\x03\n" +
	"\x11AggregationRecord\x12%\n" +
	"\x0eaggregation_id\x18\x01 \x01(\x04R\raggregationId\x12\x1a\n" +
	"\bproposer\x18\x02 \x01(\tR\bproposer\x12A\n" +
	"\x1daggregated_gradient_ipfs_hash\x18\x03 \x01(\tR\x1aaggregatedGradientIpfsHash\x12\x1f\n" +
	"\vmerkle_root\x18\x04 \x01(\tR\n" +
	"merkleRoot\x128\n" +
	"\x18participant_gradient_ids\x18\x05 \x03(\x04R\x16participantGradientIds\x12*\n" +
	"\x11training_round_id\x18\x06 \x01(\x04R\x0ftrainingRoundId\x12#\n" +
	"\rmodel_version\x18\a \x01(\tR\fmodelVersion\x12.\n" +
	"\x13submitted_at_height\x18\b \x01(\x03R\x11submittedAtHeight\x12\x16\n" +
	"\x06status\x18\t \x01(\tR\x06status\x12:\n" +
	"\x19challenge_deadline_height\x18\n" +
	" \x01(\x03R\x17challengeDeadlineHeight:(\xe8\xa0\x1f\x01\x8a\xe7\xb0*\x1fremes/x/remes/AggregationRecord\"\xcb\x03\n" +
	"\x15AggregationCommitment\x12#\n" +
	"\rcommitment_id\x18\x01 \x01(\x04R\fcommitmentId\x12\x1a\n" +
	"\bproposer\x18\x02 \x01(\tR\bproposer\x12'\n" +
	"\x0fcommitment_hash\x18\x03 \x01(\tR\x0ecommitmentHash\x12*\n" +
	"\x11training_round_id\x18\x04 \x01(\x04R\x0ftrainingRoundId\x128\n" +
	"\x18participant_gradient_ids\x18\x05 \x03(\x04R\x16participantGradientIds\x12.\n" +
	"\x13committed_at_height\x18\x06 \x01(\x03R\x11committedAtHeight\x124\n" +
	"\x16reveal_deadline_height\x18\a \x01(\x03R\x14revealDeadlineHeight\x12\x16\n" +
	"\x06status\x18\b \x01(\tR\x06status\x126\n" +
	"\x17revealed_aggregation_id\x18\t \x01(\x04R\x15revealedAggregationId:,\xe8\xa0\x1f\x01\x8a\xe7\xb0*#remes/x/remes/AggregationCommitment\"\xf1\x02\n" +
	"\x12MiningContribution\x12#\n" +
	"\rminer_address\x18\x01 \x01(\tR\fminerAddress\x12+\n" +
	"\x11total_submissions\x18\x02 \x01(\x04R\x10totalSubmissions\x125\n" +
	"\x16successful_submissions\x18\x03 \x01(\x04R\x15successfulSubmissions\x12\x1f\n" +
	"\vtrust_score\x18\x04 \x01(\tR\n" +
	"trustScore\x12'\n" +
	"\x0freputation_tier\x18\x05 \x01(\tR\x0ereputationTier\x12'\n" +
	"\x0fslashing_events\x18\x06 \x01(\x04R\x0eslashingEvents\x124\n" +
	"\x16last_submission_height\x18\a \x01(\x03R\x14lastSubmissionHeight:)\xe8\xa0\x1f\x01\x8a\xe7\xb0* remes/x/remes/MiningContribution\"\xef\x06\n" +
	"\x0fChallengeRecord\x12!\n" +
	"\fchallenge_id\x18\x01 \x01(\x04R\vchallengeId\x12\x1e\n" +
	"\n" +
	"challenger\x18\x02 \x01(\tR\n" +
	"challenger\x12%\n" +
	"\x0eaggregation_id\x18\x03 \x01(\x04R\raggregationId\x12\x16\n" +
	"\x06reason\x18\x04 \x01(\tR\x06reason\x12,\n" +
	"\x12evidence_ipfs_hash\x18\x05 \x01(\tR\x10evidenceIpfsHash\x12\x16\n" +
	"\x06status\x18\x06 \x01(\tR\x06status\x12*\n" +
	"\x11created_at_height\x18\a \x01(\x03R\x0fcreatedAtHeight\x124\n" +
	"\x16cpu_verification_panel\x18\b \x03(\tR\x14cpuVerificationPanel\x12_\n" +
	"\x18cpu_verification_results\x18\t \x03(\v2%.remes.remes.v1.CPUVerificationResultR\x16cpuVerificationResults\x12+\n" +
	"\x11resolution_height\x18\n" +
	" \x01(\x03R\x10resolutionHeight\x12%\n" +
	"\x0efraud_detected\x18\v \x01(\bR\rfraudDetected\x12\x14\n" +
	"\x05layer\x18\f \x01(\rR\x05layer\x12\x1f\n" +
	"\vbond_amount\x18\r \x01(\tR\n" +
	"bondAmount\x12'\n" +
	"\x0frandom_verifier\x18\x0e \x01(\tR\x0erandomVerifier\x124\n" +
	"\x16random_verifier_result\x18\x0f \x01(\tR\x14randomVerifierResult\x12,\n" +
	"\x12miner_weights_ipfs\x18\x10 \x01(\tR\x10minerWeightsIpfs\x12&\n" +
	"\x0fdata_batch_seed\x18\x11 \x01(\x04R\rdataBatchSeed\x12#\n" +
	"\rverifier_loss\x18\x12 \x01(\tR\fverifierLoss\x12\x1d\n" +
	"\n" +
	"loss_match\x18\x13 \x01(\bR\tlossMatch\x12%\n" +
	"\x0eloss_tolerance\x18\x14 \x01(\tR\rlossTolerance:&\xe8\xa0\x1f\x01\x8a\xe7\xb0*\x1dremes/x/remes/ChallengeRecord\"\xaa\x02\n" +
	"\x15CPUVerificationResult\x12+\n" +
	"\x11validator_address\x18\x01 \x01(\tR\x10validatorAddress\x12\x19\n" +
	"\bis_valid\x18\x02 \x01(\bR\aisValid\x12#\n" +
	"\rcomputed_hash\x18\x03 \x01(\tR\fcomputedHash\x12#\n" +
	"\rexpected_hash\x18\x04 \x01(\tR\fexpectedHash\x12Q\n" +
	"\x11verification_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampB\b\xc8\xde\x1f\x00\x90\xdf\x1f\x01R\x10verificationTime:,\xe8\xa0\x1f\x01\x8a\xe7\xb0*#remes/x/remes/CPUVerificationResult\"\xdd\x05\n" +
	"\x14ParticipantSyncState\x12/\n" +
	"\x13participant_address\x18\x01 \x01(\tR\x12participantAddress\x122\n" +
	"\x15current_model_version\x18\x02 \x01(\tR\x13currentModelVersion\x12(\n" +
	"\x10last_sync_height\x18\x03 \x01(\x03R\x0elastSyncHeight\x12J\n" +
	"\x0elast_sync_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampB\b\xc8\xde\x1f\x00\x90\xdf\x1f\x01R\flastSyncTime\x12\x1b\n" +
	"\tis_synced\x18\x05 \x01(\bR\bisSynced\x12&\n" +
	"\x0fsync_lag_blocks\x18\x06 \x01(\x03R\rsyncLagBlocks\x12)\n" +
	"\x10participant_type\x18\a \x01(\tR\x0fparticipantType\x12%\n" +
	"\x0eis_partitioned\x18\b \x01(\bR\risPartitioned\x122\n" +
	"\x15partition_detected_at\x18\t \x01(\x03R\x13partitionDetectedAt\x12\\\n" +
	"\x17partition_detected_time\x18\n" +
	" \x01(\v2\x1a.google.protobuf.TimestampB\b\xc8\xde\x1f\x00\x90\xdf\x1f\x01R\x15partitionDetectedTime\x124\n" +
	"\x16partition_recovered_at\x18\v \x01(\x03R\x14partitionRecoveredAt\x12^\n" +
	"\x18partition_recovered_time\x18\f \x01(\v2\x1a.google.protobuf.TimestampB\b\xc8\xde\x1f\x00\x90\xdf\x1f\x01R\x16partitionRecoveredTime:+\xe8\xa0\x1f\x01\x8a\xe7\xb0*\"remes/x/remes/ParticipantSyncState\"\xe8\x03\n" +
	"\x15PartitionRecoveryInfo\x12/\n" +
	"\x13participant_address\x18\x01 \x01(\tR\x12participantAddress\x12'\n" +
	"\x0fwas_partitioned\x18\x02 \x01(\bR\x0ewasPartitioned\x12-\n" +
	"\x12partition_duration\x18\x03 \x01(\x03R\x11partitionDuration\x12#\n" +
	"\rrecovery_type\x18\x04 \x01(\tR\frecoveryType\x12,\n" +
	"\x12requires_full_sync\x18\x05 \x01(\bR\x10requiresFullSync\x12&\n" +
	"\x0fsync_lag_blocks\x18\x06 \x01(\x03R\rsyncLagBlocks\x12I\n" +
	"\fglobal_state\x18\a \x01(\v2 .remes.remes.v1.GlobalModelStateB\x04\xc8\xde\x1f\x00R\vglobalState\x12R\n" +
	"\x12catch_up_gradients\x18\b \x03(\v2\x1e.remes.remes.v1.StoredGradientB\x04\xc8\xde\x1f\x00R\x10catchUpGradients:,\xe8\xa0\x1f\x01\x8a\xe7\xb0*#remes/x/remes/PartitionRecoveryInfo\"\xb1\x02\n" +
	"\x12ProofOfReplication\x12\x1b\n" +
	"\tdata_hash\x18\x01 \x01(\tR\bdataHash\x12!\n" +
	"\freplica_hash\x18\x02 \x01(\tR\vreplicaHash\x12!\n" +
	"\fmerkle_proof\x18\x03 \x01(\fR\vmerkleProof\x12#\n" +
	"\rstorage_proof\x18\x04 \x01(\fR\fstorageProof\x12%\n" +
	"\x0ereplication_id\x18\x05 \x01(\tR\rreplicationId\x12#\n" +
	"\rminer_address\x18\x06 \x01(\tR\fminerAddress\x12\x1c\n" +
	"\ttimestamp\x18\a \x01(\x03R\ttimestamp:)\xe8\xa0\x1f\x01\x8a\xe7\xb0* remes/x/remes/ProofOfReplication\"\xc8\x03\n" +
	"\x0fPartitionStatus\x12%\n" +
	"\x0eis_partitioned\x18\x01 \x01(\bR\risPartitioned\x12&\n" +
	"\x0fsync_lag_blocks\x18\x02 \x01(\x03R\rsyncLagBlocks\x12/\n" +
	"\x14time_since_last_sync\x18\x03 \x01(\tR\x11timeSinceLastSync\x12(\n" +
	"\x10last_sync_height\x18\x04 \x01(\x03R\x0elastSyncHeight\x12J\n" +
	"\x0elast_sync_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampB\b\xc8\xde\x1f\x00\x90\xdf\x1f\x01R\flastSyncTime\x122\n" +
	"\x15partition_detected_at\x18\x06 \x01(\x03R\x13partitionDetectedAt\x124\n" +
	"\x16partition_recovered_at\x18\a \x01(\x03R\x14partitionRecoveredAt\x12-\n" +
	"\x12partition_duration\x18\b \x01(\x03R\x11partitionDuration:&\xe8\xa0\x1f\x01\x8a\xe7\xb0*\x1dremes/x/remes/PartitionStatusB\x15Z\x13remes/x/remes/typesb\x06proto3"

var (
	file_remes_remes_v1_state_proto_rawDescOnce sync.Once
	file_remes_remes_v1_state_proto_rawDescData []byte
)

func file_remes_remes_v1_state_proto_rawDescGZIP() []byte {
	file_remes_remes_v1_state_proto_rawDescOnce.Do(func() {
		file_remes_remes_v1_state_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_remes_remes_v1_state_proto_rawDesc), len(file_remes_remes_v1_state_proto_rawDesc)))
	})
	return file_remes_remes_v1_state_proto_rawDescData
}

var file_remes_remes_v1_state_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_remes_remes_v1_state_proto_goTypes = []any{
	(*GlobalModelState)(nil),      // 0: remes.remes.v1.GlobalModelState
	(*AggregationRecord)(nil),     // 1: remes.remes.v1.AggregationRecord
	(*AggregationCommitment)(nil), // 2: remes.remes.v1.AggregationCommitment
	(*MiningContribution)(nil),    // 3: remes.remes.v1.MiningContribution
	(*ChallengeRecord)(nil),       // 4: remes.remes.v1.ChallengeRecord
	(*CPUVerificationResult)(nil), // 5: remes.remes.v1.CPUVerificationResult
	(*ParticipantSyncState)(nil),  // 6: remes.remes.v1.ParticipantSyncState
	(*PartitionRecoveryInfo)(nil), // 7: remes.remes.v1.PartitionRecoveryInfo
	(*ProofOfReplication)(nil),    // 8: remes.remes.v1.ProofOfReplication
	(*PartitionStatus)(nil),       // 9: remes.remes.v1.PartitionStatus
	(*timestamppb.Timestamp)(nil), // 10: google.protobuf.Timestamp
	(*StoredGradient)(nil),        // 11: remes.remes.v1.StoredGradient
}
var file_remes_remes_v1_state_proto_depIdxs = []int32{
	10, // 0: remes.remes.v1.GlobalModelState.last_updated_time:type_name -> google.protobuf.Timestamp
	5,  // 1: remes.remes.v1.ChallengeRecord.cpu_verification_results:type_name -> remes.remes.v1.CPUVerificationResult
	10, // 2: remes.remes.v1.CPUVerificationResult.verification_time:type_name -> google.protobuf.Timestamp
	10, // 3: remes.remes.v1.ParticipantSyncState.last_sync_time:type_name -> google.protobuf.Timestamp
	10, // 4: remes.remes.v1.ParticipantSyncState.partition_detected_time:type_name -> google.protobuf.Timestamp
	10, // 5: remes.remes.v1.ParticipantSyncState.partition_recovered_time:type_name -> google.protobuf.Timestamp
	0,  // 6: remes.remes.v1.PartitionRecoveryInfo.global_state:type_name -> remes.remes.v1.GlobalModelState
	11, // 7: remes.remes.v1.PartitionRecoveryInfo.catch_up_gradients:type_name -> remes.remes.v1.StoredGradient
	10, // 8: remes.remes.v1.PartitionStatus.last_sync_time:type_name -> google.protobuf.Timestamp
	9,  // [9:9] is the sub-list for method output_type
	9,  // [9:9] is the sub-list for method input_type
	9,  // [9:9] is the sub-list for extension type_name
	9,  // [9:9] is the sub-list for extension extendee
	0,  // [0:9] is the sub-list for field type_name
}

func init() { file_remes_remes_v1_state_proto_init() }
func file_remes_remes_v1_state_proto_init() {
	if File_remes_remes_v1_state_proto != nil {
		return
	}
	file_remes_remes_v1_stored_gradient_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_remes_remes_v1_state_proto_rawDesc), len(file_remes_remes_v1_state_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_remes_remes_v1_state_proto_goTypes,
		DependencyIndexes: file_remes_remes_v1_state_proto_depIdxs,
		MessageInfos:      file_remes_remes_v1_state_proto_msgTypes,
	}.Build()
	File_remes_remes_v1_state_proto = out.File
	file_remes_remes_v1_state_proto_goTypes = nil
	file_remes_remes_v1_state_proto_depIdxs = nil
}
