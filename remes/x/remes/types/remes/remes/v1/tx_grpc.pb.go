// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             (unknown)
// source: remes/remes/v1/tx.proto

package types

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	Msg_UpdateParams_FullMethodName               = "/remes.remes.v1.Msg/UpdateParams"
	Msg_RegisterModel_FullMethodName              = "/remes.remes.v1.Msg/RegisterModel"
	Msg_ActivateModel_FullMethodName              = "/remes.remes.v1.Msg/ActivateModel"
	Msg_SubmitGradient_FullMethodName             = "/remes.remes.v1.Msg/SubmitGradient"
	Msg_SubmitAggregation_FullMethodName          = "/remes.remes.v1.Msg/SubmitAggregation"
	Msg_CommitAggregation_FullMethodName          = "/remes.remes.v1.Msg/CommitAggregation"
	Msg_RevealAggregation_FullMethodName          = "/remes.remes.v1.Msg/RevealAggregation"
	Msg_ChallengeAggregation_FullMethodName       = "/remes.remes.v1.Msg/ChallengeAggregation"
	Msg_ProposeDataset_FullMethodName             = "/remes.remes.v1.Msg/ProposeDataset"
	Msg_VoteDataset_FullMethodName                = "/remes.remes.v1.Msg/VoteDataset"
	Msg_MarkDatasetAsOfficial_FullMethodName      = "/remes.remes.v1.Msg/MarkDatasetAsOfficial"
	Msg_RemoveDataset_FullMethodName              = "/remes.remes.v1.Msg/RemoveDataset"
	Msg_RegisterNode_FullMethodName               = "/remes.remes.v1.Msg/RegisterNode"
	Msg_UpdateNodeRegistration_FullMethodName     = "/remes.remes.v1.Msg/UpdateNodeRegistration"
	Msg_SubmitResourceUsage_FullMethodName        = "/remes.remes.v1.Msg/SubmitResourceUsage"
	Msg_CommitPinning_FullMethodName              = "/remes.remes.v1.Msg/CommitPinning"
	Msg_ChallengePinning_FullMethodName           = "/remes.remes.v1.Msg/ChallengePinning"
	Msg_RespondToChallenge_FullMethodName         = "/remes.remes.v1.Msg/RespondToChallenge"
	Msg_ResolveChallenge_FullMethodName           = "/remes.remes.v1.Msg/ResolveChallenge"
	Msg_SubmitCPUVerification_FullMethodName      = "/remes.remes.v1.Msg/SubmitCPUVerification"
	Msg_SubmitRandomVerifierResult_FullMethodName = "/remes.remes.v1.Msg/SubmitRandomVerifierResult"
	Msg_RequestInference_FullMethodName           = "/remes.remes.v1.Msg/RequestInference"
	Msg_SubmitInferenceResult_FullMethodName      = "/remes.remes.v1.Msg/SubmitInferenceResult"
	Msg_UpdateServingNodeStatus_FullMethodName    = "/remes.remes.v1.Msg/UpdateServingNodeStatus"
	Msg_CreateTrapJob_FullMethodName              = "/remes.remes.v1.Msg/CreateTrapJob"
	Msg_SubmitTrapJobResult_FullMethodName        = "/remes.remes.v1.Msg/SubmitTrapJobResult"
	Msg_AppealTrapJobSlashing_FullMethodName      = "/remes.remes.v1.Msg/AppealTrapJobSlashing"
	Msg_ReportLazyValidation_FullMethodName       = "/remes.remes.v1.Msg/ReportLazyValidation"
	Msg_ReportFalseVerdict_FullMethodName         = "/remes.remes.v1.Msg/ReportFalseVerdict"
	Msg_ReportProposerCensorship_FullMethodName   = "/remes.remes.v1.Msg/ReportProposerCensorship"
	Msg_AppealSlashing_FullMethodName             = "/remes.remes.v1.Msg/AppealSlashing"
	Msg_RegisterMentorRelationship_FullMethodName = "/remes.remes.v1.Msg/RegisterMentorRelationship"
	Msg_CreateSubnet_FullMethodName               = "/remes.remes.v1.Msg/CreateSubnet"
	Msg_SubmitSubnetActivation_FullMethodName     = "/remes.remes.v1.Msg/SubmitSubnetActivation"
	Msg_AssignMinerToSubnet_FullMethodName        = "/remes.remes.v1.Msg/AssignMinerToSubnet"
	Msg_CreateTrainingWindow_FullMethodName       = "/remes.remes.v1.Msg/CreateTrainingWindow"
	Msg_SubmitAsyncGradient_FullMethodName        = "/remes.remes.v1.Msg/SubmitAsyncGradient"
	Msg_SubmitLazyAggregation_FullMethodName      = "/remes.remes.v1.Msg/SubmitLazyAggregation"
)

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Msg defines the Msg service.
type MsgClient interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// RegisterModel registers a new model configuration (governance-only)
	RegisterModel(ctx context.Context, in *MsgRegisterModel, opts ...grpc.CallOption) (*MsgRegisterModelResponse, error)
	// ActivateModel activates a model for training (governance-only)
	ActivateModel(ctx context.Context, in *MsgActivateModel, opts ...grpc.CallOption) (*MsgActivateModelResponse, error)
	// SubmitGradient submits a gradient update with IPFS hash (passive IPFS role - Go node only stores hash, not data)
	SubmitGradient(ctx context.Context, in *MsgSubmitGradient, opts ...grpc.CallOption) (*MsgSubmitGradientResponse, error)
	// SubmitAggregation submits aggregated gradient results from off-chain aggregation
	SubmitAggregation(ctx context.Context, in *MsgSubmitAggregation, opts ...grpc.CallOption) (*MsgSubmitAggregationResponse, error)
	// CommitAggregation commits to an aggregation result (commit-reveal scheme for multi-proposer)
	CommitAggregation(ctx context.Context, in *MsgCommitAggregation, opts ...grpc.CallOption) (*MsgCommitAggregationResponse, error)
	// RevealAggregation reveals an aggregation result and verifies commitment
	RevealAggregation(ctx context.Context, in *MsgRevealAggregation, opts ...grpc.CallOption) (*MsgRevealAggregationResponse, error)
	// ChallengeAggregation challenges an aggregation result for dispute resolution
	ChallengeAggregation(ctx context.Context, in *MsgChallengeAggregation, opts ...grpc.CallOption) (*MsgChallengeAggregationResponse, error)
	// ProposeDataset proposes a dataset for governance approval
	ProposeDataset(ctx context.Context, in *MsgProposeDataset, opts ...grpc.CallOption) (*MsgProposeDatasetResponse, error)
	// VoteDataset votes on a dataset proposal
	VoteDataset(ctx context.Context, in *MsgVoteDataset, opts ...grpc.CallOption) (*MsgVoteDatasetResponse, error)
	// MarkDatasetAsOfficial marks an approved dataset as "Official Training Data"
	MarkDatasetAsOfficial(ctx context.Context, in *MsgMarkDatasetAsOfficial, opts ...grpc.CallOption) (*MsgMarkDatasetAsOfficialResponse, error)
	// RemoveDataset removes an approved dataset from the registry
	RemoveDataset(ctx context.Context, in *MsgRemoveDataset, opts ...grpc.CallOption) (*MsgRemoveDatasetResponse, error)
	// RegisterNode registers a node with role specification and resource quotas
	RegisterNode(ctx context.Context, in *MsgRegisterNode, opts ...grpc.CallOption) (*MsgRegisterNodeResponse, error)
	// UpdateNodeRegistration updates node registration information
	UpdateNodeRegistration(ctx context.Context, in *MsgUpdateNodeRegistration, opts ...grpc.CallOption) (*MsgUpdateNodeRegistrationResponse, error)
	// SubmitResourceUsage submits resource usage proof for validation
	SubmitResourceUsage(ctx context.Context, in *MsgSubmitResourceUsage, opts ...grpc.CallOption) (*MsgSubmitResourceUsageResponse, error)
	// CommitPinning commits to pin IPFS content with stake
	CommitPinning(ctx context.Context, in *MsgCommitPinning, opts ...grpc.CallOption) (*MsgCommitPinningResponse, error)
	// ChallengePinning challenges a pinning commitment for data availability verification
	ChallengePinning(ctx context.Context, in *MsgChallengePinning, opts ...grpc.CallOption) (*MsgChallengePinningResponse, error)
	// RespondToChallenge responds to a data availability challenge
	RespondToChallenge(ctx context.Context, in *MsgRespondToChallenge, opts ...grpc.CallOption) (*MsgRespondToChallengeResponse, error)
	// ResolveChallenge resolves an aggregation challenge with CPU verification results
	ResolveChallenge(ctx context.Context, in *MsgResolveChallenge, opts ...grpc.CallOption) (*MsgResolveChallengeResponse, error)
	// SubmitCPUVerification submits CPU verification result for a challenge
	SubmitCPUVerification(ctx context.Context, in *MsgSubmitCPUVerification, opts ...grpc.CallOption) (*MsgSubmitCPUVerificationResponse, error)
	// SubmitRandomVerifierResult submits random GPU verifier result for Layer 2 challenge
	SubmitRandomVerifierResult(ctx context.Context, in *MsgSubmitRandomVerifierResult, opts ...grpc.CallOption) (*MsgSubmitRandomVerifierResultResponse, error)
	// RequestInference requests AI model inference from a serving node
	RequestInference(ctx context.Context, in *MsgRequestInference, opts ...grpc.CallOption) (*MsgRequestInferenceResponse, error)
	// SubmitInferenceResult submits inference result from a serving node
	SubmitInferenceResult(ctx context.Context, in *MsgSubmitInferenceResult, opts ...grpc.CallOption) (*MsgSubmitInferenceResultResponse, error)
	// UpdateServingNodeStatus updates serving node status and model version
	UpdateServingNodeStatus(ctx context.Context, in *MsgUpdateServingNodeStatus, opts ...grpc.CallOption) (*MsgUpdateServingNodeStatusResponse, error)
	// CreateTrapJob creates a trap job for lazy mining detection
	CreateTrapJob(ctx context.Context, in *MsgCreateTrapJob, opts ...grpc.CallOption) (*MsgCreateTrapJobResponse, error)
	// SubmitTrapJobResult submits result for a trap job
	SubmitTrapJobResult(ctx context.Context, in *MsgSubmitTrapJobResult, opts ...grpc.CallOption) (*MsgSubmitTrapJobResultResponse, error)
	// AppealTrapJobSlashing appeals a trap job slashing decision
	AppealTrapJobSlashing(ctx context.Context, in *MsgAppealTrapJobSlashing, opts ...grpc.CallOption) (*MsgAppealTrapJobSlashingResponse, error)
	// ReportLazyValidation reports lazy validation by a validator
	ReportLazyValidation(ctx context.Context, in *MsgReportLazyValidation, opts ...grpc.CallOption) (*MsgReportLazyValidationResponse, error)
	// ReportFalseVerdict reports false verdict by a validator
	ReportFalseVerdict(ctx context.Context, in *MsgReportFalseVerdict, opts ...grpc.CallOption) (*MsgReportFalseVerdictResponse, error)
	// ReportProposerCensorship reports censorship by a proposer
	ReportProposerCensorship(ctx context.Context, in *MsgReportProposerCensorship, opts ...grpc.CallOption) (*MsgReportProposerCensorshipResponse, error)
	// AppealSlashing appeals a slashing decision
	AppealSlashing(ctx context.Context, in *MsgAppealSlashing, opts ...grpc.CallOption) (*MsgAppealSlashingResponse, error)
	// RegisterMentorRelationship registers a mentor-mentee relationship
	RegisterMentorRelationship(ctx context.Context, in *MsgRegisterMentorRelationship, opts ...grpc.CallOption) (*MsgRegisterMentorRelationshipResponse, error)
	// CreateSubnet creates a new subnet for layer-based sharding
	CreateSubnet(ctx context.Context, in *MsgCreateSubnet, opts ...grpc.CallOption) (*MsgCreateSubnetResponse, error)
	// SubmitSubnetActivation submits activation data from a subnet
	SubmitSubnetActivation(ctx context.Context, in *MsgSubmitSubnetActivation, opts ...grpc.CallOption) (*MsgSubmitSubnetActivationResponse, error)
	// AssignMinerToSubnet assigns a miner to a subnet
	AssignMinerToSubnet(ctx context.Context, in *MsgAssignMinerToSubnet, opts ...grpc.CallOption) (*MsgAssignMinerToSubnetResponse, error)
	// CreateTrainingWindow creates a new training window
	CreateTrainingWindow(ctx context.Context, in *MsgCreateTrainingWindow, opts ...grpc.CallOption) (*MsgCreateTrainingWindowResponse, error)
	// SubmitAsyncGradient submits an asynchronous gradient (non-blocking)
	SubmitAsyncGradient(ctx context.Context, in *MsgSubmitAsyncGradient, opts ...grpc.CallOption) (*MsgSubmitAsyncGradientResponse, error)
	// SubmitLazyAggregation submits lazy aggregation at window boundary
	SubmitLazyAggregation(ctx context.Context, in *MsgSubmitLazyAggregation, opts ...grpc.CallOption) (*MsgSubmitLazyAggregationResponse, error)
}

type msgClient struct {
	cc grpc.ClientConnInterface
}

func NewMsgClient(cc grpc.ClientConnInterface) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, Msg_UpdateParams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterModel(ctx context.Context, in *MsgRegisterModel, opts ...grpc.CallOption) (*MsgRegisterModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRegisterModelResponse)
	err := c.cc.Invoke(ctx, Msg_RegisterModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ActivateModel(ctx context.Context, in *MsgActivateModel, opts ...grpc.CallOption) (*MsgActivateModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgActivateModelResponse)
	err := c.cc.Invoke(ctx, Msg_ActivateModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitGradient(ctx context.Context, in *MsgSubmitGradient, opts ...grpc.CallOption) (*MsgSubmitGradientResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSubmitGradientResponse)
	err := c.cc.Invoke(ctx, Msg_SubmitGradient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitAggregation(ctx context.Context, in *MsgSubmitAggregation, opts ...grpc.CallOption) (*MsgSubmitAggregationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSubmitAggregationResponse)
	err := c.cc.Invoke(ctx, Msg_SubmitAggregation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CommitAggregation(ctx context.Context, in *MsgCommitAggregation, opts ...grpc.CallOption) (*MsgCommitAggregationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCommitAggregationResponse)
	err := c.cc.Invoke(ctx, Msg_CommitAggregation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RevealAggregation(ctx context.Context, in *MsgRevealAggregation, opts ...grpc.CallOption) (*MsgRevealAggregationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRevealAggregationResponse)
	err := c.cc.Invoke(ctx, Msg_RevealAggregation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ChallengeAggregation(ctx context.Context, in *MsgChallengeAggregation, opts ...grpc.CallOption) (*MsgChallengeAggregationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgChallengeAggregationResponse)
	err := c.cc.Invoke(ctx, Msg_ChallengeAggregation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ProposeDataset(ctx context.Context, in *MsgProposeDataset, opts ...grpc.CallOption) (*MsgProposeDatasetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgProposeDatasetResponse)
	err := c.cc.Invoke(ctx, Msg_ProposeDataset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) VoteDataset(ctx context.Context, in *MsgVoteDataset, opts ...grpc.CallOption) (*MsgVoteDatasetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgVoteDatasetResponse)
	err := c.cc.Invoke(ctx, Msg_VoteDataset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MarkDatasetAsOfficial(ctx context.Context, in *MsgMarkDatasetAsOfficial, opts ...grpc.CallOption) (*MsgMarkDatasetAsOfficialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgMarkDatasetAsOfficialResponse)
	err := c.cc.Invoke(ctx, Msg_MarkDatasetAsOfficial_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoveDataset(ctx context.Context, in *MsgRemoveDataset, opts ...grpc.CallOption) (*MsgRemoveDatasetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRemoveDatasetResponse)
	err := c.cc.Invoke(ctx, Msg_RemoveDataset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterNode(ctx context.Context, in *MsgRegisterNode, opts ...grpc.CallOption) (*MsgRegisterNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRegisterNodeResponse)
	err := c.cc.Invoke(ctx, Msg_RegisterNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateNodeRegistration(ctx context.Context, in *MsgUpdateNodeRegistration, opts ...grpc.CallOption) (*MsgUpdateNodeRegistrationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgUpdateNodeRegistrationResponse)
	err := c.cc.Invoke(ctx, Msg_UpdateNodeRegistration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitResourceUsage(ctx context.Context, in *MsgSubmitResourceUsage, opts ...grpc.CallOption) (*MsgSubmitResourceUsageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSubmitResourceUsageResponse)
	err := c.cc.Invoke(ctx, Msg_SubmitResourceUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CommitPinning(ctx context.Context, in *MsgCommitPinning, opts ...grpc.CallOption) (*MsgCommitPinningResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCommitPinningResponse)
	err := c.cc.Invoke(ctx, Msg_CommitPinning_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ChallengePinning(ctx context.Context, in *MsgChallengePinning, opts ...grpc.CallOption) (*MsgChallengePinningResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgChallengePinningResponse)
	err := c.cc.Invoke(ctx, Msg_ChallengePinning_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RespondToChallenge(ctx context.Context, in *MsgRespondToChallenge, opts ...grpc.CallOption) (*MsgRespondToChallengeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRespondToChallengeResponse)
	err := c.cc.Invoke(ctx, Msg_RespondToChallenge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ResolveChallenge(ctx context.Context, in *MsgResolveChallenge, opts ...grpc.CallOption) (*MsgResolveChallengeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgResolveChallengeResponse)
	err := c.cc.Invoke(ctx, Msg_ResolveChallenge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitCPUVerification(ctx context.Context, in *MsgSubmitCPUVerification, opts ...grpc.CallOption) (*MsgSubmitCPUVerificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSubmitCPUVerificationResponse)
	err := c.cc.Invoke(ctx, Msg_SubmitCPUVerification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitRandomVerifierResult(ctx context.Context, in *MsgSubmitRandomVerifierResult, opts ...grpc.CallOption) (*MsgSubmitRandomVerifierResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSubmitRandomVerifierResultResponse)
	err := c.cc.Invoke(ctx, Msg_SubmitRandomVerifierResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RequestInference(ctx context.Context, in *MsgRequestInference, opts ...grpc.CallOption) (*MsgRequestInferenceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRequestInferenceResponse)
	err := c.cc.Invoke(ctx, Msg_RequestInference_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitInferenceResult(ctx context.Context, in *MsgSubmitInferenceResult, opts ...grpc.CallOption) (*MsgSubmitInferenceResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSubmitInferenceResultResponse)
	err := c.cc.Invoke(ctx, Msg_SubmitInferenceResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateServingNodeStatus(ctx context.Context, in *MsgUpdateServingNodeStatus, opts ...grpc.CallOption) (*MsgUpdateServingNodeStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgUpdateServingNodeStatusResponse)
	err := c.cc.Invoke(ctx, Msg_UpdateServingNodeStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateTrapJob(ctx context.Context, in *MsgCreateTrapJob, opts ...grpc.CallOption) (*MsgCreateTrapJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCreateTrapJobResponse)
	err := c.cc.Invoke(ctx, Msg_CreateTrapJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitTrapJobResult(ctx context.Context, in *MsgSubmitTrapJobResult, opts ...grpc.CallOption) (*MsgSubmitTrapJobResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSubmitTrapJobResultResponse)
	err := c.cc.Invoke(ctx, Msg_SubmitTrapJobResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AppealTrapJobSlashing(ctx context.Context, in *MsgAppealTrapJobSlashing, opts ...grpc.CallOption) (*MsgAppealTrapJobSlashingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgAppealTrapJobSlashingResponse)
	err := c.cc.Invoke(ctx, Msg_AppealTrapJobSlashing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ReportLazyValidation(ctx context.Context, in *MsgReportLazyValidation, opts ...grpc.CallOption) (*MsgReportLazyValidationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgReportLazyValidationResponse)
	err := c.cc.Invoke(ctx, Msg_ReportLazyValidation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ReportFalseVerdict(ctx context.Context, in *MsgReportFalseVerdict, opts ...grpc.CallOption) (*MsgReportFalseVerdictResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgReportFalseVerdictResponse)
	err := c.cc.Invoke(ctx, Msg_ReportFalseVerdict_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ReportProposerCensorship(ctx context.Context, in *MsgReportProposerCensorship, opts ...grpc.CallOption) (*MsgReportProposerCensorshipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgReportProposerCensorshipResponse)
	err := c.cc.Invoke(ctx, Msg_ReportProposerCensorship_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AppealSlashing(ctx context.Context, in *MsgAppealSlashing, opts ...grpc.CallOption) (*MsgAppealSlashingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgAppealSlashingResponse)
	err := c.cc.Invoke(ctx, Msg_AppealSlashing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterMentorRelationship(ctx context.Context, in *MsgRegisterMentorRelationship, opts ...grpc.CallOption) (*MsgRegisterMentorRelationshipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRegisterMentorRelationshipResponse)
	err := c.cc.Invoke(ctx, Msg_RegisterMentorRelationship_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateSubnet(ctx context.Context, in *MsgCreateSubnet, opts ...grpc.CallOption) (*MsgCreateSubnetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCreateSubnetResponse)
	err := c.cc.Invoke(ctx, Msg_CreateSubnet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitSubnetActivation(ctx context.Context, in *MsgSubmitSubnetActivation, opts ...grpc.CallOption) (*MsgSubmitSubnetActivationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSubmitSubnetActivationResponse)
	err := c.cc.Invoke(ctx, Msg_SubmitSubnetActivation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AssignMinerToSubnet(ctx context.Context, in *MsgAssignMinerToSubnet, opts ...grpc.CallOption) (*MsgAssignMinerToSubnetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgAssignMinerToSubnetResponse)
	err := c.cc.Invoke(ctx, Msg_AssignMinerToSubnet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateTrainingWindow(ctx context.Context, in *MsgCreateTrainingWindow, opts ...grpc.CallOption) (*MsgCreateTrainingWindowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCreateTrainingWindowResponse)
	err := c.cc.Invoke(ctx, Msg_CreateTrainingWindow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitAsyncGradient(ctx context.Context, in *MsgSubmitAsyncGradient, opts ...grpc.CallOption) (*MsgSubmitAsyncGradientResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSubmitAsyncGradientResponse)
	err := c.cc.Invoke(ctx, Msg_SubmitAsyncGradient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitLazyAggregation(ctx context.Context, in *MsgSubmitLazyAggregation, opts ...grpc.CallOption) (*MsgSubmitLazyAggregationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSubmitLazyAggregationResponse)
	err := c.cc.Invoke(ctx, Msg_SubmitLazyAggregation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
// All implementations must embed UnimplementedMsgServer
// for forward compatibility
//
// Msg defines the Msg service.
type MsgServer interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// RegisterModel registers a new model configuration (governance-only)
	RegisterModel(context.Context, *MsgRegisterModel) (*MsgRegisterModelResponse, error)
	// ActivateModel activates a model for training (governance-only)
	ActivateModel(context.Context, *MsgActivateModel) (*MsgActivateModelResponse, error)
	// SubmitGradient submits a gradient update with IPFS hash (passive IPFS role - Go node only stores hash, not data)
	SubmitGradient(context.Context, *MsgSubmitGradient) (*MsgSubmitGradientResponse, error)
	// SubmitAggregation submits aggregated gradient results from off-chain aggregation
	SubmitAggregation(context.Context, *MsgSubmitAggregation) (*MsgSubmitAggregationResponse, error)
	// CommitAggregation commits to an aggregation result (commit-reveal scheme for multi-proposer)
	CommitAggregation(context.Context, *MsgCommitAggregation) (*MsgCommitAggregationResponse, error)
	// RevealAggregation reveals an aggregation result and verifies commitment
	RevealAggregation(context.Context, *MsgRevealAggregation) (*MsgRevealAggregationResponse, error)
	// ChallengeAggregation challenges an aggregation result for dispute resolution
	ChallengeAggregation(context.Context, *MsgChallengeAggregation) (*MsgChallengeAggregationResponse, error)
	// ProposeDataset proposes a dataset for governance approval
	ProposeDataset(context.Context, *MsgProposeDataset) (*MsgProposeDatasetResponse, error)
	// VoteDataset votes on a dataset proposal
	VoteDataset(context.Context, *MsgVoteDataset) (*MsgVoteDatasetResponse, error)
	// MarkDatasetAsOfficial marks an approved dataset as "Official Training Data"
	MarkDatasetAsOfficial(context.Context, *MsgMarkDatasetAsOfficial) (*MsgMarkDatasetAsOfficialResponse, error)
	// RemoveDataset removes an approved dataset from the registry
	RemoveDataset(context.Context, *MsgRemoveDataset) (*MsgRemoveDatasetResponse, error)
	// RegisterNode registers a node with role specification and resource quotas
	RegisterNode(context.Context, *MsgRegisterNode) (*MsgRegisterNodeResponse, error)
	// UpdateNodeRegistration updates node registration information
	UpdateNodeRegistration(context.Context, *MsgUpdateNodeRegistration) (*MsgUpdateNodeRegistrationResponse, error)
	// SubmitResourceUsage submits resource usage proof for validation
	SubmitResourceUsage(context.Context, *MsgSubmitResourceUsage) (*MsgSubmitResourceUsageResponse, error)
	// CommitPinning commits to pin IPFS content with stake
	CommitPinning(context.Context, *MsgCommitPinning) (*MsgCommitPinningResponse, error)
	// ChallengePinning challenges a pinning commitment for data availability verification
	ChallengePinning(context.Context, *MsgChallengePinning) (*MsgChallengePinningResponse, error)
	// RespondToChallenge responds to a data availability challenge
	RespondToChallenge(context.Context, *MsgRespondToChallenge) (*MsgRespondToChallengeResponse, error)
	// ResolveChallenge resolves an aggregation challenge with CPU verification results
	ResolveChallenge(context.Context, *MsgResolveChallenge) (*MsgResolveChallengeResponse, error)
	// SubmitCPUVerification submits CPU verification result for a challenge
	SubmitCPUVerification(context.Context, *MsgSubmitCPUVerification) (*MsgSubmitCPUVerificationResponse, error)
	// SubmitRandomVerifierResult submits random GPU verifier result for Layer 2 challenge
	SubmitRandomVerifierResult(context.Context, *MsgSubmitRandomVerifierResult) (*MsgSubmitRandomVerifierResultResponse, error)
	// RequestInference requests AI model inference from a serving node
	RequestInference(context.Context, *MsgRequestInference) (*MsgRequestInferenceResponse, error)
	// SubmitInferenceResult submits inference result from a serving node
	SubmitInferenceResult(context.Context, *MsgSubmitInferenceResult) (*MsgSubmitInferenceResultResponse, error)
	// UpdateServingNodeStatus updates serving node status and model version
	UpdateServingNodeStatus(context.Context, *MsgUpdateServingNodeStatus) (*MsgUpdateServingNodeStatusResponse, error)
	// CreateTrapJob creates a trap job for lazy mining detection
	CreateTrapJob(context.Context, *MsgCreateTrapJob) (*MsgCreateTrapJobResponse, error)
	// SubmitTrapJobResult submits result for a trap job
	SubmitTrapJobResult(context.Context, *MsgSubmitTrapJobResult) (*MsgSubmitTrapJobResultResponse, error)
	// AppealTrapJobSlashing appeals a trap job slashing decision
	AppealTrapJobSlashing(context.Context, *MsgAppealTrapJobSlashing) (*MsgAppealTrapJobSlashingResponse, error)
	// ReportLazyValidation reports lazy validation by a validator
	ReportLazyValidation(context.Context, *MsgReportLazyValidation) (*MsgReportLazyValidationResponse, error)
	// ReportFalseVerdict reports false verdict by a validator
	ReportFalseVerdict(context.Context, *MsgReportFalseVerdict) (*MsgReportFalseVerdictResponse, error)
	// ReportProposerCensorship reports censorship by a proposer
	ReportProposerCensorship(context.Context, *MsgReportProposerCensorship) (*MsgReportProposerCensorshipResponse, error)
	// AppealSlashing appeals a slashing decision
	AppealSlashing(context.Context, *MsgAppealSlashing) (*MsgAppealSlashingResponse, error)
	// RegisterMentorRelationship registers a mentor-mentee relationship
	RegisterMentorRelationship(context.Context, *MsgRegisterMentorRelationship) (*MsgRegisterMentorRelationshipResponse, error)
	// CreateSubnet creates a new subnet for layer-based sharding
	CreateSubnet(context.Context, *MsgCreateSubnet) (*MsgCreateSubnetResponse, error)
	// SubmitSubnetActivation submits activation data from a subnet
	SubmitSubnetActivation(context.Context, *MsgSubmitSubnetActivation) (*MsgSubmitSubnetActivationResponse, error)
	// AssignMinerToSubnet assigns a miner to a subnet
	AssignMinerToSubnet(context.Context, *MsgAssignMinerToSubnet) (*MsgAssignMinerToSubnetResponse, error)
	// CreateTrainingWindow creates a new training window
	CreateTrainingWindow(context.Context, *MsgCreateTrainingWindow) (*MsgCreateTrainingWindowResponse, error)
	// SubmitAsyncGradient submits an asynchronous gradient (non-blocking)
	SubmitAsyncGradient(context.Context, *MsgSubmitAsyncGradient) (*MsgSubmitAsyncGradientResponse, error)
	// SubmitLazyAggregation submits lazy aggregation at window boundary
	SubmitLazyAggregation(context.Context, *MsgSubmitLazyAggregation) (*MsgSubmitLazyAggregationResponse, error)
	mustEmbedUnimplementedMsgServer()
}

// UnimplementedMsgServer must be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (UnimplementedMsgServer) UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (UnimplementedMsgServer) RegisterModel(context.Context, *MsgRegisterModel) (*MsgRegisterModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterModel not implemented")
}
func (UnimplementedMsgServer) ActivateModel(context.Context, *MsgActivateModel) (*MsgActivateModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateModel not implemented")
}
func (UnimplementedMsgServer) SubmitGradient(context.Context, *MsgSubmitGradient) (*MsgSubmitGradientResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitGradient not implemented")
}
func (UnimplementedMsgServer) SubmitAggregation(context.Context, *MsgSubmitAggregation) (*MsgSubmitAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAggregation not implemented")
}
func (UnimplementedMsgServer) CommitAggregation(context.Context, *MsgCommitAggregation) (*MsgCommitAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitAggregation not implemented")
}
func (UnimplementedMsgServer) RevealAggregation(context.Context, *MsgRevealAggregation) (*MsgRevealAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevealAggregation not implemented")
}
func (UnimplementedMsgServer) ChallengeAggregation(context.Context, *MsgChallengeAggregation) (*MsgChallengeAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeAggregation not implemented")
}
func (UnimplementedMsgServer) ProposeDataset(context.Context, *MsgProposeDataset) (*MsgProposeDatasetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposeDataset not implemented")
}
func (UnimplementedMsgServer) VoteDataset(context.Context, *MsgVoteDataset) (*MsgVoteDatasetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VoteDataset not implemented")
}
func (UnimplementedMsgServer) MarkDatasetAsOfficial(context.Context, *MsgMarkDatasetAsOfficial) (*MsgMarkDatasetAsOfficialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkDatasetAsOfficial not implemented")
}
func (UnimplementedMsgServer) RemoveDataset(context.Context, *MsgRemoveDataset) (*MsgRemoveDatasetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveDataset not implemented")
}
func (UnimplementedMsgServer) RegisterNode(context.Context, *MsgRegisterNode) (*MsgRegisterNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterNode not implemented")
}
func (UnimplementedMsgServer) UpdateNodeRegistration(context.Context, *MsgUpdateNodeRegistration) (*MsgUpdateNodeRegistrationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNodeRegistration not implemented")
}
func (UnimplementedMsgServer) SubmitResourceUsage(context.Context, *MsgSubmitResourceUsage) (*MsgSubmitResourceUsageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitResourceUsage not implemented")
}
func (UnimplementedMsgServer) CommitPinning(context.Context, *MsgCommitPinning) (*MsgCommitPinningResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitPinning not implemented")
}
func (UnimplementedMsgServer) ChallengePinning(context.Context, *MsgChallengePinning) (*MsgChallengePinningResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengePinning not implemented")
}
func (UnimplementedMsgServer) RespondToChallenge(context.Context, *MsgRespondToChallenge) (*MsgRespondToChallengeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondToChallenge not implemented")
}
func (UnimplementedMsgServer) ResolveChallenge(context.Context, *MsgResolveChallenge) (*MsgResolveChallengeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveChallenge not implemented")
}
func (UnimplementedMsgServer) SubmitCPUVerification(context.Context, *MsgSubmitCPUVerification) (*MsgSubmitCPUVerificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitCPUVerification not implemented")
}
func (UnimplementedMsgServer) SubmitRandomVerifierResult(context.Context, *MsgSubmitRandomVerifierResult) (*MsgSubmitRandomVerifierResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitRandomVerifierResult not implemented")
}
func (UnimplementedMsgServer) RequestInference(context.Context, *MsgRequestInference) (*MsgRequestInferenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestInference not implemented")
}
func (UnimplementedMsgServer) SubmitInferenceResult(context.Context, *MsgSubmitInferenceResult) (*MsgSubmitInferenceResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitInferenceResult not implemented")
}
func (UnimplementedMsgServer) UpdateServingNodeStatus(context.Context, *MsgUpdateServingNodeStatus) (*MsgUpdateServingNodeStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateServingNodeStatus not implemented")
}
func (UnimplementedMsgServer) CreateTrapJob(context.Context, *MsgCreateTrapJob) (*MsgCreateTrapJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrapJob not implemented")
}
func (UnimplementedMsgServer) SubmitTrapJobResult(context.Context, *MsgSubmitTrapJobResult) (*MsgSubmitTrapJobResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTrapJobResult not implemented")
}
func (UnimplementedMsgServer) AppealTrapJobSlashing(context.Context, *MsgAppealTrapJobSlashing) (*MsgAppealTrapJobSlashingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppealTrapJobSlashing not implemented")
}
func (UnimplementedMsgServer) ReportLazyValidation(context.Context, *MsgReportLazyValidation) (*MsgReportLazyValidationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportLazyValidation not implemented")
}
func (UnimplementedMsgServer) ReportFalseVerdict(context.Context, *MsgReportFalseVerdict) (*MsgReportFalseVerdictResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportFalseVerdict not implemented")
}
func (UnimplementedMsgServer) ReportProposerCensorship(context.Context, *MsgReportProposerCensorship) (*MsgReportProposerCensorshipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportProposerCensorship not implemented")
}
func (UnimplementedMsgServer) AppealSlashing(context.Context, *MsgAppealSlashing) (*MsgAppealSlashingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppealSlashing not implemented")
}
func (UnimplementedMsgServer) RegisterMentorRelationship(context.Context, *MsgRegisterMentorRelationship) (*MsgRegisterMentorRelationshipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterMentorRelationship not implemented")
}
func (UnimplementedMsgServer) CreateSubnet(context.Context, *MsgCreateSubnet) (*MsgCreateSubnetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSubnet not implemented")
}
func (UnimplementedMsgServer) SubmitSubnetActivation(context.Context, *MsgSubmitSubnetActivation) (*MsgSubmitSubnetActivationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitSubnetActivation not implemented")
}
func (UnimplementedMsgServer) AssignMinerToSubnet(context.Context, *MsgAssignMinerToSubnet) (*MsgAssignMinerToSubnetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignMinerToSubnet not implemented")
}
func (UnimplementedMsgServer) CreateTrainingWindow(context.Context, *MsgCreateTrainingWindow) (*MsgCreateTrainingWindowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrainingWindow not implemented")
}
func (UnimplementedMsgServer) SubmitAsyncGradient(context.Context, *MsgSubmitAsyncGradient) (*MsgSubmitAsyncGradientResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAsyncGradient not implemented")
}
func (UnimplementedMsgServer) SubmitLazyAggregation(context.Context, *MsgSubmitLazyAggregation) (*MsgSubmitLazyAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitLazyAggregation not implemented")
}
func (UnimplementedMsgServer) mustEmbedUnimplementedMsgServer() {}

// UnsafeMsgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MsgServer will
// result in compilation errors.
type UnsafeMsgServer interface {
	mustEmbedUnimplementedMsgServer()
}

func RegisterMsgServer(s grpc.ServiceRegistrar, srv MsgServer) {
	s.RegisterService(&Msg_ServiceDesc, srv)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_UpdateParams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterModel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RegisterModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterModel(ctx, req.(*MsgRegisterModel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ActivateModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgActivateModel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ActivateModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ActivateModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ActivateModel(ctx, req.(*MsgActivateModel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitGradient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitGradient)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitGradient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SubmitGradient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitGradient(ctx, req.(*MsgSubmitGradient))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitAggregation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitAggregation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitAggregation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SubmitAggregation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitAggregation(ctx, req.(*MsgSubmitAggregation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CommitAggregation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCommitAggregation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CommitAggregation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CommitAggregation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CommitAggregation(ctx, req.(*MsgCommitAggregation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RevealAggregation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRevealAggregation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RevealAggregation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RevealAggregation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RevealAggregation(ctx, req.(*MsgRevealAggregation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ChallengeAggregation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgChallengeAggregation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ChallengeAggregation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ChallengeAggregation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ChallengeAggregation(ctx, req.(*MsgChallengeAggregation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ProposeDataset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProposeDataset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProposeDataset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ProposeDataset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProposeDataset(ctx, req.(*MsgProposeDataset))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_VoteDataset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgVoteDataset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).VoteDataset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_VoteDataset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).VoteDataset(ctx, req.(*MsgVoteDataset))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MarkDatasetAsOfficial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMarkDatasetAsOfficial)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MarkDatasetAsOfficial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_MarkDatasetAsOfficial_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MarkDatasetAsOfficial(ctx, req.(*MsgMarkDatasetAsOfficial))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoveDataset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoveDataset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoveDataset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RemoveDataset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoveDataset(ctx, req.(*MsgRemoveDataset))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RegisterNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterNode(ctx, req.(*MsgRegisterNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateNodeRegistration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateNodeRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateNodeRegistration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_UpdateNodeRegistration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateNodeRegistration(ctx, req.(*MsgUpdateNodeRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitResourceUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitResourceUsage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitResourceUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SubmitResourceUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitResourceUsage(ctx, req.(*MsgSubmitResourceUsage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CommitPinning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCommitPinning)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CommitPinning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CommitPinning_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CommitPinning(ctx, req.(*MsgCommitPinning))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ChallengePinning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgChallengePinning)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ChallengePinning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ChallengePinning_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ChallengePinning(ctx, req.(*MsgChallengePinning))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RespondToChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRespondToChallenge)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RespondToChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RespondToChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RespondToChallenge(ctx, req.(*MsgRespondToChallenge))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ResolveChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgResolveChallenge)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ResolveChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ResolveChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ResolveChallenge(ctx, req.(*MsgResolveChallenge))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitCPUVerification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitCPUVerification)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitCPUVerification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SubmitCPUVerification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitCPUVerification(ctx, req.(*MsgSubmitCPUVerification))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitRandomVerifierResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitRandomVerifierResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitRandomVerifierResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SubmitRandomVerifierResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitRandomVerifierResult(ctx, req.(*MsgSubmitRandomVerifierResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RequestInference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRequestInference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RequestInference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RequestInference_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RequestInference(ctx, req.(*MsgRequestInference))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitInferenceResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitInferenceResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitInferenceResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SubmitInferenceResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitInferenceResult(ctx, req.(*MsgSubmitInferenceResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateServingNodeStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateServingNodeStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateServingNodeStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_UpdateServingNodeStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateServingNodeStatus(ctx, req.(*MsgUpdateServingNodeStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateTrapJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateTrapJob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateTrapJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CreateTrapJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateTrapJob(ctx, req.(*MsgCreateTrapJob))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitTrapJobResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitTrapJobResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitTrapJobResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SubmitTrapJobResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitTrapJobResult(ctx, req.(*MsgSubmitTrapJobResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AppealTrapJobSlashing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAppealTrapJobSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AppealTrapJobSlashing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_AppealTrapJobSlashing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AppealTrapJobSlashing(ctx, req.(*MsgAppealTrapJobSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ReportLazyValidation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReportLazyValidation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ReportLazyValidation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ReportLazyValidation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ReportLazyValidation(ctx, req.(*MsgReportLazyValidation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ReportFalseVerdict_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReportFalseVerdict)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ReportFalseVerdict(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ReportFalseVerdict_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ReportFalseVerdict(ctx, req.(*MsgReportFalseVerdict))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ReportProposerCensorship_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReportProposerCensorship)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ReportProposerCensorship(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ReportProposerCensorship_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ReportProposerCensorship(ctx, req.(*MsgReportProposerCensorship))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AppealSlashing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAppealSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AppealSlashing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_AppealSlashing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AppealSlashing(ctx, req.(*MsgAppealSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterMentorRelationship_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterMentorRelationship)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterMentorRelationship(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RegisterMentorRelationship_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterMentorRelationship(ctx, req.(*MsgRegisterMentorRelationship))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateSubnet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CreateSubnet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateSubnet(ctx, req.(*MsgCreateSubnet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitSubnetActivation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitSubnetActivation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitSubnetActivation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SubmitSubnetActivation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitSubnetActivation(ctx, req.(*MsgSubmitSubnetActivation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AssignMinerToSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAssignMinerToSubnet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AssignMinerToSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_AssignMinerToSubnet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AssignMinerToSubnet(ctx, req.(*MsgAssignMinerToSubnet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateTrainingWindow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateTrainingWindow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateTrainingWindow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CreateTrainingWindow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateTrainingWindow(ctx, req.(*MsgCreateTrainingWindow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitAsyncGradient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitAsyncGradient)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitAsyncGradient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SubmitAsyncGradient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitAsyncGradient(ctx, req.(*MsgSubmitAsyncGradient))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitLazyAggregation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitLazyAggregation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitLazyAggregation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SubmitLazyAggregation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitLazyAggregation(ctx, req.(*MsgSubmitLazyAggregation))
	}
	return interceptor(ctx, in, info, handler)
}

// Msg_ServiceDesc is the grpc.ServiceDesc for Msg service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Msg_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "remes.remes.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "RegisterModel",
			Handler:    _Msg_RegisterModel_Handler,
		},
		{
			MethodName: "ActivateModel",
			Handler:    _Msg_ActivateModel_Handler,
		},
		{
			MethodName: "SubmitGradient",
			Handler:    _Msg_SubmitGradient_Handler,
		},
		{
			MethodName: "SubmitAggregation",
			Handler:    _Msg_SubmitAggregation_Handler,
		},
		{
			MethodName: "CommitAggregation",
			Handler:    _Msg_CommitAggregation_Handler,
		},
		{
			MethodName: "RevealAggregation",
			Handler:    _Msg_RevealAggregation_Handler,
		},
		{
			MethodName: "ChallengeAggregation",
			Handler:    _Msg_ChallengeAggregation_Handler,
		},
		{
			MethodName: "ProposeDataset",
			Handler:    _Msg_ProposeDataset_Handler,
		},
		{
			MethodName: "VoteDataset",
			Handler:    _Msg_VoteDataset_Handler,
		},
		{
			MethodName: "MarkDatasetAsOfficial",
			Handler:    _Msg_MarkDatasetAsOfficial_Handler,
		},
		{
			MethodName: "RemoveDataset",
			Handler:    _Msg_RemoveDataset_Handler,
		},
		{
			MethodName: "RegisterNode",
			Handler:    _Msg_RegisterNode_Handler,
		},
		{
			MethodName: "UpdateNodeRegistration",
			Handler:    _Msg_UpdateNodeRegistration_Handler,
		},
		{
			MethodName: "SubmitResourceUsage",
			Handler:    _Msg_SubmitResourceUsage_Handler,
		},
		{
			MethodName: "CommitPinning",
			Handler:    _Msg_CommitPinning_Handler,
		},
		{
			MethodName: "ChallengePinning",
			Handler:    _Msg_ChallengePinning_Handler,
		},
		{
			MethodName: "RespondToChallenge",
			Handler:    _Msg_RespondToChallenge_Handler,
		},
		{
			MethodName: "ResolveChallenge",
			Handler:    _Msg_ResolveChallenge_Handler,
		},
		{
			MethodName: "SubmitCPUVerification",
			Handler:    _Msg_SubmitCPUVerification_Handler,
		},
		{
			MethodName: "SubmitRandomVerifierResult",
			Handler:    _Msg_SubmitRandomVerifierResult_Handler,
		},
		{
			MethodName: "RequestInference",
			Handler:    _Msg_RequestInference_Handler,
		},
		{
			MethodName: "SubmitInferenceResult",
			Handler:    _Msg_SubmitInferenceResult_Handler,
		},
		{
			MethodName: "UpdateServingNodeStatus",
			Handler:    _Msg_UpdateServingNodeStatus_Handler,
		},
		{
			MethodName: "CreateTrapJob",
			Handler:    _Msg_CreateTrapJob_Handler,
		},
		{
			MethodName: "SubmitTrapJobResult",
			Handler:    _Msg_SubmitTrapJobResult_Handler,
		},
		{
			MethodName: "AppealTrapJobSlashing",
			Handler:    _Msg_AppealTrapJobSlashing_Handler,
		},
		{
			MethodName: "ReportLazyValidation",
			Handler:    _Msg_ReportLazyValidation_Handler,
		},
		{
			MethodName: "ReportFalseVerdict",
			Handler:    _Msg_ReportFalseVerdict_Handler,
		},
		{
			MethodName: "ReportProposerCensorship",
			Handler:    _Msg_ReportProposerCensorship_Handler,
		},
		{
			MethodName: "AppealSlashing",
			Handler:    _Msg_AppealSlashing_Handler,
		},
		{
			MethodName: "RegisterMentorRelationship",
			Handler:    _Msg_RegisterMentorRelationship_Handler,
		},
		{
			MethodName: "CreateSubnet",
			Handler:    _Msg_CreateSubnet_Handler,
		},
		{
			MethodName: "SubmitSubnetActivation",
			Handler:    _Msg_SubmitSubnetActivation_Handler,
		},
		{
			MethodName: "AssignMinerToSubnet",
			Handler:    _Msg_AssignMinerToSubnet_Handler,
		},
		{
			MethodName: "CreateTrainingWindow",
			Handler:    _Msg_CreateTrainingWindow_Handler,
		},
		{
			MethodName: "SubmitAsyncGradient",
			Handler:    _Msg_SubmitAsyncGradient_Handler,
		},
		{
			MethodName: "SubmitLazyAggregation",
			Handler:    _Msg_SubmitLazyAggregation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "remes/remes/v1/tx.proto",
}
