// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: remes/remes/v1/subnet.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// LayerRange defines a range of model layers
type LayerRange struct {
	// start_layer is the starting layer index (inclusive)
	StartLayer uint64 `protobuf:"varint,1,opt,name=start_layer,json=startLayer,proto3" json:"start_layer,omitempty"`
	// end_layer is the ending layer index (inclusive)
	EndLayer uint64 `protobuf:"varint,2,opt,name=end_layer,json=endLayer,proto3" json:"end_layer,omitempty"`
}

func (m *LayerRange) Reset()         { *m = LayerRange{} }
func (m *LayerRange) String() string { return proto.CompactTextString(m) }
func (*LayerRange) ProtoMessage()    {}
func (*LayerRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c5943fc410b6190, []int{0}
}
func (m *LayerRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LayerRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LayerRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LayerRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LayerRange.Merge(m, src)
}
func (m *LayerRange) XXX_Size() int {
	return m.Size()
}
func (m *LayerRange) XXX_DiscardUnknown() {
	xxx_messageInfo_LayerRange.DiscardUnknown(m)
}

var xxx_messageInfo_LayerRange proto.InternalMessageInfo

func (m *LayerRange) GetStartLayer() uint64 {
	if m != nil {
		return m.StartLayer
	}
	return 0
}

func (m *LayerRange) GetEndLayer() uint64 {
	if m != nil {
		return m.EndLayer
	}
	return 0
}

// SubnetConfig represents a subnet configuration for layer-based sharding
type SubnetConfig struct {
	// subnet_id is the unique identifier for this subnet
	SubnetId uint64 `protobuf:"varint,1,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// layer_range defines which layers this subnet trains
	LayerRange LayerRange `protobuf:"bytes,2,opt,name=layer_range,json=layerRange,proto3" json:"layer_range"`
	// assigned_miners is the list of miner addresses assigned to this subnet
	AssignedMiners []string `protobuf:"bytes,3,rep,name=assigned_miners,json=assignedMiners,proto3" json:"assigned_miners,omitempty"`
	// activation_hash is the IPFS hash of layer activations produced by this subnet
	ActivationHash string `protobuf:"bytes,4,opt,name=activation_hash,json=activationHash,proto3" json:"activation_hash,omitempty"`
	// next_subnet_id is the subnet ID that receives activations from this subnet
	NextSubnetId uint64 `protobuf:"varint,5,opt,name=next_subnet_id,json=nextSubnetId,proto3" json:"next_subnet_id,omitempty"`
	// status is the current status of the subnet ("active", "aggregating", "completed")
	Status string `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
	// window_id is the training window this subnet belongs to
	WindowId uint64 `protobuf:"varint,7,opt,name=window_id,json=windowId,proto3" json:"window_id,omitempty"`
	// created_at is when this subnet was created
	CreatedAt time.Time `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
	// updated_at is when this subnet was last updated
	UpdatedAt time.Time `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at"`
}

func (m *SubnetConfig) Reset()         { *m = SubnetConfig{} }
func (m *SubnetConfig) String() string { return proto.CompactTextString(m) }
func (*SubnetConfig) ProtoMessage()    {}
func (*SubnetConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c5943fc410b6190, []int{1}
}
func (m *SubnetConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetConfig.Merge(m, src)
}
func (m *SubnetConfig) XXX_Size() int {
	return m.Size()
}
func (m *SubnetConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetConfig proto.InternalMessageInfo

func (m *SubnetConfig) GetSubnetId() uint64 {
	if m != nil {
		return m.SubnetId
	}
	return 0
}

func (m *SubnetConfig) GetLayerRange() LayerRange {
	if m != nil {
		return m.LayerRange
	}
	return LayerRange{}
}

func (m *SubnetConfig) GetAssignedMiners() []string {
	if m != nil {
		return m.AssignedMiners
	}
	return nil
}

func (m *SubnetConfig) GetActivationHash() string {
	if m != nil {
		return m.ActivationHash
	}
	return ""
}

func (m *SubnetConfig) GetNextSubnetId() uint64 {
	if m != nil {
		return m.NextSubnetId
	}
	return 0
}

func (m *SubnetConfig) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *SubnetConfig) GetWindowId() uint64 {
	if m != nil {
		return m.WindowId
	}
	return 0
}

func (m *SubnetConfig) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *SubnetConfig) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

// ActivationTransmission represents activation data transmission between subnets
type ActivationTransmission struct {
	// transmission_id is the unique identifier for this transmission
	TransmissionId uint64 `protobuf:"varint,1,opt,name=transmission_id,json=transmissionId,proto3" json:"transmission_id,omitempty"`
	// from_subnet_id is the subnet ID that produced the activations
	FromSubnetId uint64 `protobuf:"varint,2,opt,name=from_subnet_id,json=fromSubnetId,proto3" json:"from_subnet_id,omitempty"`
	// to_subnet_id is the subnet ID that receives the activations
	ToSubnetId uint64 `protobuf:"varint,3,opt,name=to_subnet_id,json=toSubnetId,proto3" json:"to_subnet_id,omitempty"`
	// activation_hash is the IPFS hash of layer activations
	ActivationHash string `protobuf:"bytes,4,opt,name=activation_hash,json=activationHash,proto3" json:"activation_hash,omitempty"`
	// layer_output is compressed activation data (optional, for verification)
	LayerOutput string `protobuf:"bytes,5,opt,name=layer_output,json=layerOutput,proto3" json:"layer_output,omitempty"`
	// timestamp is when this transmission occurred
	Timestamp time.Time `protobuf:"bytes,6,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// signature is the subnet proposer signature for verification
	Signature []byte `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty"`
	// verified indicates whether this transmission has been verified
	Verified bool `protobuf:"varint,8,opt,name=verified,proto3" json:"verified,omitempty"`
}

func (m *ActivationTransmission) Reset()         { *m = ActivationTransmission{} }
func (m *ActivationTransmission) String() string { return proto.CompactTextString(m) }
func (*ActivationTransmission) ProtoMessage()    {}
func (*ActivationTransmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c5943fc410b6190, []int{2}
}
func (m *ActivationTransmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivationTransmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivationTransmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivationTransmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivationTransmission.Merge(m, src)
}
func (m *ActivationTransmission) XXX_Size() int {
	return m.Size()
}
func (m *ActivationTransmission) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivationTransmission.DiscardUnknown(m)
}

var xxx_messageInfo_ActivationTransmission proto.InternalMessageInfo

func (m *ActivationTransmission) GetTransmissionId() uint64 {
	if m != nil {
		return m.TransmissionId
	}
	return 0
}

func (m *ActivationTransmission) GetFromSubnetId() uint64 {
	if m != nil {
		return m.FromSubnetId
	}
	return 0
}

func (m *ActivationTransmission) GetToSubnetId() uint64 {
	if m != nil {
		return m.ToSubnetId
	}
	return 0
}

func (m *ActivationTransmission) GetActivationHash() string {
	if m != nil {
		return m.ActivationHash
	}
	return ""
}

func (m *ActivationTransmission) GetLayerOutput() string {
	if m != nil {
		return m.LayerOutput
	}
	return ""
}

func (m *ActivationTransmission) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *ActivationTransmission) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *ActivationTransmission) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

// SubnetTrainingWorkflow represents a complete subnet-based training workflow
type SubnetTrainingWorkflow struct {
	// workflow_id is the unique identifier for this workflow
	WorkflowId uint64 `protobuf:"varint,1,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	// window_id is the training window this workflow belongs to
	WindowId uint64 `protobuf:"varint,2,opt,name=window_id,json=windowId,proto3" json:"window_id,omitempty"`
	// subnets is the list of subnet configurations in this workflow
	Subnets []SubnetConfig `protobuf:"bytes,3,rep,name=subnets,proto3" json:"subnets"`
	// activation_chain is the list of IPFS hashes linking subnet outputs sequentially
	ActivationChain []string `protobuf:"bytes,4,rep,name=activation_chain,json=activationChain,proto3" json:"activation_chain,omitempty"`
	// global_seed is the deterministic seed derived from block hash
	GlobalSeed []byte `protobuf:"bytes,5,opt,name=global_seed,json=globalSeed,proto3" json:"global_seed,omitempty"`
	// status is the current status of the workflow ("initializing", "active", "completed")
	Status string `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
	// created_at is when this workflow was created
	CreatedAt time.Time `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
	// completed_at is when this workflow was completed (if applicable)
	CompletedAt *time.Time `protobuf:"bytes,8,opt,name=completed_at,json=completedAt,proto3,stdtime" json:"completed_at,omitempty"`
}

func (m *SubnetTrainingWorkflow) Reset()         { *m = SubnetTrainingWorkflow{} }
func (m *SubnetTrainingWorkflow) String() string { return proto.CompactTextString(m) }
func (*SubnetTrainingWorkflow) ProtoMessage()    {}
func (*SubnetTrainingWorkflow) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c5943fc410b6190, []int{3}
}
func (m *SubnetTrainingWorkflow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetTrainingWorkflow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetTrainingWorkflow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetTrainingWorkflow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetTrainingWorkflow.Merge(m, src)
}
func (m *SubnetTrainingWorkflow) XXX_Size() int {
	return m.Size()
}
func (m *SubnetTrainingWorkflow) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetTrainingWorkflow.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetTrainingWorkflow proto.InternalMessageInfo

func (m *SubnetTrainingWorkflow) GetWorkflowId() uint64 {
	if m != nil {
		return m.WorkflowId
	}
	return 0
}

func (m *SubnetTrainingWorkflow) GetWindowId() uint64 {
	if m != nil {
		return m.WindowId
	}
	return 0
}

func (m *SubnetTrainingWorkflow) GetSubnets() []SubnetConfig {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *SubnetTrainingWorkflow) GetActivationChain() []string {
	if m != nil {
		return m.ActivationChain
	}
	return nil
}

func (m *SubnetTrainingWorkflow) GetGlobalSeed() []byte {
	if m != nil {
		return m.GlobalSeed
	}
	return nil
}

func (m *SubnetTrainingWorkflow) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *SubnetTrainingWorkflow) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *SubnetTrainingWorkflow) GetCompletedAt() *time.Time {
	if m != nil {
		return m.CompletedAt
	}
	return nil
}

func init() {
	proto.RegisterType((*LayerRange)(nil), "remes.remes.v1.LayerRange")
	proto.RegisterType((*SubnetConfig)(nil), "remes.remes.v1.SubnetConfig")
	proto.RegisterType((*ActivationTransmission)(nil), "remes.remes.v1.ActivationTransmission")
	proto.RegisterType((*SubnetTrainingWorkflow)(nil), "remes.remes.v1.SubnetTrainingWorkflow")
}

func init() { proto.RegisterFile("remes/remes/v1/subnet.proto", fileDescriptor_3c5943fc410b6190) }

var fileDescriptor_3c5943fc410b6190 = []byte{
	// 702 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x53, 0xcd, 0x6e, 0x13, 0x3b,
	0x14, 0xce, 0x34, 0xb9, 0x6d, 0xc6, 0x19, 0xe5, 0xde, 0x3b, 0xa0, 0x6a, 0x94, 0x56, 0x49, 0x1a,
	0x2a, 0x51, 0x90, 0x9a, 0xa8, 0x65, 0x57, 0xb1, 0x49, 0xba, 0x80, 0x48, 0x20, 0xa4, 0x69, 0x25,
	0x24, 0x36, 0x23, 0x27, 0xe3, 0x4c, 0x2c, 0x66, 0xec, 0xc8, 0xf6, 0x24, 0xed, 0x96, 0x25, 0xab,
	0x3e, 0x02, 0x8f, 0xc0, 0x86, 0x77, 0xa8, 0x58, 0x75, 0xc9, 0x0a, 0x50, 0xbb, 0x80, 0xc7, 0x40,
	0xb6, 0xe7, 0x2f, 0x55, 0x2b, 0xb5, 0x6c, 0x2c, 0xfb, 0xf3, 0x39, 0xc7, 0x3e, 0xdf, 0x77, 0x3e,
	0xb0, 0xc1, 0x50, 0x84, 0x78, 0x4f, 0xaf, 0xf3, 0xbd, 0x1e, 0x8f, 0x47, 0x04, 0x89, 0xee, 0x8c,
	0x51, 0x41, 0xed, 0xba, 0x82, 0xbb, 0x7a, 0x9d, 0xef, 0x35, 0xfe, 0x87, 0x11, 0x26, 0xb4, 0xa7,
	0x56, 0x1d, 0xd2, 0x78, 0x18, 0xd0, 0x80, 0xaa, 0x6d, 0x4f, 0xee, 0x12, 0xb4, 0x15, 0x50, 0x1a,
	0x84, 0xa8, 0xa7, 0x4e, 0xa3, 0x78, 0xd2, 0x13, 0x38, 0x42, 0x5c, 0xc0, 0x68, 0xa6, 0x03, 0x3a,
	0x11, 0x00, 0xaf, 0xe0, 0x29, 0x62, 0x2e, 0x24, 0x01, 0xb2, 0x5b, 0xa0, 0xc6, 0x05, 0x64, 0xc2,
	0x0b, 0x25, 0xe6, 0x18, 0x6d, 0x63, 0xa7, 0xe2, 0x02, 0x05, 0xa9, 0x28, 0x7b, 0x03, 0x98, 0x88,
	0xf8, 0xc9, 0xf5, 0x8a, 0xba, 0xae, 0x22, 0xe2, 0xab, 0xcb, 0x83, 0xad, 0xdf, 0x9f, 0x5a, 0xc6,
	0xc7, 0x5f, 0x9f, 0x9f, 0x3a, 0xba, 0x8b, 0x93, 0xa4, 0x9b, 0xfc, 0x81, 0xce, 0xd7, 0x32, 0xb0,
	0x8e, 0x54, 0x67, 0x87, 0x94, 0x4c, 0x70, 0x20, 0x0b, 0xea, 0x4e, 0x3d, 0xec, 0x27, 0xef, 0x55,
	0x35, 0x30, 0xf4, 0xed, 0x3e, 0xa8, 0xa9, 0x97, 0x3c, 0x26, 0x93, 0xd5, 0x7b, 0xb5, 0xfd, 0x46,
	0x77, 0x99, 0x8c, 0x6e, 0x5e, 0x7e, 0x50, 0x39, 0xff, 0xde, 0x2a, 0xb9, 0x20, 0xcc, 0x3b, 0x7a,
	0x0c, 0xfe, 0x85, 0x9c, 0xe3, 0x80, 0x20, 0xdf, 0x8b, 0x30, 0x41, 0x8c, 0x3b, 0xe5, 0x76, 0x79,
	0xc7, 0x74, 0xeb, 0x29, 0xfc, 0x5a, 0xa1, 0x2a, 0x70, 0x2c, 0xf0, 0x1c, 0x0a, 0x4c, 0x89, 0x37,
	0x85, 0x7c, 0xea, 0x54, 0xda, 0x86, 0x0a, 0xcc, 0xe0, 0x97, 0x90, 0x4f, 0xed, 0x6d, 0x50, 0x27,
	0xe8, 0x44, 0x78, 0xf9, 0xb7, 0xff, 0x51, 0xdf, 0xb6, 0x24, 0x7a, 0x94, 0x7e, 0x7d, 0x1d, 0xac,
	0x72, 0x01, 0x45, 0xcc, 0x9d, 0x55, 0x55, 0x25, 0x39, 0xc9, 0x7e, 0x17, 0x98, 0xf8, 0x74, 0x21,
	0x13, 0xd7, 0x74, 0xbf, 0x1a, 0x18, 0xfa, 0xf6, 0x21, 0x00, 0x63, 0x86, 0xa0, 0x40, 0xbe, 0x07,
	0x85, 0x53, 0x4d, 0xda, 0xd5, 0x12, 0x76, 0x53, 0x09, 0xbb, 0xc7, 0xa9, 0x84, 0x83, 0xaa, 0x6c,
	0xf7, 0xec, 0x47, 0xcb, 0x70, 0xcd, 0x24, 0xaf, 0x2f, 0x64, 0x91, 0x78, 0xe6, 0xa7, 0x45, 0xcc,
	0xfb, 0x14, 0x49, 0xf2, 0xfa, 0xe2, 0xe0, 0x51, 0x2a, 0x65, 0x63, 0x59, 0xca, 0xa2, 0x76, 0x9d,
	0x0f, 0x65, 0xb0, 0xde, 0xcf, 0xc8, 0x39, 0x66, 0x90, 0xf0, 0x08, 0x73, 0x8e, 0x29, 0x91, 0x6c,
	0x8a, 0xc2, 0x39, 0x17, 0xb7, 0x5e, 0x84, 0x87, 0xbe, 0x64, 0x73, 0xc2, 0x68, 0x54, 0x60, 0x53,
	0x4f, 0x95, 0x25, 0xd1, 0x8c, 0xcd, 0x36, 0xb0, 0x04, 0x2d, 0xc4, 0x94, 0xf5, 0x60, 0x0a, 0x9a,
	0x45, 0xdc, 0x59, 0xbe, 0x2d, 0x60, 0xe9, 0x99, 0xa2, 0xb1, 0x98, 0xc5, 0x42, 0x89, 0x67, 0xba,
	0x7a, 0xce, 0xde, 0x28, 0xc8, 0x1e, 0x00, 0x33, 0xb3, 0x89, 0x92, 0xef, 0xce, 0x04, 0x66, 0x69,
	0xf6, 0x26, 0x30, 0xe5, 0x78, 0x41, 0x11, 0x33, 0xa4, 0x74, 0xb6, 0xdc, 0x1c, 0xb0, 0x1b, 0xa0,
	0x3a, 0x47, 0x0c, 0x4f, 0x30, 0xf2, 0x95, 0xcc, 0x55, 0x37, 0x3b, 0x1f, 0xec, 0xa6, 0xd4, 0x6f,
	0x2f, 0x53, 0x7f, 0x33, 0xd3, 0x9d, 0x2f, 0x65, 0xb0, 0xae, 0x59, 0x38, 0x66, 0x10, 0x13, 0x4c,
	0x82, 0xb7, 0x94, 0xbd, 0x9f, 0x84, 0x74, 0x21, 0xdd, 0xbc, 0x48, 0xf6, 0xb9, 0x00, 0x20, 0x85,
	0x86, 0xfe, 0xf2, 0x30, 0xae, 0x5c, 0x1b, 0xc6, 0xe7, 0x60, 0x4d, 0x13, 0xae, 0x1d, 0x53, 0xdb,
	0xdf, 0xbc, 0x6e, 0xbc, 0xe2, 0x30, 0x24, 0xd6, 0x4b, 0x53, 0xec, 0x27, 0xe0, 0xbf, 0x82, 0x1e,
	0xe3, 0x29, 0xc4, 0xc4, 0xa9, 0x28, 0xe3, 0x15, 0x74, 0x3a, 0x94, 0xb0, 0xfc, 0x66, 0x10, 0xd2,
	0x11, 0x0c, 0x3d, 0x8e, 0x90, 0x76, 0x93, 0xe5, 0x02, 0x0d, 0x1d, 0x21, 0x74, 0xbb, 0x97, 0x96,
	0xed, 0xb2, 0xf6, 0x77, 0x76, 0x79, 0x01, 0xac, 0x31, 0x8d, 0x66, 0x21, 0xba, 0x97, 0xeb, 0x0c,
	0x55, 0xa6, 0x96, 0x65, 0xf6, 0xc5, 0xad, 0xba, 0xdd, 0x2c, 0xce, 0x60, 0xf7, 0xfc, 0xb2, 0x69,
	0x5c, 0x5c, 0x36, 0x8d, 0x9f, 0x97, 0x4d, 0xe3, 0xec, 0xaa, 0x59, 0xba, 0xb8, 0x6a, 0x96, 0xbe,
	0x5d, 0x35, 0x4b, 0xef, 0x1e, 0x2c, 0xe7, 0x8b, 0xd3, 0x19, 0xe2, 0xa3, 0x55, 0xf5, 0x91, 0x67,
	0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x64, 0x2a, 0x5c, 0xbf, 0x27, 0x06, 0x00, 0x00,
}

func (this *LayerRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LayerRange)
	if !ok {
		that2, ok := that.(LayerRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartLayer != that1.StartLayer {
		return false
	}
	if this.EndLayer != that1.EndLayer {
		return false
	}
	return true
}
func (this *SubnetConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubnetConfig)
	if !ok {
		that2, ok := that.(SubnetConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetId != that1.SubnetId {
		return false
	}
	if !this.LayerRange.Equal(&that1.LayerRange) {
		return false
	}
	if len(this.AssignedMiners) != len(that1.AssignedMiners) {
		return false
	}
	for i := range this.AssignedMiners {
		if this.AssignedMiners[i] != that1.AssignedMiners[i] {
			return false
		}
	}
	if this.ActivationHash != that1.ActivationHash {
		return false
	}
	if this.NextSubnetId != that1.NextSubnetId {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.WindowId != that1.WindowId {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	return true
}
func (this *ActivationTransmission) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActivationTransmission)
	if !ok {
		that2, ok := that.(ActivationTransmission)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TransmissionId != that1.TransmissionId {
		return false
	}
	if this.FromSubnetId != that1.FromSubnetId {
		return false
	}
	if this.ToSubnetId != that1.ToSubnetId {
		return false
	}
	if this.ActivationHash != that1.ActivationHash {
		return false
	}
	if this.LayerOutput != that1.LayerOutput {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	if this.Verified != that1.Verified {
		return false
	}
	return true
}
func (this *SubnetTrainingWorkflow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubnetTrainingWorkflow)
	if !ok {
		that2, ok := that.(SubnetTrainingWorkflow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.WorkflowId != that1.WorkflowId {
		return false
	}
	if this.WindowId != that1.WindowId {
		return false
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if !this.Subnets[i].Equal(&that1.Subnets[i]) {
			return false
		}
	}
	if len(this.ActivationChain) != len(that1.ActivationChain) {
		return false
	}
	for i := range this.ActivationChain {
		if this.ActivationChain[i] != that1.ActivationChain[i] {
			return false
		}
	}
	if !bytes.Equal(this.GlobalSeed, that1.GlobalSeed) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if that1.CompletedAt == nil {
		if this.CompletedAt != nil {
			return false
		}
	} else if !this.CompletedAt.Equal(*that1.CompletedAt) {
		return false
	}
	return true
}
func (m *LayerRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LayerRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LayerRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndLayer != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.EndLayer))
		i--
		dAtA[i] = 0x10
	}
	if m.StartLayer != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.StartLayer))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubnetConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintSubnet(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x4a
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintSubnet(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x42
	if m.WindowId != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.WindowId))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x32
	}
	if m.NextSubnetId != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.NextSubnetId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ActivationHash) > 0 {
		i -= len(m.ActivationHash)
		copy(dAtA[i:], m.ActivationHash)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.ActivationHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssignedMiners) > 0 {
		for iNdEx := len(m.AssignedMiners) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AssignedMiners[iNdEx])
			copy(dAtA[i:], m.AssignedMiners[iNdEx])
			i = encodeVarintSubnet(dAtA, i, uint64(len(m.AssignedMiners[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.LayerRange.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubnet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.SubnetId != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.SubnetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActivationTransmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivationTransmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivationTransmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Verified {
		i--
		if m.Verified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintSubnet(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x32
	if len(m.LayerOutput) > 0 {
		i -= len(m.LayerOutput)
		copy(dAtA[i:], m.LayerOutput)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.LayerOutput)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ActivationHash) > 0 {
		i -= len(m.ActivationHash)
		copy(dAtA[i:], m.ActivationHash)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.ActivationHash)))
		i--
		dAtA[i] = 0x22
	}
	if m.ToSubnetId != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.ToSubnetId))
		i--
		dAtA[i] = 0x18
	}
	if m.FromSubnetId != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.FromSubnetId))
		i--
		dAtA[i] = 0x10
	}
	if m.TransmissionId != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.TransmissionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubnetTrainingWorkflow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetTrainingWorkflow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetTrainingWorkflow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CompletedAt != nil {
		n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.CompletedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CompletedAt):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintSubnet(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x42
	}
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintSubnet(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x3a
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.GlobalSeed) > 0 {
		i -= len(m.GlobalSeed)
		copy(dAtA[i:], m.GlobalSeed)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.GlobalSeed)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ActivationChain) > 0 {
		for iNdEx := len(m.ActivationChain) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ActivationChain[iNdEx])
			copy(dAtA[i:], m.ActivationChain[iNdEx])
			i = encodeVarintSubnet(dAtA, i, uint64(len(m.ActivationChain[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Subnets) > 0 {
		for iNdEx := len(m.Subnets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubnet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.WindowId != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.WindowId))
		i--
		dAtA[i] = 0x10
	}
	if m.WorkflowId != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.WorkflowId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSubnet(dAtA []byte, offset int, v uint64) int {
	offset -= sovSubnet(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LayerRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartLayer != 0 {
		n += 1 + sovSubnet(uint64(m.StartLayer))
	}
	if m.EndLayer != 0 {
		n += 1 + sovSubnet(uint64(m.EndLayer))
	}
	return n
}

func (m *SubnetConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetId != 0 {
		n += 1 + sovSubnet(uint64(m.SubnetId))
	}
	l = m.LayerRange.Size()
	n += 1 + l + sovSubnet(uint64(l))
	if len(m.AssignedMiners) > 0 {
		for _, s := range m.AssignedMiners {
			l = len(s)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	l = len(m.ActivationHash)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.NextSubnetId != 0 {
		n += 1 + sovSubnet(uint64(m.NextSubnetId))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.WindowId != 0 {
		n += 1 + sovSubnet(uint64(m.WindowId))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovSubnet(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovSubnet(uint64(l))
	return n
}

func (m *ActivationTransmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransmissionId != 0 {
		n += 1 + sovSubnet(uint64(m.TransmissionId))
	}
	if m.FromSubnetId != 0 {
		n += 1 + sovSubnet(uint64(m.FromSubnetId))
	}
	if m.ToSubnetId != 0 {
		n += 1 + sovSubnet(uint64(m.ToSubnetId))
	}
	l = len(m.ActivationHash)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	l = len(m.LayerOutput)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovSubnet(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.Verified {
		n += 2
	}
	return n
}

func (m *SubnetTrainingWorkflow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkflowId != 0 {
		n += 1 + sovSubnet(uint64(m.WorkflowId))
	}
	if m.WindowId != 0 {
		n += 1 + sovSubnet(uint64(m.WindowId))
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if len(m.ActivationChain) > 0 {
		for _, s := range m.ActivationChain {
			l = len(s)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	l = len(m.GlobalSeed)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovSubnet(uint64(l))
	if m.CompletedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CompletedAt)
		n += 1 + l + sovSubnet(uint64(l))
	}
	return n
}

func sovSubnet(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSubnet(x uint64) (n int) {
	return sovSubnet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LayerRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LayerRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LayerRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartLayer", wireType)
			}
			m.StartLayer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartLayer |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndLayer", wireType)
			}
			m.EndLayer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndLayer |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			m.SubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LayerRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LayerRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedMiners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignedMiners = append(m.AssignedMiners, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivationHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSubnetId", wireType)
			}
			m.NextSubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowId", wireType)
			}
			m.WindowId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivationTransmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivationTransmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivationTransmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransmissionId", wireType)
			}
			m.TransmissionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransmissionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromSubnetId", wireType)
			}
			m.FromSubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromSubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToSubnetId", wireType)
			}
			m.ToSubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToSubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivationHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LayerOutput", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LayerOutput = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verified = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetTrainingWorkflow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetTrainingWorkflow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetTrainingWorkflow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowId", wireType)
			}
			m.WorkflowId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkflowId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowId", wireType)
			}
			m.WindowId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, SubnetConfig{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivationChain = append(m.ActivationChain, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalSeed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlobalSeed = append(m.GlobalSeed[:0], dAtA[iNdEx:postIndex]...)
			if m.GlobalSeed == nil {
				m.GlobalSeed = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletedAt == nil {
				m.CompletedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.CompletedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSubnet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSubnet
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSubnet
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSubnet
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSubnet        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSubnet          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSubnet = fmt.Errorf("proto: unexpected end of group")
)
